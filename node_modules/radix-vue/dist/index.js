import { shallowRef as zn, watchEffect as ee, readonly as Ot, effectScope as Ps, customRef as Yn, ref as S, computed as D, watch as X, nextTick as Z, getCurrentScope as ia, onScopeDispose as ra, unref as l, toRef as Ts, getCurrentInstance as Xe, onMounted as Y, onBeforeUpdate as Bs, onUpdated as As, provide as W, inject as T, toHandlerKey as Is, camelize as ua, onUnmounted as ue, Fragment as re, onBeforeUnmount as da, defineComponent as w, mergeProps as k, cloneVNode as Ds, h as Gt, openBlock as g, createBlock as C, withCtx as y, renderSlot as _, toRefs as G, useSlots as Gn, createVNode as L, createCommentVNode as J, withKeys as pe, createElementBlock as Q, withModifiers as oe, normalizeStyle as ie, shallowReadonly as Qe, mergeDefaults as ca, createElementVNode as St, renderList as Xn, withDirectives as tn, vModelDynamic as xs, vShow as ks, reactive as pa, resolveDynamicComponent as Fe, normalizeProps as N, guardReactiveProps as K, createTextVNode as de, toDisplayString as st, Teleport as lt, isRef as it, vModelRadio as Ms, onBeforeMount as fa, vModelSelect as Rs } from "vue";
function Fs(n, t) {
  var e;
  const o = zn();
  return ee(() => {
    o.value = n();
  }, {
    ...t,
    flush: (e = t == null ? void 0 : t.flush) != null ? e : "sync"
  }), Ot(o);
}
function Ns(n, t) {
  let e, o, a;
  const s = S(!0), i = () => {
    s.value = !0, a();
  };
  X(n, i, { flush: "sync" });
  const r = typeof t == "function" ? t : t.get, u = typeof t == "function" ? void 0 : t.set, d = Yn((p, c) => (o = p, a = c, {
    get() {
      return s.value && (e = r(), s.value = !1), o(), e;
    },
    set(f) {
      u == null || u(f);
    }
  }));
  return Object.isExtensible(d) && (d.trigger = i), d;
}
function rt(n) {
  return ia() ? (ra(n), !0) : !1;
}
function Jn(n) {
  let t = !1, e;
  const o = Ps(!0);
  return (...a) => (t || (e = o.run(() => n(...a)), t = !0), e);
}
function me(n) {
  return typeof n == "function" ? n() : l(n);
}
const Ce = typeof window < "u" && typeof document < "u", Ls = (n) => typeof n < "u", Vs = Object.prototype.toString, Ks = (n) => Vs.call(n) === "[object Object]", Ko = (n, t, e) => Math.min(e, Math.max(t, n)), bt = () => {
}, Ho = /* @__PURE__ */ Hs();
function Hs() {
  var n;
  return Ce && ((n = window == null ? void 0 : window.navigator) == null ? void 0 : n.userAgent) && /* @__PURE__ */ /iP(ad|hone|od)/.test(window.navigator.userAgent);
}
function Ws(n, t) {
  function e(...o) {
    return new Promise((a, s) => {
      Promise.resolve(n(() => t.apply(this, o), { fn: t, thisArg: this, args: o })).then(a).catch(s);
    });
  }
  return e;
}
function Us(n, t = {}) {
  let e, o, a = bt;
  const s = (r) => {
    clearTimeout(r), a(), a = bt;
  };
  return (r) => {
    const u = me(n), d = me(t.maxWait);
    return e && s(e), u <= 0 || d !== void 0 && d <= 0 ? (o && (s(o), o = null), Promise.resolve(r())) : new Promise((p, c) => {
      a = t.rejectOnCancel ? c : p, d && !o && (o = setTimeout(() => {
        e && s(e), o = null, p(r());
      }, d)), e = setTimeout(() => {
        o && s(o), o = null, p(r());
      }, u);
    });
  };
}
function va(...n) {
  if (n.length !== 1)
    return Ts(...n);
  const t = n[0];
  return typeof t == "function" ? Ot(Yn(() => ({ get: t, set: bt }))) : S(t);
}
function ma(n, t = 1e4) {
  return Yn((e, o) => {
    let a = me(n), s;
    const i = () => setTimeout(() => {
      a = me(n), o();
    }, me(t));
    return rt(() => {
      clearTimeout(s);
    }), {
      get() {
        return e(), a;
      },
      set(r) {
        a = r, o(), clearTimeout(s), s = i();
      }
    };
  });
}
function qn(n, t = 200, e = {}) {
  return Ws(
    Us(t, e),
    n
  );
}
function jn(n, t, e = {}) {
  const {
    immediate: o = !0
  } = e, a = S(!1);
  let s = null;
  function i() {
    s && (clearTimeout(s), s = null);
  }
  function r() {
    a.value = !1, i();
  }
  function u(...d) {
    i(), a.value = !0, s = setTimeout(() => {
      a.value = !1, s = null, n(...d);
    }, me(t));
  }
  return o && (a.value = !0, Ce && u()), rt(r), {
    isPending: Ot(a),
    start: u,
    stop: r
  };
}
function zs(n = 1e3, t = {}) {
  const {
    controls: e = !1,
    callback: o
  } = t, a = jn(
    o ?? bt,
    n,
    t
  ), s = D(() => !a.isPending.value);
  return e ? {
    ready: s,
    ...a
  } : s;
}
function Ys(n, t, e) {
  const o = X(n, (...a) => (Z(() => o()), t(...a)), e);
}
function ye(n) {
  var t;
  const e = me(n);
  return (t = e == null ? void 0 : e.$el) != null ? t : e;
}
const nn = Ce ? window : void 0, Tn = Ce ? window.document : void 0;
function ot(...n) {
  let t, e, o, a;
  if (typeof n[0] == "string" || Array.isArray(n[0]) ? ([e, o, a] = n, t = nn) : [t, e, o, a] = n, !t)
    return bt;
  Array.isArray(e) || (e = [e]), Array.isArray(o) || (o = [o]);
  const s = [], i = () => {
    s.forEach((p) => p()), s.length = 0;
  }, r = (p, c, f, v) => (p.addEventListener(c, f, v), () => p.removeEventListener(c, f, v)), u = X(
    () => [ye(t), me(a)],
    ([p, c]) => {
      if (i(), !p)
        return;
      const f = Ks(c) ? { ...c } : c;
      s.push(
        ...e.flatMap((v) => o.map((h) => r(p, v, h, f)))
      );
    },
    { immediate: !0, flush: "post" }
  ), d = () => {
    u(), i();
  };
  return rt(d), d;
}
function Gs(n) {
  return typeof n == "function" ? n : typeof n == "string" ? (t) => t.key === n : Array.isArray(n) ? (t) => n.includes(t.key) : () => !0;
}
function Zn(...n) {
  let t, e, o = {};
  n.length === 3 ? (t = n[0], e = n[1], o = n[2]) : n.length === 2 ? typeof n[1] == "object" ? (t = !0, e = n[0], o = n[1]) : (t = n[0], e = n[1]) : (t = !0, e = n[0]);
  const {
    target: a = nn,
    eventName: s = "keydown",
    passive: i = !1,
    dedupe: r = !1
  } = o, u = Gs(t);
  return ot(a, s, (p) => {
    p.repeat && me(r) || u(p) && e(p);
  }, i);
}
function on() {
  const n = S(!1);
  return Xe() && Y(() => {
    n.value = !0;
  }), n;
}
function Xs(n) {
  const t = on();
  return D(() => (t.value, !!n()));
}
function Js(n, t = {}) {
  const {
    immediate: e = !0,
    window: o = nn
  } = t, a = S(!1);
  let s = 0, i = null;
  function r(p) {
    if (!a.value || !o)
      return;
    const c = p - (s || p);
    n({ delta: c, timestamp: p }), s = p, i = o.requestAnimationFrame(r);
  }
  function u() {
    !a.value && o && (a.value = !0, i = o.requestAnimationFrame(r));
  }
  function d() {
    a.value = !1, i != null && o && (o.cancelAnimationFrame(i), i = null);
  }
  return e && u(), rt(d), {
    isActive: Ot(a),
    pause: d,
    resume: u
  };
}
function qs(n) {
  return JSON.parse(JSON.stringify(n));
}
function Be(n, t, e = {}) {
  const { window: o = nn, ...a } = e;
  let s;
  const i = Xs(() => o && "ResizeObserver" in o), r = () => {
    s && (s.disconnect(), s = void 0);
  }, u = D(
    () => Array.isArray(n) ? n.map((c) => ye(c)) : [ye(n)]
  ), d = X(
    u,
    (c) => {
      if (r(), i.value && o) {
        s = new ResizeObserver(t);
        for (const f of c)
          f && s.observe(f, a);
      }
    },
    { immediate: !0, flush: "post", deep: !0 }
  ), p = () => {
    r(), d();
  };
  return rt(p), {
    isSupported: i,
    stop: p
  };
}
function Bn(n) {
  return typeof Window < "u" && n instanceof Window ? n.document.documentElement : typeof Document < "u" && n instanceof Document ? n.documentElement : n;
}
function js(n, t) {
  const e = zn(t);
  return X(
    va(n),
    (o, a) => {
      e.value = a;
    },
    { flush: "sync" }
  ), Ot(e);
}
function ha(n) {
  const t = window.getComputedStyle(n);
  if (t.overflowX === "scroll" || t.overflowY === "scroll" || t.overflowX === "auto" && n.clientWidth < n.scrollWidth || t.overflowY === "auto" && n.clientHeight < n.scrollHeight)
    return !0;
  {
    const e = n.parentNode;
    return !e || e.tagName === "BODY" ? !1 : ha(e);
  }
}
function Zs(n) {
  const t = n || window.event, e = t.target;
  return ha(e) ? !1 : t.touches.length > 1 ? !0 : (t.preventDefault && t.preventDefault(), !1);
}
function Qs(n, t = !1) {
  const e = S(t);
  let o = null, a;
  X(va(n), (r) => {
    const u = Bn(me(r));
    if (u) {
      const d = u;
      a = d.style.overflow, e.value && (d.style.overflow = "hidden");
    }
  }, {
    immediate: !0
  });
  const s = () => {
    const r = Bn(me(n));
    !r || e.value || (Ho && (o = ot(
      r,
      "touchmove",
      (u) => {
        Zs(u);
      },
      { passive: !1 }
    )), r.style.overflow = "hidden", e.value = !0);
  }, i = () => {
    const r = Bn(me(n));
    !r || !e.value || (Ho && (o == null || o()), r.style.overflow = a, e.value = !1);
  };
  return rt(i), D({
    get() {
      return e.value;
    },
    set(r) {
      r ? s() : i();
    }
  });
}
function q(n, t, e, o = {}) {
  var a, s, i;
  const {
    clone: r = !1,
    passive: u = !1,
    eventName: d,
    deep: p = !1,
    defaultValue: c,
    shouldEmit: f
  } = o, v = Xe(), h = e || (v == null ? void 0 : v.emit) || ((a = v == null ? void 0 : v.$emit) == null ? void 0 : a.bind(v)) || ((i = (s = v == null ? void 0 : v.proxy) == null ? void 0 : s.$emit) == null ? void 0 : i.bind(v == null ? void 0 : v.proxy));
  let m = d;
  t || (t = "modelValue"), m = m || `update:${t.toString()}`;
  const b = (E) => r ? typeof r == "function" ? r(E) : qs(E) : E, $ = () => Ls(n[t]) ? b(n[t]) : c, O = (E) => {
    f ? f(E) && h(m, E) : h(m, E);
  };
  if (u) {
    const E = $(), P = S(E);
    let B = !1;
    return X(
      () => n[t],
      (I) => {
        B || (B = !0, P.value = b(I), Z(() => B = !1));
      }
    ), X(
      P,
      (I) => {
        !B && (I !== n[t] || p) && O(I);
      },
      { deep: p }
    ), P;
  } else
    return D({
      get() {
        return $();
      },
      set(E) {
        O(E);
      }
    });
}
function an(n, t, e, o = {}) {
  if (!t)
    return null;
  const {
    arrowKeyOptions: a = "both",
    attributeName: s = "data-radix-vue-collection-item",
    itemsArray: i = [],
    loop: r = !0,
    dir: u = "ltr",
    preventScroll: d = !0,
    focus: p = !1
  } = o, [c, f, v, h, m, b] = [
    n.key === "ArrowRight",
    n.key === "ArrowLeft",
    n.key === "ArrowUp",
    n.key === "ArrowDown",
    n.key === "Home",
    n.key === "End"
  ], $ = v || h, O = c || f;
  if (!m && !b && (!$ && !O || a === "vertical" && O || a === "horizontal" && $))
    return null;
  const E = e ? Array.from(e.querySelectorAll(`[${s}]`)) : i;
  if (!E.length)
    return null;
  d && n.preventDefault();
  let P = null;
  return O || $ ? P = ya(E, t, {
    goForward: $ ? h : u === "ltr" ? c : f,
    loop: r
  }) : m ? P = E.at(0) || null : b && (P = E.at(-1) || null), p && (P == null || P.focus()), P;
}
function ya(n, t, { goForward: e, loop: o }, a = n.length) {
  if (--a === 0)
    return null;
  const s = n.indexOf(t), i = e ? s + 1 : s - 1;
  if (!o && (i < 0 || i >= n.length))
    return null;
  const r = (i + n.length) % n.length, u = n[r];
  return u ? u.hasAttribute("disabled") && u.getAttribute("disabled") !== "false" ? ya(
    n,
    u,
    { goForward: e, loop: o },
    a
  ) : u : null;
}
function ga(n, t) {
  const e = S(n);
  function o(s) {
    return t[e.value][s] ?? e.value;
  }
  return {
    state: e,
    dispatch: (s) => {
      e.value = o(s);
    }
  };
}
let An = 0;
function Qn() {
  ee((n) => {
    if (!Ce)
      return;
    const t = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement(
      "afterbegin",
      t[0] ?? Wo()
    ), document.body.insertAdjacentElement(
      "beforeend",
      t[1] ?? Wo()
    ), An++, n(() => {
      An === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((e) => e.remove()), An--;
    });
  });
}
function Wo() {
  const n = document.createElement("span");
  return n.setAttribute("data-radix-focus-guard", ""), n.tabIndex = 0, n.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", n;
}
const el = "data-radix-vue-collection-item";
function le(n) {
  const t = n ?? Symbol();
  return { createCollection: (a) => {
    const s = S([]);
    function i() {
      const r = ye(a);
      return r ? s.value = Array.from(
        r.querySelectorAll(`[${el}]:not([data-disabled=true])`)
      ) : s.value = [];
    }
    return Bs(() => {
      s.value = [];
    }), Y(i), As(i), X(() => a == null ? void 0 : a.value, i, { immediate: !0 }), W(t, s), s;
  }, injectCollection: () => T(t, S([])) };
}
function ae(n) {
  const t = Xe(), e = t == null ? void 0 : t.type.emits, o = {};
  return e != null && e.length || console.warn(
    `No emitted event found. Please check component: ${t == null ? void 0 : t.type.__name}`
  ), e == null || e.forEach((a) => {
    o[Is(ua(a))] = (...s) => n(a, ...s);
  }), o;
}
function sn(n) {
  const t = Xe(), e = Object.keys((t == null ? void 0 : t.type.props) ?? {}).reduce((o, a) => {
    const s = (t == null ? void 0 : t.type.props[a]).default;
    return s !== void 0 && (o[a] = s), o;
  }, {});
  return Ns(() => ({ ...n }), () => {
    const o = {}, a = (t == null ? void 0 : t.vnode.props) ?? {};
    return Object.keys(a).forEach((s) => {
      o[ua(s)] = a[s];
    }), { ...e, ...o };
  });
}
function fe(n, t) {
  const e = sn(n), o = t ? ae(t) : {};
  return D(() => ({
    ...e.value,
    ...o
  }));
}
function ba() {
  const n = Xe();
  function t(e) {
    typeof e == "object" && (n.exposed = e, n.exposeProxy = e);
  }
  return t;
}
function _a(n) {
  const t = S(), e = D(() => {
    var a;
    return ((a = t.value) == null ? void 0 : a.width) ?? 0;
  }), o = D(() => {
    var a;
    return ((a = t.value) == null ? void 0 : a.height) ?? 0;
  });
  return Y(() => {
    const a = ye(n);
    if (a) {
      t.value = { width: a.offsetWidth, height: a.offsetHeight };
      const s = new ResizeObserver((i) => {
        if (!Array.isArray(i) || !i.length)
          return;
        const r = i[0];
        let u, d;
        if ("borderBoxSize" in r) {
          const p = r.borderBoxSize, c = Array.isArray(p) ? p[0] : p;
          u = c.inlineSize, d = c.blockSize;
        } else
          u = a.offsetWidth, d = a.offsetHeight;
        t.value = { width: u, height: d };
      });
      return s.observe(a, { box: "border-box" }), () => s.unobserve(a);
    } else
      t.value = void 0;
  }), {
    width: e,
    height: o
  };
}
var tl = function(n) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(n) ? n[0] : n;
  return t.ownerDocument.body;
}, et = /* @__PURE__ */ new WeakMap(), Nt = /* @__PURE__ */ new WeakMap(), Lt = {}, In = 0, wa = function(n) {
  return n && (n.host || wa(n.parentNode));
}, nl = function(n, t) {
  return t.map(function(e) {
    if (n.contains(e))
      return e;
    var o = wa(e);
    return o && n.contains(o) ? o : (console.error("aria-hidden", e, "in not contained inside", n, ". Doing nothing"), null);
  }).filter(function(e) {
    return !!e;
  });
}, ol = function(n, t, e, o) {
  var a = nl(t, Array.isArray(n) ? n : [n]);
  Lt[e] || (Lt[e] = /* @__PURE__ */ new WeakMap());
  var s = Lt[e], i = [], r = /* @__PURE__ */ new Set(), u = new Set(a), d = function(c) {
    !c || r.has(c) || (r.add(c), d(c.parentNode));
  };
  a.forEach(d);
  var p = function(c) {
    !c || u.has(c) || Array.prototype.forEach.call(c.children, function(f) {
      if (r.has(f))
        p(f);
      else {
        var v = f.getAttribute(o), h = v !== null && v !== "false", m = (et.get(f) || 0) + 1, b = (s.get(f) || 0) + 1;
        et.set(f, m), s.set(f, b), i.push(f), m === 1 && h && Nt.set(f, !0), b === 1 && f.setAttribute(e, "true"), h || f.setAttribute(o, "true");
      }
    });
  };
  return p(t), r.clear(), In++, function() {
    i.forEach(function(c) {
      var f = et.get(c) - 1, v = s.get(c) - 1;
      et.set(c, f), s.set(c, v), f || (Nt.has(c) || c.removeAttribute(o), Nt.delete(c)), v || c.removeAttribute(e);
    }), In--, In || (et = /* @__PURE__ */ new WeakMap(), et = /* @__PURE__ */ new WeakMap(), Nt = /* @__PURE__ */ new WeakMap(), Lt = {});
  };
}, al = function(n, t, e) {
  e === void 0 && (e = "data-aria-hidden");
  var o = Array.from(Array.isArray(n) ? n : [n]), a = t || tl(n);
  return a ? (o.push.apply(o, Array.from(a.querySelectorAll("[aria-live]"))), ol(o, a, e, "aria-hidden")) : function() {
    return null;
  };
};
function Pt(n) {
  let t;
  X(() => ye(n), (e) => {
    e ? t = al(e) : t && t();
  }), ue(() => {
    t();
  });
}
const sl = Jn(() => ({ count: S(0) }));
function te(n) {
  const { count: t } = sl();
  return n || t.value++, n || `radix-${t.value}`;
}
function ln(n) {
  return n ? n.flatMap((t) => t.type === re ? ln(t.children) : [t]) : [];
}
const ll = Jn(() => S(0));
function Tt(n) {
  const t = ll(), e = Qs(Tn == null ? void 0 : Tn.body, !1), o = D({
    get() {
      return e.value;
    },
    set(a) {
      if (Ce)
        if (a) {
          const s = window.innerWidth - document.documentElement.clientWidth;
          s > 0 && (document.body.style.paddingRight = `${s}px`), Z(() => {
            document.body.style.pointerEvents = "none", e.value = !0;
          });
        } else
          document.body.style.paddingRight = "", document.body.style.pointerEvents = "", e.value = !1;
    }
  });
  return n && (t.value++, o.value = n), da(() => {
    n && (t.value--, t.value === 0 && (document.body.style.paddingRight = "", document.body.style.pointerEvents = ""));
  }), o;
}
function eo(n) {
  const t = ma("", 1e3);
  return {
    search: t,
    handleTypeaheadSearch: (a) => {
      var c, f;
      t.value = t.value + a;
      const s = n.value, i = document.activeElement, r = ((f = (c = s.find((v) => v === i)) == null ? void 0 : c.textContent) == null ? void 0 : f.trim()) ?? "", u = s.map((v) => {
        var h;
        return ((h = v.textContent) == null ? void 0 : h.trim()) ?? "";
      }), d = il(u, t.value, r), p = s.find(
        (v) => {
          var h;
          return ((h = v.textContent) == null ? void 0 : h.trim()) === d;
        }
      );
      p && p.focus();
    },
    resetTypeahead: () => {
      t.value = "";
    }
  };
}
function to(n, t) {
  return n.map((e, o) => n[(t + o) % n.length]);
}
function il(n, t, e) {
  const a = t.length > 1 && Array.from(t).every((d) => d === t[0]) ? t[0] : t, s = e ? n.indexOf(e) : -1;
  let i = to(n, Math.max(s, 0));
  a.length === 1 && (i = i.filter((d) => d !== e));
  const u = i.find(
    (d) => d.toLowerCase().startsWith(a.toLowerCase())
  );
  return u !== e ? u : void 0;
}
function Ca(n) {
  const t = Symbol(
    `${n}Context`
  );
  return [(a) => {
    const s = T(t, a);
    if (s)
      return s;
    if (s === null)
      return null;
    throw new Error(`Component must be used within ${n}`);
  }, (a) => {
    W(t, a);
  }];
}
const rl = w({
  name: "PrimitiveSlot",
  inheritAttrs: !1,
  setup(n, { attrs: t, slots: e }) {
    return () => {
      var i, r;
      if (!e.default)
        return null;
      const o = ln(e.default()), [a, ...s] = o;
      if (Object.keys(t).length > 0) {
        (i = a.props) == null || delete i.ref;
        const u = k(t, a.props ?? {});
        t.class && ((r = a.props) != null && r.class) && delete a.props.class;
        const d = Ds(a, u);
        for (const p in u)
          p.startsWith("on") && (d.props || (d.props = {}), d.props[p] = u[p]);
        return o.length === 1 ? d : [d, ...s];
      }
      return o;
    };
  }
}), M = w({
  name: "Primitive",
  inheritAttrs: !1,
  props: {
    asChild: {
      type: Boolean,
      default: !1
    },
    as: {
      type: String,
      default: "div"
    }
  },
  setup(n, { attrs: t, slots: e }) {
    return (n.asChild ? "template" : n.as) !== "template" ? () => Gt(n.as, t, { default: e.default }) : () => Gt(rl, t, { default: e.default });
  }
});
function H() {
  const n = S(), t = D(() => {
    var e, o;
    return ["#text", "#comment"].includes((e = n.value) == null ? void 0 : e.$el.nodeName) ? (o = n.value) == null ? void 0 : o.$el.nextElementSibling : ye(n);
  });
  return {
    primitiveElement: n,
    currentElement: t
  };
}
const no = Symbol(), ul = /* @__PURE__ */ w({
  __name: "CollapsibleRoot",
  props: {
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:open"],
  setup(n, { expose: t, emit: e }) {
    const o = n, a = q(o, "open", e, {
      defaultValue: o.defaultOpen,
      passive: !0
    }), s = q(o, "disabled");
    return W(no, {
      contentId: te(),
      disabled: s,
      open: a,
      onOpenToggle: () => {
        a.value = !a.value;
      }
    }), t({ open: a }), (i, r) => (g(), C(l(M), {
      as: i.as,
      "as-child": o.asChild,
      "data-state": o.open ? "open" : "closed",
      "data-disabled": o.disabled ? "" : void 0
    }, {
      default: y(() => [
        _(i.$slots, "default", { open: l(a) })
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-state", "data-disabled"]));
  }
}), dl = /* @__PURE__ */ w({
  __name: "CollapsibleTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(n) {
    const t = n, e = T(no);
    return (o, a) => {
      var s, i, r, u, d, p, c, f;
      return g(), C(l(M), {
        type: o.as === "button" ? "button" : void 0,
        as: o.as,
        "as-child": t.asChild,
        "aria-controls": (s = l(e)) == null ? void 0 : s.contentId,
        "aria-expanded": ((i = l(e)) == null ? void 0 : i.open.value) || !1,
        "data-state": (r = l(e)) != null && r.open.value ? "open" : "closed",
        "data-disabled": (d = (u = l(e)) == null ? void 0 : u.disabled) != null && d.value ? "" : void 0,
        disabled: (c = (p = l(e)) == null ? void 0 : p.disabled) == null ? void 0 : c.value,
        onClick: (f = l(e)) == null ? void 0 : f.onOpenToggle
      }, {
        default: y(() => [
          _(o.$slots, "default")
        ]),
        _: 3
      }, 8, ["type", "as", "as-child", "aria-controls", "aria-expanded", "data-state", "data-disabled", "disabled", "onClick"]);
    };
  }
});
function cl(n, t) {
  const e = S({}), o = S("none"), a = n.value ? "mounted" : "unmounted", { state: s, dispatch: i } = ga(a, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  X(
    n,
    async (f, v) => {
      var m;
      const h = v !== f;
      if (await Z(), h) {
        const b = o.value, $ = Vt(t.value);
        f ? i("MOUNT") : $ === "none" || ((m = e.value) == null ? void 0 : m.display) === "none" ? i("UNMOUNT") : i(v && b !== $ ? "ANIMATION_OUT" : "UNMOUNT");
      }
    },
    { immediate: !0 }
  );
  const r = (f) => {
    const h = Vt(t.value).includes(
      f.animationName
    );
    f.target === t.value && h && i("ANIMATION_END");
  }, u = (f) => {
    f.target === t.value && (o.value = Vt(t.value));
  }, d = X(
    t,
    (f, v) => {
      f ? (e.value = getComputedStyle(f), f.addEventListener("animationstart", u), f.addEventListener("animationcancel", r), f.addEventListener("animationend", r)) : (i("ANIMATION_END"), v == null || v.removeEventListener("animationstart", u), v == null || v.removeEventListener("animationcancel", r), v == null || v.removeEventListener("animationend", r));
    },
    { immediate: !0 }
  ), p = X(s, () => {
    const f = Vt(t.value);
    o.value = s.value === "mounted" ? f : "none";
  });
  return ue(() => {
    d(), p();
  }), {
    isPresent: D(
      () => ["mounted", "unmountSuspended"].includes(s.value)
    )
  };
}
function Vt(n) {
  return n && getComputedStyle(n).animationName || "none";
}
const ce = /* @__PURE__ */ w({
  __name: "Presence",
  props: {
    present: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(n, { expose: t }) {
    var c;
    const e = n, { present: o, forceMount: a } = G(e), s = Gn(), i = S(), { isPresent: r } = cl(o, i);
    let u = (c = s.default) == null ? void 0 : c.call(s);
    u = ln(u || []);
    const d = Xe();
    function p() {
      var f, v;
      if (u && (u == null ? void 0 : u.length) > 1) {
        const h = (f = d == null ? void 0 : d.parent) != null && f.type.name ? `<${d.parent.type.name} />` : "component";
        throw new Error(
          [
            `Detected an invalid children for \`${h}\` for  \`Presence\` component.`,
            "",
            "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
            "You can apply a few solutions:",
            [
              "Provide a single child element so that `presence` directive attach correctly.rv",
              "Ensure the first child is an actual element instead of a raw text node or comment node."
            ].map((m) => `  - ${m}`).join(`
`)
          ].join(`
`)
        );
      }
      return a.value || o.value || r.value ? Gt((v = s.default) == null ? void 0 : v.call(s)[0], {
        ref: (h) => {
          const m = ye(h);
          return m != null && m.hasAttribute("data-radix-popper-content-wrapper") ? i.value = m.firstChild : i.value = m, m;
        }
      }) : null;
    }
    return t({
      present: r
    }), (f, v) => (g(), C(p));
  }
}), pl = {
  inheritAttrs: !1
}, fl = /* @__PURE__ */ w({
  ...pl,
  __name: "CollapsibleContent",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, e = T(no), o = S(), { primitiveElement: a, currentElement: s } = H(), i = S(0), r = S(0), u = D(() => e == null ? void 0 : e.open.value), d = S(u.value), p = S();
    return X(
      () => {
        var c;
        return [u.value, (c = o.value) == null ? void 0 : c.present];
      },
      async () => {
        await Z();
        const c = s.value;
        if (!c)
          return;
        p.value = p.value || {
          transitionDuration: c.style.transitionDuration,
          animationName: c.style.animationName
        }, c.style.transitionDuration = "0s", c.style.animationName = "none";
        const f = c.getBoundingClientRect();
        r.value = f.height, i.value = f.width, d.value || (c.style.transitionDuration = p.value.transitionDuration, c.style.animationName = p.value.animationName);
      },
      {
        immediate: !0
      }
    ), Y(() => {
      requestAnimationFrame(() => {
        d.value = !1;
      });
    }), (c, f) => (g(), C(l(ce), {
      ref_key: "presentRef",
      ref: o,
      present: l(e).open.value,
      "force-mount": !0
    }, {
      default: y(() => {
        var v, h, m, b, $;
        return [
          L(l(M), k(c.$attrs, {
            id: (v = l(e)) == null ? void 0 : v.contentId,
            ref_key: "primitiveElement",
            ref: a,
            "as-child": t.asChild,
            as: c.as,
            "data-state": (h = l(e)) != null && h.open.value ? "open" : "closed",
            "data-disabled": (b = (m = l(e)) == null ? void 0 : m.disabled) != null && b.value ? "true" : void 0,
            hidden: !(($ = o.value) != null && $.present),
            style: {
              ["--radix-collapsible-content-height"]: `${r.value}px`,
              ["--radix-collapsible-content-width"]: `${i.value}px`
            }
          }), {
            default: y(() => {
              var O;
              return [
                (O = o.value) != null && O.present ? _(c.$slots, "default", { key: 0 }) : J("", !0)
              ];
            }),
            _: 3
          }, 16, ["id", "as-child", "as", "data-state", "data-disabled", "hidden", "style"])
        ];
      }),
      _: 3
    }, 8, ["present"]));
  }
});
function vl(n, t) {
  if (n === "single") {
    if (Array.isArray(t)) {
      console.error(`Invalid prop \`value\` of value \`${t}\` supplied to \`AccordionRoot\`, which type is \`single\`. The \`value\` prop must be:
  - a string
  - \`undefined\`

If you want to use multiple values, use the \`AccordionRoot\` with type \`multiple\`.

Defaulting to \`undefined\`.`);
      return;
    }
  } else if (n === "multiple" && (typeof t == "string" || typeof t > "u"))
    return console.error(`Invalid prop \`value\` of value \`${t}\` supplied to \`AccordionRoot\`, which type is \`multiple\`. The \`value\` prop must be:
- an array of strings
- empty array (\`[]\`)

If you want to use just one value, use the \`AccordionRoot\` with type \`single\`.

Defaulting to empty array (\`[]\`).`), [];
  return t;
}
function ml({ type: n, defaultValue: t }) {
  if (n === "multiple")
    return Array.isArray(t) ? t : t === void 0 ? [] : (console.error(
      `Invalid prop \`defaultValue\` of value \`${t}\` supplied to \`AccordionRoot\`, which type is \`multiple\`. The \`defaultValue\` prop must be:
  - an array of strings
  - empty array (\`[]\`)

If you want to use just one value, use the \`AccordionRoot\` with type \`single\`.

Defaulting to empty array (\`[]\`).`
    ), []);
  if (n === "single") {
    if (typeof t == "string")
      return t;
    if (t === void 0)
      return;
    console.error(
      `Invalid prop \`defaultValue\` of value \`${t}\` supplied to \`AccordionRoot\`, which type is \`single\`. The \`defaultValue\` prop must be:
  - a string
  - \`undefined\`

Defaulting to \`undefined\`.`
    );
    return;
  }
}
function Ea(n, t) {
  const e = q(n, "modelValue", t, {
    defaultValue: ml(n),
    passive: !0
  });
  X(
    () => [n.type, n.modelValue],
    () => {
      const a = vl(n.type, e.value);
      e.value !== a && (e.value = a);
    },
    { immediate: !0 }
  );
  function o(a) {
    if (n.type === "single")
      e.value = a === e.value ? void 0 : a;
    else {
      const s = e.value || [];
      if (s.includes(a)) {
        const i = s.findIndex((r) => r === a);
        s.splice(i, 1);
      } else
        s.push(a);
      e.value = s, t("update:modelValue", e.value);
    }
  }
  return {
    modelValue: e,
    changeModelValue: o
  };
}
const Bt = Symbol(), du = /* @__PURE__ */ w({
  __name: "AccordionRoot",
  props: {
    type: {},
    modelValue: {},
    defaultValue: {},
    collapsible: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    dir: { default: "ltr" },
    orientation: { default: "vertical" },
    asChild: { type: Boolean, default: !1 },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(n, { expose: t, emit: e }) {
    const o = n, { modelValue: a, changeModelValue: s } = Ea(o, e), { primitiveElement: i, currentElement: r } = H();
    return W(Bt, {
      disabled: o.disabled,
      direction: o.dir,
      orientation: o.orientation,
      parentElement: r,
      isSingle: D(() => o.type === "single"),
      collapsible: o.collapsible,
      modelValue: a,
      changeModelValue: s
    }), t({
      modelValue: a
    }), (u, d) => (g(), C(l(M), {
      ref_key: "primitiveElement",
      ref: i,
      "as-child": o.asChild,
      as: o.as
    }, {
      default: y(() => [
        _(u.$slots, "default", { modelValue: l(a) })
      ]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), rn = Symbol(), cu = /* @__PURE__ */ w({
  __name: "AccordionItem",
  props: {
    disabled: { type: Boolean },
    value: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(n, { expose: t }) {
    const e = n, o = T(Bt), a = D(
      () => o != null && o.isSingle.value ? e.value === o.modelValue.value : Array.isArray(o == null ? void 0 : o.modelValue.value) && !!(o != null && o.modelValue.value.includes(e.value))
    ), s = D(() => (o == null ? void 0 : o.disabled) || e.disabled || !!(o != null && o.isSingle.value) && a.value && !(o != null && o.collapsible)), i = D(() => s.value ? "" : void 0), r = D(
      () => a.value ? "open" : "closed"
      /* Closed */
    ), { primitiveElement: u, currentElement: d } = H();
    W(rn, {
      open: a,
      dataState: r,
      disabled: s,
      dataDisabled: i,
      triggerId: te(),
      primitiveElement: u,
      currentElement: d,
      value: D(() => e.value)
    });
    function p(c) {
      an(
        c,
        d.value,
        o == null ? void 0 : o.parentElement.value,
        {
          arrowKeyOptions: o == null ? void 0 : o.orientation,
          dir: o == null ? void 0 : o.direction,
          focus: !0
        }
      );
    }
    return t({ open: a }), (c, f) => {
      var v;
      return g(), C(l(ul), {
        "data-orientation": (v = l(o)) == null ? void 0 : v.orientation,
        "data-disabled": i.value,
        "data-state": r.value,
        disabled: s.value,
        open: a.value,
        "as-child": e.asChild,
        onKeydown: pe(p, ["up", "down", "left", "right", "home", "end"])
      }, {
        default: y(() => [
          _(c.$slots, "default", { open: a.value })
        ]),
        _: 3
      }, 8, ["data-orientation", "data-disabled", "data-state", "disabled", "open", "as-child", "onKeydown"]);
    };
  }
}), pu = /* @__PURE__ */ w({
  __name: "AccordionContent",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, e = T(Bt), o = T(rn);
    return (a, s) => {
      var i, r, u, d, p, c, f;
      return g(), C(l(fl), {
        id: (i = l(o)) == null ? void 0 : i.triggerId,
        role: "region",
        open: (r = l(o)) == null ? void 0 : r.open.value,
        hidden: !((u = l(o)) != null && u.open.value),
        "as-child": t.asChild,
        "aria-labelledby": (d = l(o)) == null ? void 0 : d.triggerId,
        "data-state": (p = l(o)) == null ? void 0 : p.dataState.value,
        "data-disabled": (c = l(o)) == null ? void 0 : c.dataDisabled.value,
        "data-orientation": (f = l(e)) == null ? void 0 : f.orientation,
        style: { "--radix-accordion-content-width": "var(--radix-collapsible-content-width)", "--radix-accordion-content-height": "var(--radix-collapsible-content-height)" }
      }, {
        default: y(() => [
          _(a.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "open", "hidden", "as-child", "aria-labelledby", "data-state", "data-disabled", "data-orientation"]);
    };
  }
}), fu = /* @__PURE__ */ w({
  __name: "AccordionHeader",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, e = T(Bt), o = T(rn);
    return (a, s) => {
      var i, r, u;
      return g(), C(l(M), {
        as: t.as || "h3",
        "as-child": t.asChild,
        "data-orientation": (i = l(e)) == null ? void 0 : i.orientation,
        "data-state": (r = l(o)) == null ? void 0 : r.dataState.value,
        "data-disabled": (u = l(o)) == null ? void 0 : u.dataDisabled.value
      }, {
        default: y(() => [
          _(a.$slots, "default")
        ]),
        _: 3
      }, 8, ["as", "as-child", "data-orientation", "data-state", "data-disabled"]);
    };
  }
}), vu = /* @__PURE__ */ w({
  __name: "AccordionTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, e = T(Bt), o = T(rn);
    function a() {
      o != null && o.disabled.value || o && (e == null || e.changeModelValue(o.value.value));
    }
    return (s, i) => {
      var r, u, d, p, c, f, v, h, m, b;
      return g(), C(l(dl), {
        id: (r = l(o)) == null ? void 0 : r.triggerId,
        ref: (u = l(o)) == null ? void 0 : u.primitiveElement,
        "data-radix-vue-collection-item": "",
        as: t.as,
        "as-child": t.asChild,
        "aria-controls": (d = l(o)) == null ? void 0 : d.triggerId,
        "aria-disabled": ((p = l(o)) == null ? void 0 : p.disabled.value) || void 0,
        "aria-expanded": ((c = l(o)) == null ? void 0 : c.open.value) || !1,
        "data-disabled": (f = l(o)) == null ? void 0 : f.dataDisabled.value,
        "data-orientation": (v = l(e)) == null ? void 0 : v.orientation,
        "data-state": (h = l(o)) == null ? void 0 : h.dataState.value,
        disabled: (b = (m = l(o)) == null ? void 0 : m.disabled) == null ? void 0 : b.value,
        onClick: a
      }, {
        default: y(() => [
          _(s.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "as", "as-child", "aria-controls", "aria-disabled", "aria-expanded", "data-disabled", "data-orientation", "data-state", "disabled"]);
    };
  }
});
function Xt(n) {
  return n === "indeterminate";
}
function $a(n) {
  return Xt(n) ? "indeterminate" : n ? "checked" : "unchecked";
}
const hl = ["defaultChecked", "checked", "name", "disabled", "required"], Oa = Symbol(), yl = {
  inheritAttrs: !1
}, mu = /* @__PURE__ */ w({
  ...yl,
  __name: "CheckboxRoot",
  props: {
    defaultChecked: { type: Boolean },
    checked: { type: [Boolean, String], default: void 0 },
    disabled: { type: Boolean },
    required: { type: Boolean },
    name: {},
    value: { default: "on" },
    id: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  emits: ["update:checked"],
  setup(n, { emit: t }) {
    const e = n, { disabled: o } = G(e), a = q(e, "checked", t, {
      defaultValue: e.defaultChecked,
      passive: !0
    }), { primitiveElement: s, currentElement: i } = H(), r = D(() => i.value ? !!i.value.closest("form") : !0), u = D(() => {
      var d;
      return e.id && i.value ? (d = document.querySelector(`[for="${e.id}"]`)) == null ? void 0 : d.innerText : void 0;
    });
    return W(Oa, {
      disabled: o,
      state: a
    }), (d, p) => (g(), Q(re, null, [
      L(l(M), k(d.$attrs, {
        id: d.id,
        ref_key: "primitiveElement",
        ref: s,
        role: "checkbox",
        "as-child": e.asChild,
        as: d.as,
        type: d.as === "button" ? "button" : void 0,
        "aria-checked": l(Xt)(l(a)) ? "mixed" : l(a),
        "aria-required": d.required,
        "aria-label": d.$attrs["aria-label"] || u.value,
        "data-state": l($a)(l(a)),
        "data-disabled": l(o) ? "" : void 0,
        disabled: l(o),
        onKeydown: pe(oe(() => {
        }, ["prevent"]), ["enter"]),
        onClick: p[0] || (p[0] = (c) => a.value = !l(a))
      }), {
        default: y(() => [
          _(d.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "as-child", "as", "type", "aria-checked", "aria-required", "aria-label", "data-state", "data-disabled", "disabled", "onKeydown"]),
      r.value ? (g(), Q("input", {
        key: 0,
        type: "checkbox",
        tabindex: "-1",
        "aria-hidden": "",
        defaultChecked: l(Xt)(l(a)) ? !1 : l(a),
        checked: !!l(a),
        name: e.name,
        disabled: e.disabled,
        required: e.required,
        style: ie({
          transform: "translateX(-100%)",
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        })
      }, null, 12, hl)) : J("", !0)
    ], 64));
  }
}), hu = /* @__PURE__ */ w({
  __name: "CheckboxIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(n) {
    const t = T(Oa);
    return (e, o) => {
      var a;
      return g(), C(l(ce), {
        present: e.forceMount || l(Xt)(l(t).state.value) || ((a = l(t)) == null ? void 0 : a.state.value) === !0
      }, {
        default: y(() => {
          var s;
          return [
            L(l(M), k({
              "data-state": l($a)(l(t).state.value),
              "data-disabled": (s = l(t)) != null && s.disabled.value ? "" : void 0,
              style: { pointerEvents: "none" },
              "as-child": e.asChild,
              as: e.as
            }, e.$attrs), {
              default: y(() => [
                _(e.$slots, "default")
              ]),
              _: 3
            }, 16, ["data-state", "data-disabled", "as-child", "as"])
          ];
        }),
        _: 3
      }, 8, ["present"]);
    };
  }
}), oo = Symbol(), Je = /* @__PURE__ */ w({
  __name: "PopperRoot",
  setup(n) {
    const t = S();
    return W(oo, {
      anchor: t,
      onAnchorChange: (e) => {
        t.value = e;
      }
    }), (e, o) => _(e.$slots, "default");
  }
}), qe = /* @__PURE__ */ w({
  __name: "PopperAnchor",
  props: {
    element: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, { primitiveElement: e, currentElement: o } = H(), a = T(oo);
    return X(o, () => {
      a == null || a.onAnchorChange(t.element ?? o.value);
    }), (s, i) => (g(), C(l(M), {
      ref_key: "primitiveElement",
      ref: e,
      as: s.as,
      "as-child": s.asChild
    }, {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), gl = ["top", "right", "bottom", "left"], _t = Math.min, ze = Math.max, bl = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, _l = {
  start: "end",
  end: "start"
};
function kn(n, t, e) {
  return ze(n, _t(t, e));
}
function Ae(n, t) {
  return typeof n == "function" ? n(t) : n;
}
function Ie(n) {
  return n.split("-")[0];
}
function ut(n) {
  return n.split("-")[1];
}
function ao(n) {
  return n === "x" ? "y" : "x";
}
function so(n) {
  return n === "y" ? "height" : "width";
}
function dt(n) {
  return ["top", "bottom"].includes(Ie(n)) ? "y" : "x";
}
function lo(n) {
  return ao(dt(n));
}
function wl(n, t, e) {
  e === void 0 && (e = !1);
  const o = ut(n), a = lo(n), s = so(a);
  let i = a === "x" ? o === (e ? "end" : "start") ? "right" : "left" : o === "start" ? "bottom" : "top";
  return t.reference[s] > t.floating[s] && (i = Jt(i)), [i, Jt(i)];
}
function Cl(n) {
  const t = Jt(n);
  return [Mn(n), t, Mn(t)];
}
function Mn(n) {
  return n.replace(/start|end/g, (t) => _l[t]);
}
function El(n, t, e) {
  const o = ["left", "right"], a = ["right", "left"], s = ["top", "bottom"], i = ["bottom", "top"];
  switch (n) {
    case "top":
    case "bottom":
      return e ? t ? a : o : t ? o : a;
    case "left":
    case "right":
      return t ? s : i;
    default:
      return [];
  }
}
function $l(n, t, e, o) {
  const a = ut(n);
  let s = El(Ie(n), e === "start", o);
  return a && (s = s.map((i) => i + "-" + a), t && (s = s.concat(s.map(Mn)))), s;
}
function Jt(n) {
  return n.replace(/left|right|bottom|top/g, (t) => bl[t]);
}
function Ol(n) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...n
  };
}
function Sa(n) {
  return typeof n != "number" ? Ol(n) : {
    top: n,
    right: n,
    bottom: n,
    left: n
  };
}
function qt(n) {
  return {
    ...n,
    top: n.y,
    left: n.x,
    right: n.x + n.width,
    bottom: n.y + n.height
  };
}
function Uo(n, t, e) {
  let {
    reference: o,
    floating: a
  } = n;
  const s = dt(t), i = lo(t), r = so(i), u = Ie(t), d = s === "y", p = o.x + o.width / 2 - a.width / 2, c = o.y + o.height / 2 - a.height / 2, f = o[r] / 2 - a[r] / 2;
  let v;
  switch (u) {
    case "top":
      v = {
        x: p,
        y: o.y - a.height
      };
      break;
    case "bottom":
      v = {
        x: p,
        y: o.y + o.height
      };
      break;
    case "right":
      v = {
        x: o.x + o.width,
        y: c
      };
      break;
    case "left":
      v = {
        x: o.x - a.width,
        y: c
      };
      break;
    default:
      v = {
        x: o.x,
        y: o.y
      };
  }
  switch (ut(t)) {
    case "start":
      v[i] -= f * (e && d ? -1 : 1);
      break;
    case "end":
      v[i] += f * (e && d ? -1 : 1);
      break;
  }
  return v;
}
const Sl = async (n, t, e) => {
  const {
    placement: o = "bottom",
    strategy: a = "absolute",
    middleware: s = [],
    platform: i
  } = e, r = s.filter(Boolean), u = await (i.isRTL == null ? void 0 : i.isRTL(t));
  let d = await i.getElementRects({
    reference: n,
    floating: t,
    strategy: a
  }), {
    x: p,
    y: c
  } = Uo(d, o, u), f = o, v = {}, h = 0;
  for (let m = 0; m < r.length; m++) {
    const {
      name: b,
      fn: $
    } = r[m], {
      x: O,
      y: E,
      data: P,
      reset: B
    } = await $({
      x: p,
      y: c,
      initialPlacement: o,
      placement: f,
      strategy: a,
      middlewareData: v,
      rects: d,
      platform: i,
      elements: {
        reference: n,
        floating: t
      }
    });
    if (p = O ?? p, c = E ?? c, v = {
      ...v,
      [b]: {
        ...v[b],
        ...P
      }
    }, B && h <= 50) {
      h++, typeof B == "object" && (B.placement && (f = B.placement), B.rects && (d = B.rects === !0 ? await i.getElementRects({
        reference: n,
        floating: t,
        strategy: a
      }) : B.rects), {
        x: p,
        y: c
      } = Uo(d, f, u)), m = -1;
      continue;
    }
  }
  return {
    x: p,
    y: c,
    placement: f,
    strategy: a,
    middlewareData: v
  };
};
async function wt(n, t) {
  var e;
  t === void 0 && (t = {});
  const {
    x: o,
    y: a,
    platform: s,
    rects: i,
    elements: r,
    strategy: u
  } = n, {
    boundary: d = "clippingAncestors",
    rootBoundary: p = "viewport",
    elementContext: c = "floating",
    altBoundary: f = !1,
    padding: v = 0
  } = Ae(t, n), h = Sa(v), b = r[f ? c === "floating" ? "reference" : "floating" : c], $ = qt(await s.getClippingRect({
    element: (e = await (s.isElement == null ? void 0 : s.isElement(b))) == null || e ? b : b.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(r.floating)),
    boundary: d,
    rootBoundary: p,
    strategy: u
  })), O = c === "floating" ? {
    ...i.floating,
    x: o,
    y: a
  } : i.reference, E = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(r.floating)), P = await (s.isElement == null ? void 0 : s.isElement(E)) ? await (s.getScale == null ? void 0 : s.getScale(E)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, B = qt(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: O,
    offsetParent: E,
    strategy: u
  }) : O);
  return {
    top: ($.top - B.top + h.top) / P.y,
    bottom: (B.bottom - $.bottom + h.bottom) / P.y,
    left: ($.left - B.left + h.left) / P.x,
    right: (B.right - $.right + h.right) / P.x
  };
}
const Pl = (n) => ({
  name: "arrow",
  options: n,
  async fn(t) {
    const {
      x: e,
      y: o,
      placement: a,
      rects: s,
      platform: i,
      elements: r
    } = t, {
      element: u,
      padding: d = 0
    } = Ae(n, t) || {};
    if (u == null)
      return {};
    const p = Sa(d), c = {
      x: e,
      y: o
    }, f = lo(a), v = so(f), h = await i.getDimensions(u), m = f === "y", b = m ? "top" : "left", $ = m ? "bottom" : "right", O = m ? "clientHeight" : "clientWidth", E = s.reference[v] + s.reference[f] - c[f] - s.floating[v], P = c[f] - s.reference[f], B = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(u));
    let I = B ? B[O] : 0;
    (!I || !await (i.isElement == null ? void 0 : i.isElement(B))) && (I = r.floating[O] || s.floating[v]);
    const x = E / 2 - P / 2, V = I / 2 - h[v] / 2 - 1, A = _t(p[b], V), R = _t(p[$], V), F = A, U = I - h[v] - R, z = I / 2 - h[v] / 2 + x, j = kn(F, z, U), se = ut(a) != null && z != j && s.reference[v] / 2 - (z < F ? A : R) - h[v] / 2 < 0 ? z < F ? F - z : U - z : 0;
    return {
      [f]: c[f] - se,
      data: {
        [f]: j,
        centerOffset: z - j + se
      }
    };
  }
}), Tl = function(n) {
  return n === void 0 && (n = {}), {
    name: "flip",
    options: n,
    async fn(t) {
      var e;
      const {
        placement: o,
        middlewareData: a,
        rects: s,
        initialPlacement: i,
        platform: r,
        elements: u
      } = t, {
        mainAxis: d = !0,
        crossAxis: p = !0,
        fallbackPlacements: c,
        fallbackStrategy: f = "bestFit",
        fallbackAxisSideDirection: v = "none",
        flipAlignment: h = !0,
        ...m
      } = Ae(n, t), b = Ie(o), $ = Ie(i) === i, O = await (r.isRTL == null ? void 0 : r.isRTL(u.floating)), E = c || ($ || !h ? [Jt(i)] : Cl(i));
      !c && v !== "none" && E.push(...$l(i, h, v, O));
      const P = [i, ...E], B = await wt(t, m), I = [];
      let x = ((e = a.flip) == null ? void 0 : e.overflows) || [];
      if (d && I.push(B[b]), p) {
        const F = wl(o, s, O);
        I.push(B[F[0]], B[F[1]]);
      }
      if (x = [...x, {
        placement: o,
        overflows: I
      }], !I.every((F) => F <= 0)) {
        var V, A;
        const F = (((V = a.flip) == null ? void 0 : V.index) || 0) + 1, U = P[F];
        if (U)
          return {
            data: {
              index: F,
              overflows: x
            },
            reset: {
              placement: U
            }
          };
        let z = (A = x.filter((j) => j.overflows[0] <= 0).sort((j, ne) => j.overflows[1] - ne.overflows[1])[0]) == null ? void 0 : A.placement;
        if (!z)
          switch (f) {
            case "bestFit": {
              var R;
              const j = (R = x.map((ne) => [ne.placement, ne.overflows.filter((se) => se > 0).reduce((se, Ze) => se + Ze, 0)]).sort((ne, se) => ne[1] - se[1])[0]) == null ? void 0 : R[0];
              j && (z = j);
              break;
            }
            case "initialPlacement":
              z = i;
              break;
          }
        if (o !== z)
          return {
            reset: {
              placement: z
            }
          };
      }
      return {};
    }
  };
};
function zo(n, t) {
  return {
    top: n.top - t.height,
    right: n.right - t.width,
    bottom: n.bottom - t.height,
    left: n.left - t.width
  };
}
function Yo(n) {
  return gl.some((t) => n[t] >= 0);
}
const Bl = function(n) {
  return n === void 0 && (n = {}), {
    name: "hide",
    options: n,
    async fn(t) {
      const {
        rects: e
      } = t, {
        strategy: o = "referenceHidden",
        ...a
      } = Ae(n, t);
      switch (o) {
        case "referenceHidden": {
          const s = await wt(t, {
            ...a,
            elementContext: "reference"
          }), i = zo(s, e.reference);
          return {
            data: {
              referenceHiddenOffsets: i,
              referenceHidden: Yo(i)
            }
          };
        }
        case "escaped": {
          const s = await wt(t, {
            ...a,
            altBoundary: !0
          }), i = zo(s, e.floating);
          return {
            data: {
              escapedOffsets: i,
              escaped: Yo(i)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function Al(n, t) {
  const {
    placement: e,
    platform: o,
    elements: a
  } = n, s = await (o.isRTL == null ? void 0 : o.isRTL(a.floating)), i = Ie(e), r = ut(e), u = dt(e) === "y", d = ["left", "top"].includes(i) ? -1 : 1, p = s && u ? -1 : 1, c = Ae(t, n);
  let {
    mainAxis: f,
    crossAxis: v,
    alignmentAxis: h
  } = typeof c == "number" ? {
    mainAxis: c,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...c
  };
  return r && typeof h == "number" && (v = r === "end" ? h * -1 : h), u ? {
    x: v * p,
    y: f * d
  } : {
    x: f * d,
    y: v * p
  };
}
const Il = function(n) {
  return n === void 0 && (n = 0), {
    name: "offset",
    options: n,
    async fn(t) {
      const {
        x: e,
        y: o
      } = t, a = await Al(t, n);
      return {
        x: e + a.x,
        y: o + a.y,
        data: a
      };
    }
  };
}, Dl = function(n) {
  return n === void 0 && (n = {}), {
    name: "shift",
    options: n,
    async fn(t) {
      const {
        x: e,
        y: o,
        placement: a
      } = t, {
        mainAxis: s = !0,
        crossAxis: i = !1,
        limiter: r = {
          fn: (b) => {
            let {
              x: $,
              y: O
            } = b;
            return {
              x: $,
              y: O
            };
          }
        },
        ...u
      } = Ae(n, t), d = {
        x: e,
        y: o
      }, p = await wt(t, u), c = dt(Ie(a)), f = ao(c);
      let v = d[f], h = d[c];
      if (s) {
        const b = f === "y" ? "top" : "left", $ = f === "y" ? "bottom" : "right", O = v + p[b], E = v - p[$];
        v = kn(O, v, E);
      }
      if (i) {
        const b = c === "y" ? "top" : "left", $ = c === "y" ? "bottom" : "right", O = h + p[b], E = h - p[$];
        h = kn(O, h, E);
      }
      const m = r.fn({
        ...t,
        [f]: v,
        [c]: h
      });
      return {
        ...m,
        data: {
          x: m.x - e,
          y: m.y - o
        }
      };
    }
  };
}, xl = function(n) {
  return n === void 0 && (n = {}), {
    options: n,
    fn(t) {
      const {
        x: e,
        y: o,
        placement: a,
        rects: s,
        middlewareData: i
      } = t, {
        offset: r = 0,
        mainAxis: u = !0,
        crossAxis: d = !0
      } = Ae(n, t), p = {
        x: e,
        y: o
      }, c = dt(a), f = ao(c);
      let v = p[f], h = p[c];
      const m = Ae(r, t), b = typeof m == "number" ? {
        mainAxis: m,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...m
      };
      if (u) {
        const E = f === "y" ? "height" : "width", P = s.reference[f] - s.floating[E] + b.mainAxis, B = s.reference[f] + s.reference[E] - b.mainAxis;
        v < P ? v = P : v > B && (v = B);
      }
      if (d) {
        var $, O;
        const E = f === "y" ? "width" : "height", P = ["top", "left"].includes(Ie(a)), B = s.reference[c] - s.floating[E] + (P && (($ = i.offset) == null ? void 0 : $[c]) || 0) + (P ? 0 : b.crossAxis), I = s.reference[c] + s.reference[E] + (P ? 0 : ((O = i.offset) == null ? void 0 : O[c]) || 0) - (P ? b.crossAxis : 0);
        h < B ? h = B : h > I && (h = I);
      }
      return {
        [f]: v,
        [c]: h
      };
    }
  };
}, kl = function(n) {
  return n === void 0 && (n = {}), {
    name: "size",
    options: n,
    async fn(t) {
      const {
        placement: e,
        rects: o,
        platform: a,
        elements: s
      } = t, {
        apply: i = () => {
        },
        ...r
      } = Ae(n, t), u = await wt(t, r), d = Ie(e), p = ut(e), c = dt(e) === "y", {
        width: f,
        height: v
      } = o.floating;
      let h, m;
      d === "top" || d === "bottom" ? (h = d, m = p === (await (a.isRTL == null ? void 0 : a.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (m = d, h = p === "end" ? "top" : "bottom");
      const b = v - u[h], $ = f - u[m], O = !t.middlewareData.shift;
      let E = b, P = $;
      if (c) {
        const I = f - u.left - u.right;
        P = p || O ? _t($, I) : I;
      } else {
        const I = v - u.top - u.bottom;
        E = p || O ? _t(b, I) : I;
      }
      if (O && !p) {
        const I = ze(u.left, 0), x = ze(u.right, 0), V = ze(u.top, 0), A = ze(u.bottom, 0);
        c ? P = f - 2 * (I !== 0 || x !== 0 ? I + x : ze(u.left, u.right)) : E = v - 2 * (V !== 0 || A !== 0 ? V + A : ze(u.top, u.bottom));
      }
      await i({
        ...t,
        availableWidth: P,
        availableHeight: E
      });
      const B = await a.getDimensions(s.floating);
      return f !== B.width || v !== B.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function he(n) {
  var t;
  return ((t = n.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function be(n) {
  return he(n).getComputedStyle(n);
}
function Pa(n) {
  return n instanceof he(n).Node;
}
function Re(n) {
  return Pa(n) ? (n.nodeName || "").toLowerCase() : "#document";
}
function _e(n) {
  return n instanceof he(n).HTMLElement;
}
function Pe(n) {
  return n instanceof he(n).Element;
}
function Go(n) {
  return typeof ShadowRoot < "u" && (n instanceof he(n).ShadowRoot || n instanceof ShadowRoot);
}
function Ct(n) {
  const { overflow: t, overflowX: e, overflowY: o, display: a } = be(n);
  return /auto|scroll|overlay|hidden|clip/.test(t + o + e) && !["inline", "contents"].includes(a);
}
function Ml(n) {
  return ["table", "td", "th"].includes(Re(n));
}
function Rn(n) {
  const t = io(), e = be(n);
  return e.transform !== "none" || e.perspective !== "none" || !t && !!e.backdropFilter && e.backdropFilter !== "none" || !t && !!e.filter && e.filter !== "none" || ["transform", "perspective", "filter"].some((o) => (e.willChange || "").includes(o)) || ["paint", "layout", "strict", "content"].some((o) => (e.contain || "").includes(o));
}
function io() {
  return !(typeof CSS > "u" || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none");
}
function un(n) {
  return ["html", "body", "#document"].includes(Re(n));
}
const Fn = Math.min, tt = Math.max, jt = Math.round, Kt = Math.floor, Ye = (n) => ({ x: n, y: n });
function Ta(n) {
  const t = be(n);
  let e = parseFloat(t.width) || 0, o = parseFloat(t.height) || 0;
  const a = _e(n), s = a ? n.offsetWidth : e, i = a ? n.offsetHeight : o, r = jt(e) !== s || jt(o) !== i;
  return r && (e = s, o = i), { width: e, height: o, $: r };
}
function ro(n) {
  return Pe(n) ? n : n.contextElement;
}
function nt(n) {
  const t = ro(n);
  if (!_e(t))
    return Ye(1);
  const e = t.getBoundingClientRect(), { width: o, height: a, $: s } = Ta(t);
  let i = (s ? jt(e.width) : e.width) / o, r = (s ? jt(e.height) : e.height) / a;
  return i && Number.isFinite(i) || (i = 1), r && Number.isFinite(r) || (r = 1), { x: i, y: r };
}
const Xo = Ye(0);
function Ba(n, t, e) {
  var o, a;
  if (t === void 0 && (t = !0), !io())
    return Xo;
  const s = n ? he(n) : window;
  return !e || t && e !== s ? Xo : { x: ((o = s.visualViewport) == null ? void 0 : o.offsetLeft) || 0, y: ((a = s.visualViewport) == null ? void 0 : a.offsetTop) || 0 };
}
function Ge(n, t, e, o) {
  t === void 0 && (t = !1), e === void 0 && (e = !1);
  const a = n.getBoundingClientRect(), s = ro(n);
  let i = Ye(1);
  t && (o ? Pe(o) && (i = nt(o)) : i = nt(n));
  const r = Ba(s, e, o);
  let u = (a.left + r.x) / i.x, d = (a.top + r.y) / i.y, p = a.width / i.x, c = a.height / i.y;
  if (s) {
    const f = he(s), v = o && Pe(o) ? he(o) : o;
    let h = f.frameElement;
    for (; h && o && v !== f; ) {
      const m = nt(h), b = h.getBoundingClientRect(), $ = getComputedStyle(h), O = b.left + (h.clientLeft + parseFloat($.paddingLeft)) * m.x, E = b.top + (h.clientTop + parseFloat($.paddingTop)) * m.y;
      u *= m.x, d *= m.y, p *= m.x, c *= m.y, u += O, d += E, h = he(h).frameElement;
    }
  }
  return qt({ width: p, height: c, x: u, y: d });
}
function Te(n) {
  return ((Pa(n) ? n.ownerDocument : n.document) || window.document).documentElement;
}
function dn(n) {
  return Pe(n) ? { scrollLeft: n.scrollLeft, scrollTop: n.scrollTop } : { scrollLeft: n.pageXOffset, scrollTop: n.pageYOffset };
}
function Aa(n) {
  return Ge(Te(n)).left + dn(n).scrollLeft;
}
function at(n) {
  if (Re(n) === "html")
    return n;
  const t = n.assignedSlot || n.parentNode || Go(n) && n.host || Te(n);
  return Go(t) ? t.host : t;
}
function Ia(n) {
  const t = at(n);
  return un(t) ? n.ownerDocument ? n.ownerDocument.body : n.body : _e(t) && Ct(t) ? t : Ia(t);
}
function Zt(n, t) {
  var e;
  t === void 0 && (t = []);
  const o = Ia(n), a = o === ((e = n.ownerDocument) == null ? void 0 : e.body), s = he(o);
  return a ? t.concat(s, s.visualViewport || [], Ct(o) ? o : []) : t.concat(o, Zt(o));
}
function Jo(n, t, e) {
  let o;
  if (t === "viewport")
    o = function(a, s) {
      const i = he(a), r = Te(a), u = i.visualViewport;
      let d = r.clientWidth, p = r.clientHeight, c = 0, f = 0;
      if (u) {
        d = u.width, p = u.height;
        const v = io();
        (!v || v && s === "fixed") && (c = u.offsetLeft, f = u.offsetTop);
      }
      return { width: d, height: p, x: c, y: f };
    }(n, e);
  else if (t === "document")
    o = function(a) {
      const s = Te(a), i = dn(a), r = a.ownerDocument.body, u = tt(s.scrollWidth, s.clientWidth, r.scrollWidth, r.clientWidth), d = tt(s.scrollHeight, s.clientHeight, r.scrollHeight, r.clientHeight);
      let p = -i.scrollLeft + Aa(a);
      const c = -i.scrollTop;
      return be(r).direction === "rtl" && (p += tt(s.clientWidth, r.clientWidth) - u), { width: u, height: d, x: p, y: c };
    }(Te(n));
  else if (Pe(t))
    o = function(a, s) {
      const i = Ge(a, !0, s === "fixed"), r = i.top + a.clientTop, u = i.left + a.clientLeft, d = _e(a) ? nt(a) : Ye(1);
      return { width: a.clientWidth * d.x, height: a.clientHeight * d.y, x: u * d.x, y: r * d.y };
    }(t, e);
  else {
    const a = Ba(n);
    o = { ...t, x: t.x - a.x, y: t.y - a.y };
  }
  return qt(o);
}
function Da(n, t) {
  const e = at(n);
  return !(e === t || !Pe(e) || un(e)) && (be(e).position === "fixed" || Da(e, t));
}
function qo(n, t) {
  return _e(n) && be(n).position !== "fixed" ? t ? t(n) : n.offsetParent : null;
}
function jo(n, t) {
  const e = he(n);
  if (!_e(n))
    return e;
  let o = qo(n, t);
  for (; o && Ml(o) && be(o).position === "static"; )
    o = qo(o, t);
  return o && (Re(o) === "html" || Re(o) === "body" && be(o).position === "static" && !Rn(o)) ? e : o || function(a) {
    let s = at(a);
    for (; _e(s) && !un(s); ) {
      if (Rn(s))
        return s;
      s = at(s);
    }
    return null;
  }(n) || e;
}
function Rl(n, t, e) {
  const o = _e(t), a = Te(t), s = e === "fixed", i = Ge(n, !0, s, t);
  let r = { scrollLeft: 0, scrollTop: 0 };
  const u = Ye(0);
  if (o || !o && !s)
    if ((Re(t) !== "body" || Ct(a)) && (r = dn(t)), _e(t)) {
      const d = Ge(t, !0, s, t);
      u.x = d.x + t.clientLeft, u.y = d.y + t.clientTop;
    } else
      a && (u.x = Aa(a));
  return { x: i.left + r.scrollLeft - u.x, y: i.top + r.scrollTop - u.y, width: i.width, height: i.height };
}
const Fl = { getClippingRect: function(n) {
  let { element: t, boundary: e, rootBoundary: o, strategy: a } = n;
  const s = e === "clippingAncestors" ? function(d, p) {
    const c = p.get(d);
    if (c)
      return c;
    let f = Zt(d).filter((b) => Pe(b) && Re(b) !== "body"), v = null;
    const h = be(d).position === "fixed";
    let m = h ? at(d) : d;
    for (; Pe(m) && !un(m); ) {
      const b = be(m), $ = Rn(m);
      $ || b.position !== "fixed" || (v = null), (h ? !$ && !v : !$ && b.position === "static" && v && ["absolute", "fixed"].includes(v.position) || Ct(m) && !$ && Da(d, m)) ? f = f.filter((O) => O !== m) : v = b, m = at(m);
    }
    return p.set(d, f), f;
  }(t, this._c) : [].concat(e), i = [...s, o], r = i[0], u = i.reduce((d, p) => {
    const c = Jo(t, p, a);
    return d.top = tt(c.top, d.top), d.right = Fn(c.right, d.right), d.bottom = Fn(c.bottom, d.bottom), d.left = tt(c.left, d.left), d;
  }, Jo(t, r, a));
  return { width: u.right - u.left, height: u.bottom - u.top, x: u.left, y: u.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(n) {
  let { rect: t, offsetParent: e, strategy: o } = n;
  const a = _e(e), s = Te(e);
  if (e === s)
    return t;
  let i = { scrollLeft: 0, scrollTop: 0 }, r = Ye(1);
  const u = Ye(0);
  if ((a || !a && o !== "fixed") && ((Re(e) !== "body" || Ct(s)) && (i = dn(e)), _e(e))) {
    const d = Ge(e);
    r = nt(e), u.x = d.x + e.clientLeft, u.y = d.y + e.clientTop;
  }
  return { width: t.width * r.x, height: t.height * r.y, x: t.x * r.x - i.scrollLeft * r.x + u.x, y: t.y * r.y - i.scrollTop * r.y + u.y };
}, isElement: Pe, getDimensions: function(n) {
  return Ta(n);
}, getOffsetParent: jo, getDocumentElement: Te, getScale: nt, async getElementRects(n) {
  let { reference: t, floating: e, strategy: o } = n;
  const a = this.getOffsetParent || jo, s = this.getDimensions;
  return { reference: Rl(t, await a(e), o), floating: { x: 0, y: 0, ...await s(e) } };
}, getClientRects: (n) => Array.from(n.getClientRects()), isRTL: (n) => be(n).direction === "rtl" };
function Nl(n, t, e, o) {
  o === void 0 && (o = {});
  const { ancestorScroll: a = !0, ancestorResize: s = !0, elementResize: i = !0, layoutShift: r = typeof IntersectionObserver == "function", animationFrame: u = !1 } = o, d = ro(n), p = a || s ? [...d ? Zt(d) : [], ...Zt(t)] : [];
  p.forEach((m) => {
    a && m.addEventListener("scroll", e, { passive: !0 }), s && m.addEventListener("resize", e);
  });
  const c = d && r ? function(m, b) {
    let $, O = null;
    const E = Te(m);
    function P() {
      clearTimeout($), O && O.disconnect(), O = null;
    }
    return function B(I, x) {
      I === void 0 && (I = !1), x === void 0 && (x = 1), P();
      const { left: V, top: A, width: R, height: F } = m.getBoundingClientRect();
      if (I || b(), !R || !F)
        return;
      const U = Kt(A), z = Kt(E.clientWidth - (V + R)), j = Kt(E.clientHeight - (A + F)), ne = Kt(V);
      let se = !0;
      O = new IntersectionObserver((Ze) => {
        const gt = Ze[0].intersectionRatio;
        if (gt !== x) {
          if (!se)
            return B();
          gt ? B(!1, gt) : $ = setTimeout(() => {
            B(!1, 1e-7);
          }, 100);
        }
        se = !1;
      }, { rootMargin: -U + "px " + -z + "px " + -j + "px " + -ne + "px", threshold: tt(0, Fn(1, x)) || 1 }), O.observe(m);
    }(!0), P;
  }(d, e) : null;
  let f, v = null;
  i && (v = new ResizeObserver(e), d && !u && v.observe(d), v.observe(t));
  let h = u ? Ge(n) : null;
  return u && function m() {
    const b = Ge(n);
    !h || b.x === h.x && b.y === h.y && b.width === h.width && b.height === h.height || e(), h = b, f = requestAnimationFrame(m);
  }(), e(), () => {
    p.forEach((m) => {
      a && m.removeEventListener("scroll", e), s && m.removeEventListener("resize", e);
    }), c && c(), v && v.disconnect(), v = null, u && cancelAnimationFrame(f);
  };
}
const Ll = (n, t, e) => {
  const o = /* @__PURE__ */ new Map(), a = { platform: Fl, ...e }, s = { ...a.platform, _c: o };
  return Sl(n, t, { ...a, platform: s });
};
function Nn(n) {
  var t;
  return (t = n == null ? void 0 : n.$el) != null ? t : n;
}
function Vl(n) {
  return {
    name: "arrow",
    options: n,
    fn(t) {
      const e = Nn(l(n.element));
      return e == null ? {} : Pl({
        element: e,
        padding: n.padding
      }).fn(t);
    }
  };
}
function xa(n) {
  return typeof window > "u" ? 1 : (n.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Zo(n, t) {
  const e = xa(n);
  return Math.round(t * e) / e;
}
function Kl(n, t, e) {
  e === void 0 && (e = {});
  const o = e.whileElementsMounted, a = D(() => {
    var x;
    return (x = l(e.open)) != null ? x : !0;
  }), s = D(() => l(e.middleware)), i = D(() => {
    var x;
    return (x = l(e.placement)) != null ? x : "bottom";
  }), r = D(() => {
    var x;
    return (x = l(e.strategy)) != null ? x : "absolute";
  }), u = D(() => {
    var x;
    return (x = l(e.transform)) != null ? x : !0;
  }), d = D(() => Nn(n.value)), p = D(() => Nn(t.value)), c = S(0), f = S(0), v = S(r.value), h = S(i.value), m = zn({}), b = S(!1), $ = D(() => {
    const x = {
      position: v.value,
      left: "0",
      top: "0"
    };
    if (!p.value)
      return x;
    const V = Zo(p.value, c.value), A = Zo(p.value, f.value);
    return u.value ? {
      ...x,
      transform: "translate(" + V + "px, " + A + "px)",
      ...xa(p.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: v.value,
      left: V + "px",
      top: A + "px"
    };
  });
  let O;
  function E() {
    d.value == null || p.value == null || Ll(d.value, p.value, {
      middleware: s.value,
      placement: i.value,
      strategy: r.value
    }).then((x) => {
      c.value = x.x, f.value = x.y, v.value = x.strategy, h.value = x.placement, m.value = x.middlewareData, b.value = !0;
    });
  }
  function P() {
    typeof O == "function" && (O(), O = void 0);
  }
  function B() {
    if (P(), o === void 0) {
      E();
      return;
    }
    if (d.value != null && p.value != null) {
      O = o(d.value, p.value, E);
      return;
    }
  }
  function I() {
    a.value || (b.value = !1);
  }
  return X([s, i, r], E, {
    flush: "sync"
  }), X([d, p], B, {
    flush: "sync"
  }), X(a, I, {
    flush: "sync"
  }), ia() && ra(P), {
    x: Qe(c),
    y: Qe(f),
    strategy: Qe(v),
    placement: Qe(h),
    middlewareData: Qe(m),
    isPositioned: Qe(b),
    floatingStyles: $,
    update: E
  };
}
function Hl(n) {
  return n !== null;
}
function Wl(n) {
  return {
    name: "transformOrigin",
    options: n,
    fn(t) {
      var b, $, O;
      const { placement: e, rects: o, middlewareData: a } = t, i = ((b = a.arrow) == null ? void 0 : b.centerOffset) !== 0, r = i ? 0 : n.arrowWidth, u = i ? 0 : n.arrowHeight, [d, p] = Ln(e), c = { start: "0%", center: "50%", end: "100%" }[p], f = ((($ = a.arrow) == null ? void 0 : $.x) ?? 0) + r / 2, v = (((O = a.arrow) == null ? void 0 : O.y) ?? 0) + u / 2;
      let h = "", m = "";
      return d === "bottom" ? (h = i ? c : `${f}px`, m = `${-u}px`) : d === "top" ? (h = i ? c : `${f}px`, m = `${o.floating.height + u}px`) : d === "right" ? (h = `${-u}px`, m = i ? c : `${v}px`) : d === "left" && (h = `${o.floating.width + u}px`, m = i ? c : `${v}px`), { data: { x: h, y: m } };
    }
  };
}
function Ln(n) {
  const [t, e = "center"] = n.split("-");
  return [t, e];
}
const ka = {
  side: "bottom",
  sideOffset: 0,
  align: "center",
  alignOffset: 0,
  arrowPadding: 0,
  avoidCollisions: !0,
  collisionBoundary: () => [],
  collisionPadding: 0,
  sticky: "partial",
  hideWhenDetached: !1,
  updatePositionStrategy: "optimized",
  prioritizePosition: !1
}, Ma = Symbol(), Ul = {
  inheritAttrs: !1
}, ct = /* @__PURE__ */ w({
  ...Ul,
  __name: "PopperContent",
  props: ca({
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  }, {
    ...ka
  }),
  setup(n, { expose: t }) {
    const e = n, o = T(oo), a = ba(), { primitiveElement: s, currentElement: i } = H(), r = S(), u = S(), { width: d, height: p } = _a(u), c = D(
      () => e.side + (e.align !== "center" ? `-${e.align}` : "")
    ), f = D(() => typeof e.collisionPadding == "number" ? e.collisionPadding : { top: 0, right: 0, bottom: 0, left: 0, ...e.collisionPadding }), v = D(() => Array.isArray(e.collisionBoundary) ? e.collisionBoundary : [e.collisionBoundary]), h = D(() => ({
      padding: f.value,
      boundary: v.value.filter(Hl),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: v.value.length > 0
    })), m = Fs(() => [
      Il({
        mainAxis: e.sideOffset + p.value,
        alignmentAxis: e.alignOffset
      }),
      e.avoidCollisions && Dl({
        mainAxis: !0,
        crossAxis: !!e.prioritizePosition,
        limiter: e.sticky === "partial" ? xl() : void 0,
        ...h.value
      }),
      !e.prioritizePosition && e.avoidCollisions && Tl({
        ...h.value
      }),
      kl({
        ...h.value,
        apply: ({ elements: R, rects: F, availableWidth: U, availableHeight: z }) => {
          const { width: j, height: ne } = F.reference, se = R.floating.style;
          Object.assign(R.floating.style, {
            maxWidth: `${U}px`,
            maxHeight: `${z}px`
          }), se.setProperty(
            "--radix-popper-available-width",
            `${U}px`
          ), se.setProperty(
            "--radix-popper-available-height",
            `${z}px`
          ), se.setProperty(
            "--radix-popper-anchor-width",
            `${j}px`
          ), se.setProperty(
            "--radix-popper-anchor-height",
            `${ne}px`
          );
        }
      }),
      u.value && Vl({ element: u.value, padding: e.arrowPadding }),
      Wl({
        arrowWidth: d.value,
        arrowHeight: p.value
      }),
      e.hideWhenDetached && Bl({ strategy: "referenceHidden", ...h.value })
    ]), { floatingStyles: b, placement: $, isPositioned: O, middlewareData: E } = Kl(
      o.anchor,
      r,
      {
        strategy: "fixed",
        placement: c,
        whileElementsMounted: (...R) => Nl(...R, {
          animationFrame: e.updatePositionStrategy === "always"
        }),
        middleware: m
      }
    ), P = D(
      () => Ln($.value)[0]
    ), B = D(
      () => Ln($.value)[1]
    );
    ee(() => {
      var R;
      O.value && ((R = e.onPlaced) == null || R.call(e));
    });
    const I = D(
      () => {
        var R;
        return ((R = E.value.arrow) == null ? void 0 : R.centerOffset) !== 0;
      }
    ), x = S("");
    ee(() => {
      i.value && (x.value = window.getComputedStyle(i.value).zIndex);
    });
    const V = D(() => {
      var R;
      return ((R = E.value.arrow) == null ? void 0 : R.x) ?? 0;
    }), A = D(() => {
      var R;
      return ((R = E.value.arrow) == null ? void 0 : R.y) ?? 0;
    });
    return W(Ma, {
      placedSide: P,
      onArrowChange: (R) => {
        u.value = R;
      },
      arrowX: V,
      arrowY: A,
      shouldHideArrow: I
    }), t({
      $el: i
    }), (R, F) => {
      var U, z, j;
      return g(), Q("div", {
        ref_key: "floatingRef",
        ref: r,
        "data-radix-popper-content-wrapper": "",
        style: ie({
          ...l(b),
          transform: l(O) ? l(b).transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: x.value,
          ["--radix-popper-transform-origin"]: [
            (U = l(E).transformOrigin) == null ? void 0 : U.x,
            (z = l(E).transformOrigin) == null ? void 0 : z.y
          ].join(" ")
        })
      }, [
        L(l(M), k({
          ref: (ne) => {
            l(a)(ne), s.value = ne;
          }
        }, R.$attrs, {
          "as-child": e.asChild,
          as: R.as,
          "data-side": P.value,
          "data-align": B.value,
          style: {
            // if the PopperContent hasn't been placed yet (not all measurements done)
            // we prevent animations so that users's animation don't kick in too early referring wrong sides
            animation: l(O) ? void 0 : "none",
            // hide the content if using the hide middleware and should be hidden
            opacity: (j = l(E).hide) != null && j.referenceHidden ? 0 : void 0
          }
        }), {
          default: y(() => [
            _(R.$slots, "default")
          ]),
          _: 3
        }, 16, ["as-child", "as", "data-side", "data-align", "style"])
      ], 4);
    };
  }
}), zl = /* @__PURE__ */ St("polygon", { points: "0,0 30,0 15,10" }, null, -1), Yl = /* @__PURE__ */ w({
  __name: "Arrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(n) {
    const t = n, { primitiveElement: e } = H();
    return (o, a) => (g(), C(l(M), k({
      ref_key: "primitiveElement",
      ref: e
    }, t, {
      width: o.width,
      height: o.height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none"
    }), {
      default: y(() => [
        _(o.$slots, "default", {}, () => [
          zl
        ])
      ]),
      _: 3
    }, 16, ["width", "height"]));
  }
}), Gl = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, Xl = {
  inheritAttrs: !1
}, pt = /* @__PURE__ */ w({
  ...Xl,
  __name: "PopperArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(n) {
    const t = T(Ma), e = D(
      () => t != null && t.placedSide ? Gl[t == null ? void 0 : t.placedSide.value] : ""
    );
    return (o, a) => {
      var s, i, r, u;
      return g(), Q("span", {
        ref: (d) => {
          l(t).onArrowChange(d);
        },
        style: ie({
          position: "absolute",
          left: (s = l(t).arrowX) != null && s.value ? `${(i = l(t).arrowX) == null ? void 0 : i.value}px` : void 0,
          top: (r = l(t).arrowY) != null && r.value ? `${(u = l(t).arrowY) == null ? void 0 : u.value}px` : void 0,
          [e.value]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[l(t).placedSide.value],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[l(t).placedSide.value],
          visibility: l(t).shouldHideArrow.value ? "hidden" : void 0
        })
      }, [
        L(Yl, k(o.$attrs, {
          style: {
            display: "block"
          },
          as: o.as,
          "as-child": o.asChild
        }), null, 16, ["as", "as-child"])
      ], 4);
    };
  }
}), ft = /* @__PURE__ */ w({
  __name: "VisuallyHidden",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(n) {
    return (t, e) => (g(), C(l(M), {
      as: t.as,
      "as-child": t.asChild,
      style: ie({
        // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal"
      })
    }, {
      default: y(() => [
        _(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "style"]));
  }
}), Jl = /* @__PURE__ */ w({
  __name: "VisuallyHiddenInput",
  props: {
    name: {},
    value: {}
  },
  setup(n) {
    const t = n, e = D(() => typeof t.value == "string" || typeof t.value == "number" ? [{ name: t.name, value: t.value }] : typeof t.value == "object" && Array.isArray(t.value) ? t.value.flatMap((o, a) => Object.entries(o).map(([s, i]) => ({ name: `[${a}][${t.name}][${s}]`, value: i }))) : typeof t.value == "object" && !Array.isArray(t.value) ? Object.entries(t.value).map(([o, a]) => ({ name: `[${t.name}][${o}]`, value: a })) : []);
    return (o, a) => (g(!0), Q(re, null, Xn(e.value, (s) => (g(), C(ft, {
      key: s.name,
      as: "input",
      type: "hidden",
      hidden: "",
      readonly: "",
      name: s.name,
      value: s.value
    }, null, 8, ["name", "value"]))), 128));
  }
}), Ee = Symbol(), yu = /* @__PURE__ */ w({
  __name: "ComboboxRoot",
  props: {
    modelValue: {},
    defaultValue: {},
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean },
    searchTerm: {},
    multiple: { type: Boolean },
    disabled: { type: Boolean },
    name: {},
    dir: { default: "ltr" },
    filterFunction: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue", "update:open", "update:searchTerm"],
  setup(n, { emit: t }) {
    const e = n, { multiple: o, disabled: a, name: s, dir: i } = G(e), r = q(e, "searchTerm", t, {
      defaultValue: "",
      passive: !e.searchTerm
    }), u = q(e, "modelValue", t, {
      defaultValue: e.defaultValue ?? o.value ? [] : void 0,
      passive: !e.modelValue,
      deep: !0
    }), d = q(e, "open", t, {
      defaultValue: e.defaultOpen,
      passive: !e.open
    });
    async function p(A) {
      var R;
      d.value = A, await Z(), (R = h.value) == null || R.focus(), A || (f.value = !1), !A && !o.value && typeof u.value == "string" && (r.value = u.value);
    }
    function c(A) {
      if (r.value = typeof A == "string" && !o.value ? A : "", o.value && Array.isArray(u.value)) {
        const R = u.value.findIndex((F) => F === A);
        R === -1 ? u.value.push(A) : u.value.splice(R, 1);
      } else
        u.value = A;
      p(!1);
    }
    const f = S(!1), v = S(/* @__PURE__ */ new Set()), h = S(), m = S(), { primitiveElement: b, currentElement: $ } = H(), { createCollection: O } = le(), E = O(m), P = S(), B = D(() => Array.from(v.value).sort((R, F) => E.value.indexOf(R.vnode.el) - E.value.indexOf(F.vnode.el)).map((R) => R.props.value)), I = D(() => {
      if (f.value) {
        if (e.filterFunction)
          return e.filterFunction(B.value, r.value);
        if (typeof B.value[0] == "string")
          return B.value.filter((A) => {
            var R;
            return A.toLowerCase().includes((R = r.value) == null ? void 0 : R.toLowerCase());
          });
      }
      return B.value;
    }), x = D(() => I.value.findIndex((A) => JSON.stringify(A) === JSON.stringify(P.value)));
    X(() => I.value.length, (A) => {
      A && x.value === -1 && (P.value = I.value[0]);
    }), Y(() => {
      typeof u.value == "string" && (r.value = u.value);
    });
    const V = D(
      () => $.value ? !!$.value.closest("form") : !0
    );
    return W(Ee, {
      searchTerm: r,
      modelValue: u,
      onValueChange: c,
      isUserInputted: f,
      multiple: o,
      disabled: a,
      open: d,
      onOpenChange: p,
      options: B,
      optionsInstance: v,
      filteredOptions: I,
      contentId: te(),
      inputElement: h,
      onInputElementChange: (A) => h.value = A,
      onInputNavigation: async (A) => {
        var F, U;
        const R = x.value;
        R === 0 && A === "up" || R === I.value.length - 1 && A === "down" || (R === -1 && I.value.length || A === "home" ? P.value = I.value[0] : A === "end" ? P.value = I.value[I.value.length - 1] : P.value = I.value[A === "up" ? R - 1 : R + 1], (U = (F = Array.from(v.value).find((z) => z.props.value === P.value)) == null ? void 0 : F.vnode.el) == null || U.scrollIntoView({ block: "nearest" }));
      },
      onInputEnter: () => {
        var A, R;
        if (P.value) {
          const F = (R = (A = Array.from(v.value).find((U) => JSON.stringify(U.props.value) === JSON.stringify(P.value))) == null ? void 0 : A.vnode) == null ? void 0 : R.el;
          F ? F.click() : c(P.value);
        }
      },
      selectedValue: P,
      onSelectedValueChange: (A) => P.value = A,
      parentElement: $,
      contentElement: m,
      onContentElementChange: (A) => m.value = A
    }), (A, R) => (g(), C(l(Je), null, {
      default: y(() => [
        L(l(M), k({
          ref_key: "primitiveElement",
          ref: b,
          style: {
            pointerEvents: l(d) ? "auto" : void 0
          },
          as: A.as,
          "as-child": A.asChild
        }, A.$attrs, { dir: l(i) }), {
          default: y(() => [
            _(A.$slots, "default", {
              activeIndex: x.value,
              open: l(d),
              disabled: l(a),
              value: l(u)
            }),
            V.value && l(s) ? (g(), C(l(Jl), {
              key: 0,
              name: l(s),
              value: l(u)
            }, null, 8, ["name", "value"])) : J("", !0)
          ]),
          _: 3
        }, 16, ["style", "as", "as-child", "dir"])
      ]),
      _: 3
    }));
  }
}), ql = ["type", "aria-expanded", "aria-controls", "disabled", "aria-disabled", "autofocus", "onKeydown"], gu = /* @__PURE__ */ w({
  __name: "ComboboxInput",
  props: {
    type: { default: "text" },
    disabled: { type: Boolean },
    autoFocus: { type: Boolean }
  },
  setup(n) {
    const t = n, e = T(Ee), o = S();
    Y(() => {
      e.inputElement = o, e == null || e.onInputElementChange(o.value);
    });
    const a = D(() => t.disabled || (e == null ? void 0 : e.disabled.value) || !1);
    function s(u) {
      e != null && e.open.value ? e.onInputNavigation(u.key === "ArrowUp" ? "up" : "down") : e == null || e.onOpenChange(!0);
    }
    function i(u) {
      e != null && e.open.value && e.onInputNavigation(u.key === "Home" ? "home" : "end");
    }
    function r() {
      e != null && e.open.value || e == null || e.onOpenChange(!0), e.isUserInputted.value = !0;
    }
    return (u, d) => {
      var p, c;
      return tn((g(), Q("input", {
        ref_key: "elRef",
        ref: o,
        "onUpdate:modelValue": d[0] || (d[0] = (f) => l(e).searchTerm.value = f),
        type: u.type,
        "aria-expanded": (p = l(e)) == null ? void 0 : p.open.value,
        "aria-controls": (c = l(e)) == null ? void 0 : c.contentId,
        disabled: a.value,
        "aria-disabled": a.value ?? void 0,
        "aria-autocomplete": "list",
        tabindex: "0",
        role: "combobox",
        autocomplete: "false",
        autofocus: u.autoFocus,
        onInput: r,
        onKeydown: [
          pe(oe(s, ["prevent"]), ["down", "up"]),
          d[1] || (d[1] = pe(
            //@ts-ignore
            (...f) => {
              var v, h;
              return ((v = l(e)) == null ? void 0 : v.onInputEnter) && ((h = l(e)) == null ? void 0 : h.onInputEnter(...f));
            },
            ["enter"]
          )),
          pe(oe(i, ["prevent"]), ["home", "end"])
        ]
      }, null, 40, ql)), [
        [xs, l(e).searchTerm.value]
      ]);
    };
  }
}), bu = /* @__PURE__ */ w({
  __name: "ComboboxHeader",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    return (t, e) => (g(), C(l(qe), { "as-child": "" }, {
      default: y(() => [
        L(l(M), k({
          "as-child": t.asChild,
          as: t.as
        }, t.$attrs), {
          default: y(() => [
            _(t.$slots, "default")
          ]),
          _: 3
        }, 16, ["as-child", "as"])
      ]),
      _: 3
    }));
  }
}), _u = /* @__PURE__ */ w({
  __name: "ComboboxTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(n) {
    const t = n, e = T(Ee), o = D(() => t.disabled || (e == null ? void 0 : e.disabled.value) || !1);
    return (a, s) => {
      var i, r, u;
      return g(), C(l(M), k({
        type: a.as === "button" ? "button" : void 0
      }, t, {
        tabindex: "-1",
        "aria-label": "Show popup",
        "aria-haspopup": "listbox",
        "aria-expanded": (i = l(e)) == null ? void 0 : i.open.value,
        "aria-controls": (r = l(e)) == null ? void 0 : r.contentId,
        "data-state": (u = l(e)) != null && u.open.value ? "open" : "closed",
        disabled: o.value,
        "data-disabled": o.value,
        "aria-disabled": o.value ?? void 0,
        onClick: s[0] || (s[0] = (d) => {
          var p;
          return (p = l(e)) == null ? void 0 : p.onOpenChange(!l(e).open.value);
        })
      }), {
        default: y(() => [
          _(a.$slots, "default")
        ]),
        _: 3
      }, 16, ["type", "aria-expanded", "aria-controls", "data-state", "disabled", "data-disabled", "aria-disabled"]);
    };
  }
}), wu = /* @__PURE__ */ w({
  __name: "ComboboxCancel",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(n) {
    const t = n, e = T(Ee);
    function o() {
      var a;
      e.searchTerm.value = "", (a = e == null ? void 0 : e.inputElement.value) == null || a.focus();
    }
    return (a, s) => (g(), C(l(M), k({
      type: a.as === "button" ? "button" : void 0
    }, t, {
      tabindex: "-1",
      onClick: o
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["type"]));
  }
}), uo = Symbol(), Cu = /* @__PURE__ */ w({
  __name: "ComboboxGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, e = te(), o = S([]);
    W(uo, {
      id: e,
      options: o
    });
    const a = T(Ee), s = D(() => !(a != null && a.isUserInputted.value) || o.value.length === 0 || (a == null ? void 0 : a.filteredOptions.value.map((i) => JSON.stringify(i)).some((i) => o.value.map((r) => JSON.stringify(r)).includes(i))));
    return (i, r) => tn((g(), C(l(M), k({ role: "group" }, t, { "aria-labelledby": l(e) }), {
      default: y(() => [
        _(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-labelledby"])), [
      [ks, s.value]
    ]);
  }
}), Eu = /* @__PURE__ */ w({
  __name: "ComboboxLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: { default: "label" }
  },
  setup(n) {
    const t = n, e = T(uo, {
      id: ""
    });
    return (o, a) => (g(), C(l(M), k(t, {
      id: l(e).id
    }), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["id"]));
  }
}), jl = "dismissableLayer.pointerDownOutside", Zl = "dismissableLayer.focusOutside";
function Ra(n, t) {
  const e = t.closest(
    "[data-dismissable-layer]"
  ), o = n.querySelector(
    "[data-dismissable-layer]"
  );
  if (!o)
    return !1;
  const a = Array.from(
    n.ownerDocument.querySelectorAll("[data-dismissable-layer]")
  );
  return o === e || a.indexOf(o) < a.indexOf(e);
}
function Ql(n, t) {
  var s;
  const e = ((s = t == null ? void 0 : t.value) == null ? void 0 : s.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), o = S(!1), a = S(() => {
  });
  return ee((i) => {
    if (!Ce)
      return;
    const r = async (d) => {
      if (t != null && t.value) {
        if (await Z(), Ra(t.value, d.target)) {
          o.value = !1;
          return;
        }
        if (d.target && !o.value) {
          let p = function() {
            Fa(
              jl,
              n,
              c
            );
          };
          const c = { originalEvent: d };
          d.pointerType === "touch" ? (e.removeEventListener("click", a.value), a.value = p, e.addEventListener("click", a.value, {
            once: !0
          })) : p();
        } else
          e.removeEventListener("click", a.value);
        o.value = !1;
      }
    }, u = window.setTimeout(() => {
      e.addEventListener("pointerdown", r);
    }, 0);
    i(() => {
      window.clearTimeout(u), e.removeEventListener("pointerdown", r), e.removeEventListener("click", a.value);
    });
  }), {
    onPointerDownCapture: () => o.value = !0
  };
}
function ei(n, t) {
  var a;
  const e = ((a = t == null ? void 0 : t.value) == null ? void 0 : a.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), o = S(!1);
  return ee((s) => {
    if (!Ce)
      return;
    const i = async (r) => {
      t != null && t.value && (await Z(), !Ra(t.value, r.target) && r.target && !o.value && Fa(
        Zl,
        n,
        { originalEvent: r }
      ));
    };
    e.addEventListener("focusin", i), s(() => e.removeEventListener("focusin", i));
  }), {
    onFocusCapture: () => o.value = !0,
    onBlurCapture: () => o.value = !1
  };
}
function Fa(n, t, e) {
  const o = e.originalEvent.target, a = new CustomEvent(n, {
    bubbles: !1,
    cancelable: !0,
    detail: e
  });
  t && o.addEventListener(n, t, { once: !0 }), o.dispatchEvent(a);
}
const ge = pa({
  layersRoot: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), Ne = /* @__PURE__ */ w({
  __name: "DismissableLayer",
  props: {
    disableOutsidePointerEvents: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(n, { emit: t }) {
    const e = n, { primitiveElement: o, currentElement: a } = H(), s = D(
      () => {
        var f;
        return ((f = a.value) == null ? void 0 : f.ownerDocument) ?? globalThis.document;
      }
    ), i = D(() => ge.layersRoot), r = D(() => a.value ? Array.from(i.value).indexOf(a.value) : -1), u = D(() => ge.layersWithOutsidePointerEventsDisabled.size > 0), d = D(() => {
      const f = Array.from(i.value), [v] = [...ge.layersWithOutsidePointerEventsDisabled].slice(-1), h = f.indexOf(v);
      return r.value >= h;
    }), p = Ql(async (f) => {
      const v = [...ge.branches].some(
        (h) => h.contains(f.target)
      );
      !d.value || v || (t("pointerDownOutside", f), t("interactOutside", f), await Z(), f.defaultPrevented || t("dismiss"));
    }, a), c = ei((f) => {
      [...ge.branches].some(
        (h) => h.contains(f.target)
      ) || (t("focusOutside", f), t("interactOutside", f), f.defaultPrevented || t("dismiss"));
    }, a);
    return Zn("Escape", (f) => {
      r.value === i.value.size - 1 && (t("escapeKeyDown", f), f.defaultPrevented || t("dismiss"));
    }), ee((f) => {
      if (!a.value)
        return;
      let v;
      e.disableOutsidePointerEvents && (ge.layersWithOutsidePointerEventsDisabled.size === 0 && (v = s.value.body.style.pointerEvents, s.value.body.style.pointerEvents = "none"), ge.layersWithOutsidePointerEventsDisabled.add(a.value)), i.value.add(a.value), f(() => {
        e.disableOutsidePointerEvents && ge.layersWithOutsidePointerEventsDisabled.size === 1 && (s.value.body.style.pointerEvents = v);
      });
    }), ee((f) => {
      f(() => {
        a.value && (i.value.delete(a.value), ge.layersWithOutsidePointerEventsDisabled.delete(a.value));
      });
    }), (f, v) => (g(), C(l(M), {
      ref_key: "primitiveElement",
      ref: o,
      "as-child": f.asChild,
      as: f.as,
      "data-dismissable-layer": "",
      style: ie({
        pointerEvents: u.value ? d.value ? "auto" : "none" : void 0
      }),
      onFocusCapture: l(c).onFocusCapture,
      onBlurCapture: l(c).onBlurCapture,
      onPointerdownCapture: l(p).onPointerDownCapture
    }, {
      default: y(() => [
        _(f.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "style", "onFocusCapture", "onBlurCapture", "onPointerdownCapture"]));
  }
}), ti = /* @__PURE__ */ w({
  __name: "DismissableLayerBranch",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, { primitiveElement: e, currentElement: o } = H();
    return Y(() => {
      ge.branches.add(o.value);
    }), ue(() => {
      ge.branches.delete(o.value);
    }), (a, s) => (g(), C(l(M), k({
      ref_key: "primitiveElement",
      ref: e
    }, t), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Na = Symbol(), ni = /* @__PURE__ */ w({
  __name: "ComboboxContentImpl",
  props: {
    position: { default: "inline" },
    bodyLock: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(n, { emit: t }) {
    const e = n, { position: o } = G(e), a = T(Ee);
    Tt(e.bodyLock);
    const { primitiveElement: s, currentElement: i } = H();
    Pt(i);
    const r = D(() => e.position === "popper" ? e : {});
    function u(p) {
      a == null || a.onSelectedValueChange("");
    }
    Y(() => {
      a == null || a.onContentElementChange(i.value);
    });
    const d = {
      // Ensure border-box for floating-ui calculations
      boxSizing: "border-box",
      "--radix-combobox-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-combobox-content-available-width": "var(--radix-popper-available-width)",
      "--radix-combobox-content-available-height": "var(--radix-popper-available-height)",
      "--radix-combobox-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-combobox-trigger-height": "var(--radix-popper-anchor-height)"
    };
    return W(Na, {
      position: o
    }), (p, c) => (g(), C(l(Ne), {
      "as-child": "",
      "disable-outside-pointer-events": p.disableOutsidePointerEvents,
      onFocusOutside: c[0] || (c[0] = oe(() => {
      }, ["prevent"])),
      onDismiss: c[1] || (c[1] = (f) => {
        var v;
        return (v = l(a)) == null ? void 0 : v.onOpenChange(!1);
      }),
      onEscapeKeyDown: c[2] || (c[2] = (f) => t("escapeKeyDown", f)),
      onPointerDownOutside: c[3] || (c[3] = (f) => {
        var v, h;
        (h = (v = l(a)) == null ? void 0 : v.parentElement.value) != null && h.contains(f.target) && f.preventDefault(), t("pointerDownOutside", f);
      })
    }, {
      default: y(() => {
        var f, v;
        return [
          (g(), C(Fe(l(o) === "popper" ? l(ct) : l(M)), k({ ...p.$attrs, ...r.value }, {
            id: (f = l(a)) == null ? void 0 : f.contentId,
            ref_key: "primitiveElement",
            ref: s,
            role: "listbox",
            "data-state": (v = l(a)) != null && v.open.value ? "open" : "closed",
            style: {
              // flex layout so we can place the scroll buttons properly
              display: "flex",
              flexDirection: "column",
              // reset the outline by default as the content MAY get focused
              outline: "none",
              ...l(o) === "popper" ? d : {}
            },
            onPointerleave: u
          }), {
            default: y(() => [
              _(p.$slots, "default")
            ]),
            _: 3
          }, 16, ["id", "data-state", "style"]))
        ];
      }),
      _: 3
    }, 8, ["disable-outside-pointer-events"]));
  }
}), $u = /* @__PURE__ */ w({
  __name: "ComboboxContent",
  props: {
    position: {},
    bodyLock: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(n, { emit: t }) {
    const o = fe(n, t), a = T(Ee);
    return (s, i) => (g(), C(l(ce), {
      present: l(a).open.value
    }, {
      default: y(() => [
        L(ni, N(K({ ...l(o), ...s.$attrs })), {
          default: y(() => [
            _(s.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), Ou = /* @__PURE__ */ w({
  __name: "ComboboxEmpty",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, e = T(Ee), o = D(() => (e == null ? void 0 : e.searchTerm.value) && e.filteredOptions.value.length === 0);
    return (a, s) => o.value ? (g(), C(l(M), N(k({ key: 0 }, t)), {
      default: y(() => [
        _(a.$slots, "default", {}, () => [
          de("No options")
        ])
      ]),
      _: 3
    }, 16)) : J("", !0);
  }
}), Su = /* @__PURE__ */ w({
  __name: "ComboboxViewport",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), Q(re, null, [
      L(l(M), { as: "style" }, {
        default: y(() => [
          de(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-select-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-select-viewport]::-webkit-scrollbar { display: none; } ")
        ]),
        _: 1
      }),
      L(l(M), k({
        "data-radix-combobox-viewport": "",
        role: "presentation"
      }, { ...e.$attrs, ...t }, { style: {
        // we use position: 'relative' here on the `viewport` so that when we call
        // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
        // (independent of the scrollUpButton).
        position: "relative",
        flex: 1,
        overflow: "auto"
      } }), {
        default: y(() => [
          _(e.$slots, "default")
        ]),
        _: 3
      }, 16, ["style"])
    ], 64));
  }
}), La = Symbol(), Pu = /* @__PURE__ */ w({
  __name: "ComboboxItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(n, { emit: t }) {
    const e = n, { disabled: o } = G(e), a = T(Ee), s = T(uo), { primitiveElement: i, currentElement: r } = H(), u = D(
      () => {
        var b, $;
        return a != null && a.multiple.value && Array.isArray(a.modelValue.value) ? (b = a.modelValue.value) == null ? void 0 : b.includes(e.value) : JSON.stringify(($ = a == null ? void 0 : a.modelValue) == null ? void 0 : $.value) === JSON.stringify(e.value);
      }
    ), d = D(() => JSON.stringify(a == null ? void 0 : a.selectedValue.value) === JSON.stringify(e.value)), p = S(e.textValue ?? ""), c = te(), f = D(() => a != null && a.isUserInputted.value ? (a == null ? void 0 : a.searchTerm.value) === "" || (a == null ? void 0 : a.filteredOptions.value.map((b) => JSON.stringify(b)).includes(JSON.stringify(e.value))) : !0);
    async function v(b) {
      await Z(), !(b != null && b.defaultPrevented) && (o.value || (a.onValueChange(e.value), t("select", e.value)));
    }
    async function h(b) {
      await Z(), !b.defaultPrevented && (a == null || a.onSelectedValueChange(e.value));
    }
    if (e.value === "")
      throw new Error(
        "A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    const m = Xe();
    return Y(() => {
      var b, $, O, E;
      m && (a == null || a.optionsInstance.value.add(m)), ($ = (b = s == null ? void 0 : s.options) == null ? void 0 : b.value) != null && $.includes(e.value) || (O = s == null ? void 0 : s.options) == null || O.value.push(e.value), !p.value && ((E = r.value) != null && E.textContent) && (p.value = r.value.textContent);
    }), ue(() => {
      m && (a == null || a.optionsInstance.value.delete(m));
    }), W(La, {
      isSelected: u
    }), (b, $) => f.value ? (g(), C(l(M), {
      key: 0,
      ref_key: "primitiveElement",
      ref: i,
      role: "option",
      tabindex: "-1",
      "data-radix-vue-collection-item": "",
      "aria-labelledby": l(c),
      "data-highlighted": d.value ? "" : void 0,
      "aria-selected": u.value,
      "data-state": u.value ? "checked" : "unchecked",
      "aria-disabled": l(o) || void 0,
      "data-disabled": l(o) ? "" : void 0,
      as: b.as,
      "as-child": b.asChild,
      onClick: v,
      onPointermove: h
    }, {
      default: y(() => [
        _(b.$slots, "default", {}, () => [
          de(st(b.value), 1)
        ])
      ]),
      _: 3
    }, 8, ["aria-labelledby", "data-highlighted", "aria-selected", "data-state", "aria-disabled", "data-disabled", "as", "as-child"])) : J("", !0);
  }
}), Tu = /* @__PURE__ */ w({
  __name: "ComboboxItemIndicator",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(n) {
    const t = n, e = T(La);
    return (o, a) => {
      var s;
      return (s = l(e)) != null && s.isSelected.value ? (g(), C(l(M), k({
        key: 0,
        "aria-hidden": ""
      }, t), {
        default: y(() => [
          _(o.$slots, "default")
        ]),
        _: 3
      }, 16)) : J("", !0);
    };
  }
}), Bu = /* @__PURE__ */ w({
  __name: "ComboboxSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(M), k({ "aria-hidden": "" }, t), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Au = /* @__PURE__ */ w({
  __name: "ComboboxArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, e = T(Ee), o = T(Na);
    return (a, s) => {
      var i, r;
      return (i = l(e)) != null && i.open.value && ((r = l(o)) == null ? void 0 : r.position.value) === "popper" ? (g(), C(l(pt), N(k({ key: 0 }, t)), {
        default: y(() => [
          _(a.$slots, "default")
        ]),
        _: 3
      }, 16)) : J("", !0);
    };
  }
}), Le = /* @__PURE__ */ w({
  __name: "Teleport",
  props: {
    to: { default: "body" },
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(n) {
    const t = on();
    return (e, o) => l(t) || e.forceMount ? (g(), C(lt, {
      key: 0,
      to: e.to,
      disabled: e.disabled
    }, [
      _(e.$slots, "default")
    ], 8, ["to", "disabled"])) : J("", !0);
  }
}), Iu = /* @__PURE__ */ w({
  __name: "ComboboxPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(Le), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), oi = ["checked", "name", "disabled", "required", "data-state", "data-disabled"], Va = Symbol(), Du = /* @__PURE__ */ w({
  __name: "SwitchRoot",
  props: {
    defaultChecked: { type: Boolean },
    checked: { type: Boolean },
    disabled: { type: Boolean, default: !1 },
    required: { type: Boolean },
    name: {},
    id: {},
    value: { default: "on" },
    asChild: { type: Boolean, default: !1 },
    as: { default: "button" }
  },
  emits: ["update:checked"],
  setup(n, { emit: t }) {
    const e = n, { disabled: o } = G(e), a = q(e, "checked", t, {
      defaultValue: e.defaultChecked,
      passive: !0
      // set passive to true so that if no props.modelValue was passed, it will still update
    });
    function s() {
      o.value || (a.value = !a.value);
    }
    const { primitiveElement: i, currentElement: r } = H(), u = D(() => r.value ? !!r.value.closest("form") : !0), d = D(() => {
      var p;
      return e.id && r.value ? (p = document.querySelector(`[for="${e.id}"]`)) == null ? void 0 : p.innerText : void 0;
    });
    return W(Va, {
      checked: a,
      toggleCheck: s,
      disabled: o
    }), (p, c) => (g(), Q(re, null, [
      L(l(M), k(p.$attrs, {
        id: p.id,
        ref_key: "primitiveElement",
        ref: i,
        role: "switch",
        type: p.as === "button" ? "button" : void 0,
        value: p.value,
        "aria-label": p.$attrs["aria-label"] || d.value,
        "aria-checked": l(a),
        "aria-required": p.required,
        "data-state": l(a) ? "checked" : "unchecked",
        "data-disabled": l(o) ? "" : void 0,
        "as-child": p.asChild,
        as: p.as,
        disabled: l(o),
        onClick: s,
        onKeydown: pe(oe(s, ["prevent"]), ["enter"])
      }), {
        default: y(() => [
          _(p.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "type", "value", "aria-label", "aria-checked", "aria-required", "data-state", "data-disabled", "as-child", "as", "disabled", "onKeydown"]),
      u.value ? (g(), Q("input", {
        key: 0,
        checked: l(a),
        type: "checkbox",
        name: p.name,
        tabindex: "-1",
        "aria-hidden": "",
        disabled: l(o),
        required: p.required,
        "data-state": l(a) ? "checked" : "unchecked",
        "data-disabled": l(o) ? "" : void 0,
        style: ie({
          transform: "translateX(-100%)",
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        })
      }, null, 12, oi)) : J("", !0)
    ], 64));
  }
}), xu = /* @__PURE__ */ w({
  __name: "SwitchThumb",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(n) {
    const t = T(Va);
    return (e, o) => {
      var a, s, i;
      return g(), C(l(M), {
        "data-state": (s = (a = l(t)) == null ? void 0 : a.checked) != null && s.value ? "checked" : "unchecked",
        "data-disabled": (i = l(t)) != null && i.disabled.value ? "" : void 0,
        "as-child": e.asChild,
        as: e.as
      }, {
        default: y(() => [
          _(e.$slots, "default")
        ]),
        _: 3
      }, 8, ["data-state", "data-disabled", "as-child", "as"]);
    };
  }
}), Ka = /* @__PURE__ */ w({
  __name: "BaseSeparator",
  props: {
    orientation: { default: "horizontal" },
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, e = ["horizontal", "vertical"];
    function o(r) {
      return e.includes(r);
    }
    const a = D(
      () => o(t.orientation) ? t.orientation : "horizontal"
    ), s = D(
      () => a.value === "vertical" ? t.orientation : void 0
    ), i = D(
      () => t.decorative ? { role: "none" } : { "aria-orientation": s.value, role: "separator" }
    );
    return (r, u) => (g(), C(l(M), k({
      as: r.as,
      "as-child": r.asChild,
      "data-orientation": a.value
    }, i.value), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["as", "as-child", "data-orientation"]));
  }
}), ku = /* @__PURE__ */ w({
  __name: "Separator",
  props: {
    orientation: { default: "horizontal" },
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(Ka, N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Mu = /* @__PURE__ */ w({
  __name: "Label",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: { default: "label" }
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(M), k(t, {
      onMousedown: o[0] || (o[0] = (a) => {
        !a.defaultPrevented && a.detail > 1 && a.preventDefault();
      })
    }), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ai = /* @__PURE__ */ w({
  __name: "ToggleRoot",
  props: {
    defaultValue: { type: Boolean },
    pressed: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  emits: ["update:pressed"],
  setup(n, { emit: t }) {
    const e = n, o = q(e, "pressed", t, {
      defaultValue: e.defaultValue,
      passive: !0
    });
    function a() {
      o.value = !o.value;
    }
    const s = D(() => o.value ? "on" : "off");
    return (i, r) => (g(), C(l(M), {
      type: i.as === "button" ? "button" : void 0,
      "as-child": e.asChild,
      as: i.as,
      "aria-pressed": l(o),
      "data-state": s.value,
      "data-disabled": i.disabled ? "" : void 0,
      disabled: i.disabled,
      onClick: a,
      onKeydown: pe(a, ["enter"])
    }, {
      default: y(() => [
        _(i.$slots, "default")
      ]),
      _: 3
    }, 8, ["type", "as-child", "as", "aria-pressed", "data-state", "data-disabled", "disabled", "onKeydown"]));
  }
}), si = "rovingFocusGroup.onEntryFocus", li = { bubbles: !1, cancelable: !0 }, ii = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function ri(n, t) {
  return t !== "rtl" ? n : n === "ArrowLeft" ? "ArrowRight" : n === "ArrowRight" ? "ArrowLeft" : n;
}
function ui(n, t, e) {
  const o = ri(n.key, e);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(o)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(o)))
    return ii[o];
}
function Ha(n) {
  const t = document.activeElement;
  for (const e of n)
    if (e === t || (e.focus(), document.activeElement !== t))
      return;
}
function di(n, t) {
  return n.map((e, o) => n[(t + o) % n.length]);
}
const Wa = Symbol(), vt = /* @__PURE__ */ w({
  __name: "RovingFocusGroup",
  props: {
    orientation: { default: void 0 },
    dir: { default: "ltr" },
    loop: { type: Boolean, default: !1 },
    currentTabStopId: {},
    defaultCurrentTabStopId: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["entryFocus", "update:currentTabStopId"],
  setup(n, { emit: t }) {
    const e = n, { loop: o, orientation: a, dir: s } = G(e), i = q(e, "currentTabStopId", t, {
      defaultValue: e.defaultCurrentTabStopId,
      passive: !0
    }), r = S(!1), u = S(!1), d = S(0), { primitiveElement: p, currentElement: c } = H(), { createCollection: f } = le("rovingFocus"), v = f(c);
    function h(m) {
      const b = !u.value;
      if (m.currentTarget && m.target === m.currentTarget && b && !r.value) {
        const $ = new CustomEvent(si, li);
        if (m.currentTarget.dispatchEvent($), t("entryFocus", $), !$.defaultPrevented) {
          const O = v.value, E = O.find((I) => I.getAttribute("data-active") === "true"), P = O.find(
            (I) => I.id === i.value
          ), B = [E, P, ...O].filter(
            Boolean
          );
          Ha(B);
        }
      }
      u.value = !1;
    }
    return W(Wa, {
      loop: o,
      dir: s,
      orientation: a,
      currentTabStopId: i,
      onItemFocus: (m) => {
        i.value = m;
      },
      onItemShiftTab: () => {
        r.value = !0;
      },
      onFocusableItemAdd: () => {
        d.value++;
      },
      onFocusableItemRemove: () => {
        d.value--;
      }
    }), (m, b) => (g(), C(l(M), {
      ref_key: "primitiveElement",
      ref: p,
      tabindex: r.value || d.value === 0 ? -1 : 0,
      "data-orientation": l(a),
      as: m.as,
      "as-child": m.asChild,
      style: { outline: "none" },
      onMousedown: b[0] || (b[0] = ($) => u.value = !0),
      onFocus: h,
      onBlur: b[1] || (b[1] = ($) => r.value = !1)
    }, {
      default: y(() => [
        _(m.$slots, "default")
      ]),
      _: 3
    }, 8, ["tabindex", "data-orientation", "as", "as-child"]));
  }
}), mt = /* @__PURE__ */ w({
  __name: "RovingFocusItem",
  props: {
    tabStopId: {},
    focusable: { type: Boolean, default: !0 },
    active: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(n) {
    const t = n, e = T(Wa), o = te(), a = D(() => t.tabStopId || o), s = D(
      () => (e == null ? void 0 : e.currentTabStopId.value) === a.value
    ), { injectCollection: i } = le("rovingFocus"), r = i(), { onFocusableItemAdd: u, onFocusableItemRemove: d } = e;
    Y(() => {
      t.focusable && u();
    }), ue(() => {
      t.focusable && d();
    });
    function p(c) {
      if (c.key === "Tab" && c.shiftKey) {
        e == null || e.onItemShiftTab();
        return;
      }
      if (c.target !== c.currentTarget)
        return;
      const f = ui(
        c,
        e == null ? void 0 : e.orientation.value,
        e == null ? void 0 : e.dir.value
      );
      if (f !== void 0) {
        c.preventDefault();
        let v = [...r.value];
        if (f === "last")
          v.reverse();
        else if (f === "prev" || f === "next") {
          f === "prev" && v.reverse();
          const h = v.indexOf(
            c.currentTarget
          );
          v = e != null && e.loop.value ? di(v, h + 1) : v.slice(h + 1);
        }
        Z(() => Ha(v));
      }
    }
    return (c, f) => {
      var v;
      return g(), C(l(M), {
        "data-radix-vue-collection-item": "",
        tabindex: s.value ? 0 : -1,
        "data-orientation": (v = l(e)) == null ? void 0 : v.orientation.value,
        "data-active": c.active,
        "data-disabled": !c.focusable || void 0,
        as: c.as,
        "as-child": c.asChild,
        onMousedown: f[0] || (f[0] = (h) => {
          var m;
          c.focusable ? (m = l(e)) == null || m.onItemFocus(a.value) : h.preventDefault();
        }),
        onFocus: f[1] || (f[1] = (h) => {
          var m;
          return (m = l(e)) == null ? void 0 : m.onItemFocus(a.value);
        }),
        onKeydown: p
      }, {
        default: y(() => [
          _(c.$slots, "default")
        ]),
        _: 3
      }, 8, ["tabindex", "data-orientation", "data-active", "data-disabled", "as", "as-child"]);
    };
  }
}), Ua = Symbol(), ci = /* @__PURE__ */ w({
  __name: "ToggleGroupRoot",
  props: {
    type: { default: "single" },
    defaultValue: {},
    modelValue: {},
    rovingFocus: { type: Boolean, default: !0 },
    disabled: { type: Boolean, default: !1 },
    orientation: { default: "horizontal" },
    dir: { default: "ltr" },
    loop: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(n, { emit: t }) {
    const e = n, { loop: o, rovingFocus: a, disabled: s, dir: i } = G(e), { modelValue: r, changeModelValue: u } = Ea(e, t);
    return W(Ua, {
      type: e.type,
      modelValue: r,
      changeModelValue: u,
      dir: i,
      orientation: e.orientation,
      loop: o,
      rovingFocus: a,
      disabled: s
    }), (d, p) => (g(), C(Fe(l(a) ? l(vt) : l(M)), {
      "as-child": "",
      orientation: l(a) ? d.orientation : void 0,
      dir: l(i),
      loop: l(a) ? l(o) : void 0
    }, {
      default: y(() => [
        L(l(M), {
          role: "group",
          "as-child": d.asChild,
          as: d.as
        }, {
          default: y(() => [
            _(d.$slots, "default", { modelValue: l(r) })
          ]),
          _: 3
        }, 8, ["as-child", "as"])
      ]),
      _: 3
    }, 8, ["orientation", "dir", "loop"]));
  }
}), pi = /* @__PURE__ */ w({
  __name: "ToggleGroupItem",
  props: {
    value: {},
    defaultValue: { type: Boolean },
    pressed: { type: Boolean },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(n) {
    const t = n, e = T(Ua), o = D(() => {
      var s;
      return ((s = e == null ? void 0 : e.disabled) == null ? void 0 : s.value) || t.disabled;
    }), a = D(() => {
      var s;
      return (s = e == null ? void 0 : e.modelValue.value) == null ? void 0 : s.includes(t.value);
    });
    return (s, i) => {
      var r;
      return g(), C(Fe((r = l(e)) != null && r.rovingFocus.value ? l(mt) : l(M)), {
        "as-child": "",
        focusable: !o.value,
        active: a.value
      }, {
        default: y(() => {
          var u, d, p, c;
          return [
            L(l(ai), k(t, {
              disabled: o.value,
              pressed: ((u = l(e)) == null ? void 0 : u.type) === "single" ? ((d = l(e)) == null ? void 0 : d.modelValue.value) === s.value : (c = (p = l(e)) == null ? void 0 : p.modelValue.value) == null ? void 0 : c.includes(s.value),
              "onUpdate:pressed": i[0] || (i[0] = (f) => {
                var v;
                return (v = l(e)) == null ? void 0 : v.changeModelValue(s.value);
              })
            }), {
              default: y(() => [
                _(s.$slots, "default")
              ]),
              _: 3
            }, 16, ["disabled", "pressed"])
          ];
        }),
        _: 3
      }, 8, ["focusable", "active"]);
    };
  }
}), fi = {
  inheritAttrs: !1
}, Ru = /* @__PURE__ */ w({
  ...fi,
  __name: "AspectRatio",
  props: {
    ratio: { default: 1 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, e = D(() => 1 / t.ratio * 100);
    return (o, a) => (g(), Q("div", {
      style: ie(`position: relative; width: 100%; padding-bottom: ${e.value}%`),
      "data-radix-aspect-ratio-wrapper": ""
    }, [
      L(l(M), k({
        "as-child": o.asChild,
        as: o.as,
        style: { position: "absolute", inset: "0px" }
      }, o.$attrs), {
        default: y(() => [
          _(o.$slots, "default", { aspect: e.value })
        ]),
        _: 3
      }, 16, ["as-child", "as"])
    ], 4));
  }
}), cn = Symbol(), Fu = /* @__PURE__ */ w({
  __name: "TabsRoot",
  props: {
    defaultValue: {},
    orientation: { default: "horizontal" },
    dir: { default: "ltr" },
    activationMode: { default: "automatic" },
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(n, { emit: t }) {
    const e = n, { orientation: o, dir: a } = G(e), s = q(e, "modelValue", t, {
      defaultValue: e.defaultValue,
      passive: !0
    });
    return W(cn, {
      modelValue: s,
      changeModelValue: (i) => {
        s.value = i;
      },
      orientation: o,
      dir: a,
      activationMode: e.activationMode,
      baseId: te()
    }), (i, r) => (g(), C(l(M), {
      dir: l(a),
      "data-orientation": l(o),
      "as-child": i.asChild,
      as: i.as
    }, {
      default: y(() => [
        _(i.$slots, "default")
      ]),
      _: 3
    }, 8, ["dir", "data-orientation", "as-child", "as"]));
  }
}), Nu = /* @__PURE__ */ w({
  __name: "TabsList",
  props: {
    loop: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, { loop: e } = G(t), o = T(cn);
    return (a, s) => {
      var i, r;
      return g(), C(l(vt), {
        "as-child": "",
        orientation: (i = l(o)) == null ? void 0 : i.orientation.value,
        dir: (r = l(o)) == null ? void 0 : r.dir.value,
        loop: l(e)
      }, {
        default: y(() => {
          var u;
          return [
            L(l(M), {
              role: "tablist",
              "as-child": a.asChild,
              as: a.as,
              "aria-orientation": (u = l(o)) == null ? void 0 : u.orientation.value
            }, {
              default: y(() => [
                _(a.$slots, "default")
              ]),
              _: 3
            }, 8, ["as-child", "as", "aria-orientation"])
          ];
        }),
        _: 3
      }, 8, ["orientation", "dir", "loop"]);
    };
  }
});
function za(n, t) {
  return `${n}-trigger-${t}`;
}
function Ya(n, t) {
  return `${n}-content-${t}`;
}
const Lu = /* @__PURE__ */ w({
  __name: "TabsContent",
  props: {
    value: {},
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, e = T(cn), o = D(() => za(e.baseId, t.value)), a = D(() => Ya(e.baseId, t.value)), s = D(() => t.value === (e == null ? void 0 : e.modelValue.value)), i = S(s.value);
    Y(() => {
      requestAnimationFrame(() => i.value = !1);
    });
    const r = S();
    return (u, d) => (g(), C(l(ce), {
      ref_key: "presenceRef",
      ref: r,
      present: u.forceMount || s.value
    }, {
      default: y(() => {
        var p, c;
        return [
          L(l(M), {
            id: a.value,
            "as-child": u.asChild,
            as: u.as,
            role: "tabpanel",
            "data-state": s.value ? "active" : "inactive",
            "data-orientation": (p = l(e)) == null ? void 0 : p.orientation.value,
            "aria-labelledby": o.value,
            hidden: !((c = r.value) != null && c.present),
            tabindex: "0",
            style: ie({
              animationDuration: i.value ? "0s" : void 0
            })
          }, {
            default: y(() => [
              _(u.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "as-child", "as", "data-state", "data-orientation", "aria-labelledby", "hidden", "style"])
        ];
      }),
      _: 3
    }, 8, ["present"]));
  }
}), Vu = /* @__PURE__ */ w({
  __name: "TabsTrigger",
  props: {
    value: {},
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(n) {
    const t = n, e = T(cn), o = D(() => za(e.baseId, t.value)), a = D(() => Ya(e.baseId, t.value)), s = D(() => t.value === (e == null ? void 0 : e.modelValue.value));
    return (i, r) => (g(), C(l(mt), {
      "as-child": "",
      focusable: !i.disabled,
      active: s.value
    }, {
      default: y(() => {
        var u;
        return [
          L(l(M), {
            id: o.value,
            role: "tab",
            type: i.as === "button" ? "button" : void 0,
            as: i.as,
            "as-child": i.asChild,
            "aria-selected": s.value ? "true" : "false",
            "aria-controls": a.value,
            "data-state": s.value ? "active" : "inactive",
            disabled: i.disabled,
            "data-disabled": i.disabled ? "" : void 0,
            "data-orientation": (u = l(e)) == null ? void 0 : u.orientation.value,
            onMousedown: r[0] || (r[0] = oe((d) => {
              var p;
              !i.disabled && d.ctrlKey === !1 ? (p = l(e)) == null || p.changeModelValue(i.value) : d.preventDefault();
            }, ["left"])),
            onKeydown: r[1] || (r[1] = pe((d) => {
              var p;
              return (p = l(e)) == null ? void 0 : p.changeModelValue(i.value);
            }, ["enter", "space"])),
            onFocus: r[2] || (r[2] = () => {
              var p, c;
              const d = ((p = l(e)) == null ? void 0 : p.activationMode) !== "manual";
              !s.value && !i.disabled && d && ((c = l(e)) == null || c.changeModelValue(i.value));
            })
          }, {
            default: y(() => [
              _(i.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "type", "as", "as-child", "aria-selected", "aria-controls", "data-state", "disabled", "data-disabled", "data-orientation"])
        ];
      }),
      _: 3
    }, 8, ["focusable", "active"]));
  }
});
function Ga(n, [t, e]) {
  return Math.min(e, Math.max(t, n));
}
function vi(n = [], t, e) {
  const o = [...n];
  return o[e] = t, o.sort((a, s) => a - s);
}
function Xa(n, t, e) {
  const s = 100 / (e - t) * (n - t);
  return Ga(s, [0, 100]);
}
function mi(n, t) {
  return t > 2 ? `Value ${n + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][n] : void 0;
}
function hi(n, t) {
  if (n.length === 1)
    return 0;
  const e = n.map((a) => Math.abs(a - t)), o = Math.min(...e);
  return e.indexOf(o);
}
function yi(n, t, e) {
  const o = n / 2, s = co([0, 50], [0, o]);
  return (o - s(t) * e) * e;
}
function gi(n) {
  return n.slice(0, -1).map((t, e) => n[e + 1] - t);
}
function bi(n, t) {
  if (t > 0) {
    const e = gi(n);
    return Math.min(...e) >= t;
  }
  return !0;
}
function co(n, t) {
  return (e) => {
    if (n[0] === n[1] || t[0] === t[1])
      return t[0];
    const o = (t[1] - t[0]) / (n[1] - n[0]);
    return t[0] + o * (e - n[0]);
  };
}
function _i(n) {
  return (String(n).split(".")[1] || "").length;
}
function wi(n, t) {
  const e = 10 ** t;
  return Math.round(n * e) / e;
}
const Ja = ["PageUp", "PageDown"], qa = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], ja = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
}, pn = Symbol(), Za = /* @__PURE__ */ w({
  __name: "SliderImpl",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  emits: ["slideStart", "slideMove", "slideEnd", "homeKeyDown", "endKeyDown", "stepKeyDown"],
  setup(n, { emit: t }) {
    const e = n, o = T(At);
    return (a, s) => (g(), C(l(M), k(e, {
      onKeydown: s[0] || (s[0] = (i) => {
        i.key === "Home" ? (t("homeKeyDown", i), i.preventDefault()) : i.key === "End" ? (t("endKeyDown", i), i.preventDefault()) : l(Ja).concat(l(qa)).includes(i.key) && (t("stepKeyDown", i), i.preventDefault());
      }),
      onPointerdown: s[1] || (s[1] = (i) => {
        const r = i.target;
        r.setPointerCapture(i.pointerId), i.preventDefault(), l(o).thumbElements.value.includes(r) ? r.focus() : t("slideStart", i);
      }),
      onPointermove: s[2] || (s[2] = (i) => {
        i.target.hasPointerCapture(i.pointerId) && t("slideMove", i);
      }),
      onPointerup: s[3] || (s[3] = (i) => {
        const r = i.target;
        r.hasPointerCapture(i.pointerId) && (r.releasePointerCapture(i.pointerId), t("slideEnd", i));
      })
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ci = /* @__PURE__ */ w({
  __name: "SliderHorizontal",
  props: {
    dir: {},
    min: {},
    max: {},
    inverted: { type: Boolean }
  },
  emits: ["slideEnd", "slideStart", "slideMove", "homeKeyDown", "endKeyDown", "stepKeyDown"],
  setup(n, { emit: t }) {
    const e = n, { max: o, min: a, dir: s, inverted: i } = G(e), { primitiveElement: r, currentElement: u } = H(), d = S(), p = D(() => (s == null ? void 0 : s.value) === "ltr" && !i.value || (s == null ? void 0 : s.value) !== "ltr" && i.value);
    function c(f) {
      const v = d.value || u.value.getBoundingClientRect(), h = [0, v.width], m = p.value ? [a.value, o.value] : [o.value, a.value], b = co(h, m);
      return d.value = v, b(f - v.left);
    }
    return W(pn, {
      startEdge: p.value ? "left" : "right",
      endEdge: p.value ? "right" : "left",
      direction: p.value ? 1 : -1,
      size: "width"
    }), (f, v) => (g(), C(Za, {
      ref_key: "primitiveElement",
      ref: r,
      dir: l(s),
      "data-orientation": "horizontal",
      style: ie({
        ["--radix-slider-thumb-transform"]: "translateX(-50%)"
      }),
      onSlideStart: v[0] || (v[0] = (h) => {
        const m = c(h.clientX);
        t("slideStart", m);
      }),
      onSlideMove: v[1] || (v[1] = (h) => {
        const m = c(h.clientX);
        t("slideMove", m);
      }),
      onSlideEnd: v[2] || (v[2] = () => {
        d.value = void 0, t("slideEnd");
      }),
      onStepKeyDown: v[3] || (v[3] = (h) => {
        const m = p.value ? "from-left" : "from-right", b = l(ja)[m].includes(h.key);
        t("stepKeyDown", h, b ? -1 : 1);
      }),
      onEndKeyDown: v[4] || (v[4] = (h) => t("endKeyDown", h)),
      onHomeKeyDown: v[5] || (v[5] = (h) => t("homeKeyDown", h))
    }, {
      default: y(() => [
        _(f.$slots, "default")
      ]),
      _: 3
    }, 8, ["dir", "style"]));
  }
}), Ei = /* @__PURE__ */ w({
  __name: "SliderVertical",
  props: {
    min: {},
    max: {},
    inverted: { type: Boolean }
  },
  emits: ["slideEnd", "slideStart", "slideMove", "homeKeyDown", "endKeyDown", "stepKeyDown"],
  setup(n, { emit: t }) {
    const e = n, { max: o, min: a, inverted: s } = G(e), { primitiveElement: i, currentElement: r } = H(), u = S(), d = D(() => !s.value);
    function p(c) {
      const f = u.value || r.value.getBoundingClientRect(), v = [0, f.height], h = d.value ? [o.value, a.value] : [a.value, o.value], m = co(v, h);
      return u.value = f, m(c - f.top);
    }
    return W(pn, {
      startEdge: d.value ? "bottom" : "top",
      endEdge: d.value ? "top" : "bottom",
      size: "height",
      direction: d.value ? 1 : -1
    }), (c, f) => (g(), C(Za, {
      ref_key: "primitiveElement",
      ref: i,
      "data-orientation": "vertical",
      style: ie({
        ["--radix-slider-thumb-transform"]: "translateY(50%)"
      }),
      onSlideStart: f[0] || (f[0] = (v) => {
        const h = p(v.clientY);
        t("slideStart", h);
      }),
      onSlideMove: f[1] || (f[1] = (v) => {
        const h = p(v.clientY);
        t("slideMove", h);
      }),
      onSlideEnd: f[2] || (f[2] = () => {
        u.value = void 0, t("slideEnd");
      }),
      onStepKeyDown: f[3] || (f[3] = (v) => {
        const h = d.value ? "from-bottom" : "from-top", m = l(ja)[h].includes(v.key);
        t("stepKeyDown", v, m ? -1 : 1);
      }),
      onEndKeyDown: f[4] || (f[4] = (v) => t("endKeyDown", v)),
      onHomeKeyDown: f[5] || (f[5] = (v) => t("homeKeyDown", v))
    }, {
      default: y(() => [
        _(c.$slots, "default")
      ]),
      _: 3
    }, 8, ["style"]));
  }
}), $i = ["value", "default-value", "name", "disabled"], At = Symbol(), Oi = {
  inheritAttrs: !1
}, Ku = /* @__PURE__ */ w({
  ...Oi,
  __name: "SliderRoot",
  props: {
    name: {},
    defaultValue: { default: () => [0] },
    modelValue: {},
    disabled: { type: Boolean, default: !1 },
    orientation: { default: "horizontal" },
    dir: { default: "ltr" },
    inverted: { type: Boolean, default: !1 },
    min: { default: 0 },
    max: { default: 100 },
    step: { default: 1 },
    minStepsBetweenThumbs: { default: 0 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue", "valueCommit"],
  setup(n, { emit: t }) {
    const e = n, { min: o, max: a, step: s, minStepsBetweenThumbs: i, orientation: r, disabled: u, dir: d } = G(e), { createCollection: p } = le("sliderThumb"), { primitiveElement: c, currentElement: f } = H();
    p(f);
    const v = q(e, "modelValue", t, {
      defaultValue: e.defaultValue,
      passive: !0
    }), h = S(0), m = S(v.value);
    function b(B) {
      const I = hi(v.value, B);
      E(B, I);
    }
    function $(B) {
      E(B, h.value);
    }
    function O() {
      const B = m.value[h.value];
      v.value[h.value] !== B && t("valueCommit", v.value);
    }
    function E(B, I, { commit: x } = { commit: !1 }) {
      var U;
      const V = _i(s.value), A = wi(Math.round((B - o.value) / s.value) * s.value + o.value, V), R = Ga(A, [o.value, a.value]), F = vi(v.value, R, I);
      if (bi(F, i.value * s.value)) {
        h.value = F.indexOf(R);
        const z = String(F) !== String(v.value);
        z && x && t("valueCommit", F), z && ((U = P.value[h.value]) == null || U.focus(), v.value = F);
      }
    }
    const P = S([]);
    return W(At, {
      modelValue: v,
      valueIndexToChangeRef: h,
      thumbElements: P,
      orientation: r,
      min: o,
      max: a,
      disabled: u
    }), (B, I) => (g(), Q(re, null, [
      (g(), C(Fe(l(r) === "horizontal" ? Ci : Ei), k(B.$attrs, {
        ref_key: "primitiveElement",
        ref: c,
        "as-child": B.asChild,
        as: B.as,
        min: l(o),
        max: l(a),
        dir: l(d),
        inverted: B.inverted,
        "aria-disabled": l(u),
        "data-disabled": l(u),
        onPointerdown: I[0] || (I[0] = () => {
          l(u) || (m.value = l(v));
        }),
        onSlideStart: I[1] || (I[1] = (x) => !l(u) && b(x)),
        onSlideMove: I[2] || (I[2] = (x) => !l(u) && $(x)),
        onSlideEnd: I[3] || (I[3] = (x) => !l(u) && O),
        onHomeKeyDown: I[4] || (I[4] = (x) => !l(u) && E(l(o), 0, { commit: !0 })),
        onEndKeyDown: I[5] || (I[5] = (x) => !l(u) && E(l(a), l(v).length - 1, { commit: !0 })),
        onStepKeyDown: I[6] || (I[6] = (x, V) => {
          if (!l(u)) {
            const F = l(Ja).includes(x.key) || x.shiftKey && l(qa).includes(x.key) ? 10 : 1, U = h.value, z = l(v)[U], j = l(s) * F * V;
            E(z + j, U, { commit: !0 });
          }
        })
      }), {
        default: y(() => [
          _(B.$slots, "default", { modelValue: l(v) })
        ]),
        _: 3
      }, 16, ["as-child", "as", "min", "max", "dir", "inverted", "aria-disabled", "data-disabled"])),
      (g(!0), Q(re, null, Xn(l(v), (x, V) => (g(), Q("input", {
        key: V,
        value: x,
        style: { display: "none" },
        "default-value": x,
        name: B.name ? B.name + (l(v).length > 1 ? "[]" : "") : void 0,
        disabled: l(u)
      }, null, 8, $i))), 128))
    ], 64));
  }
}), Si = {
  inheritAttrs: !1
}, Pi = /* @__PURE__ */ w({
  ...Si,
  __name: "SliderThumbImpl",
  props: {
    index: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(n, { expose: t }) {
    const e = n, o = T(At), a = T(pn), { primitiveElement: s, currentElement: i } = H(), r = D(() => {
      var h, m;
      return (m = (h = o == null ? void 0 : o.modelValue) == null ? void 0 : h.value) == null ? void 0 : m[e.index];
    }), u = D(() => r.value === void 0 ? 0 : Xa(r.value, (o == null ? void 0 : o.min.value) ?? 0, (o == null ? void 0 : o.max.value) ?? 100)), d = D(() => {
      var h, m;
      return mi(e.index, ((m = (h = o == null ? void 0 : o.modelValue) == null ? void 0 : h.value) == null ? void 0 : m.length) ?? 0);
    }), p = _a(i), c = D(() => p[a.size].value), f = D(() => c.value ? yi(c.value, u.value, a.direction) : 0), v = on();
    return Y(() => {
      o == null || o.thumbElements.value.push(i.value);
    }), ue(() => {
      const h = (o == null ? void 0 : o.thumbElements.value.findIndex((m) => m === i.value)) ?? -1;
      o == null || o.thumbElements.value.splice(h, 1);
    }), t({
      $el: i
    }), (h, m) => {
      var b, $, O, E, P, B;
      return g(), C(l(M), k(h.$attrs, {
        ref_key: "primitiveElement",
        ref: s,
        role: "slider",
        "data-radix-vue-collection-item": "",
        tabindex: (b = l(o)) != null && b.disabled.value ? void 0 : 0,
        "aria-label": h.$attrs["aria-label"] || d.value,
        "data-disabled": ($ = l(o)) == null ? void 0 : $.disabled.value,
        "data-orientation": (O = l(o)) == null ? void 0 : O.orientation.value,
        "aria-valuenow": r.value,
        "aria-valuemin": (E = l(o)) == null ? void 0 : E.min.value,
        "aria-valuemax": (P = l(o)) == null ? void 0 : P.max.value,
        "aria-orientation": (B = l(o)) == null ? void 0 : B.orientation.value,
        "as-child": h.asChild,
        as: h.as,
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [l(a).startEdge]: `calc(${u.value}% + ${f.value}px)`,
          /**
           * There will be no value on initial render while we work out the index so we hide thumbs
           * without a value, otherwise SSR will render them in the wrong position before they
           * snap into the correct position during hydration which would be visually jarring for
           * slower connections.
           */
          display: !l(v) && r.value === void 0 ? "none" : void 0
        },
        onFocus: m[0] || (m[0] = () => {
          l(o).valueIndexToChangeRef.value = h.index;
        })
      }), {
        default: y(() => [
          _(h.$slots, "default")
        ]),
        _: 3
      }, 16, ["tabindex", "aria-label", "data-disabled", "data-orientation", "aria-valuenow", "aria-valuemin", "aria-valuemax", "aria-orientation", "as-child", "as", "style"]);
    };
  }
}), Hu = /* @__PURE__ */ w({
  __name: "SliderThumb",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, { injectCollection: e } = le("sliderThumb"), o = e(), { primitiveElement: a, currentElement: s } = H(), i = D(() => s.value ? o.value.findIndex((r) => r === s.value) : -1);
    return (r, u) => (g(), C(Pi, k({
      ref_key: "primitiveElement",
      ref: a
    }, t, { index: i.value }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["index"]));
  }
}), Wu = /* @__PURE__ */ w({
  __name: "SliderTrack",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(n) {
    const t = n, e = T(At);
    return (o, a) => {
      var s, i;
      return g(), C(l(M), {
        "as-child": t.asChild,
        as: o.as,
        "data-disabled": (s = l(e)) == null ? void 0 : s.disabled.value,
        "data-orientation": (i = l(e)) == null ? void 0 : i.orientation.value
      }, {
        default: y(() => [
          _(o.$slots, "default")
        ]),
        _: 3
      }, 8, ["as-child", "as", "data-disabled", "data-orientation"]);
    };
  }
}), Uu = /* @__PURE__ */ w({
  __name: "SliderRange",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(n) {
    const t = T(At), e = T(pn), o = D(() => {
      var i, r;
      return (r = (i = t == null ? void 0 : t.modelValue) == null ? void 0 : i.value) == null ? void 0 : r.map(
        (u) => Xa(u, t.min.value, t.max.value)
      );
    }), a = D(() => t.modelValue.value.length > 1 ? Math.min(...o.value) : 0), s = D(() => 100 - Math.max(...o.value));
    return (i, r) => {
      var u, d;
      return g(), C(l(M), {
        "data-disabled": (u = l(t)) == null ? void 0 : u.disabled.value,
        "data-orientation": (d = l(t)) == null ? void 0 : d.orientation.value,
        "as-child": i.asChild,
        as: i.as,
        style: ie({
          [l(e).startEdge]: `${a.value}%`,
          [l(e).endEdge]: `${s.value}%`
        })
      }, {
        default: y(() => [
          _(i.$slots, "default")
        ]),
        _: 3
      }, 8, ["data-disabled", "data-orientation", "as-child", "as", "style"]);
    };
  }
}), po = Symbol(), zu = /* @__PURE__ */ w({
  __name: "RadioGroupRoot",
  props: {
    modelValue: {},
    defaultValue: {},
    disabled: { type: Boolean, default: !1 },
    name: {},
    required: { type: Boolean, default: !1 },
    orientation: { default: void 0 },
    dir: { default: "ltr" },
    loop: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(n, { emit: t }) {
    const e = n, o = q(e, "modelValue", t, {
      defaultValue: e.defaultValue,
      passive: !0
    }), { disabled: a, loop: s, orientation: i, name: r, required: u } = G(e);
    return W(po, {
      modelValue: o,
      changeModelValue: (d) => {
        o.value = d;
      },
      disabled: a,
      loop: s,
      orientation: i,
      name: r == null ? void 0 : r.value,
      required: u
    }), (d, p) => (g(), C(l(vt), {
      "as-child": "",
      orientation: l(i),
      dir: d.dir,
      loop: l(s)
    }, {
      default: y(() => [
        L(l(M), {
          role: "radiogroup",
          "data-disabled": l(a) ? "" : void 0,
          "as-child": d.asChild,
          as: d.as,
          required: l(u),
          "aria-orientation": l(i),
          "aria-required": l(u),
          dir: d.dir,
          name: l(r)
        }, {
          default: y(() => [
            _(d.$slots, "default")
          ]),
          _: 3
        }, 8, ["data-disabled", "as-child", "as", "required", "aria-orientation", "aria-required", "dir", "name"])
      ]),
      _: 3
    }, 8, ["orientation", "dir", "loop"]));
  }
}), Ti = /* @__PURE__ */ w({
  __name: "Radio",
  props: {
    id: {},
    value: {},
    disabled: { type: Boolean, default: !1 },
    required: { type: Boolean },
    checked: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(n) {
    const t = n, { value: e, checked: o } = G(t), { primitiveElement: a, currentElement: s } = H(), i = T(po), r = D(
      () => s.value ? !!s.value.closest("form") : !0
    ), u = D(() => {
      var c;
      return t.id && s.value ? (c = document.querySelector(`[for="${t.id}"]`)) == null ? void 0 : c.innerText : void 0;
    }), d = S(!1);
    function p(c) {
      i == null || i.changeModelValue(e == null ? void 0 : e.value), r.value && "isPropagationStopped" in c && (d.value || c.stopPropagation());
    }
    return (c, f) => {
      var v;
      return g(), C(l(M), k(c.$attrs, {
        id: c.id,
        ref_key: "primitiveElement",
        ref: a,
        role: "radio",
        type: c.as === "button" ? "button" : void 0,
        as: c.as,
        "aria-checked": l(o),
        "aria-label": u.value,
        "as-child": c.asChild,
        disabled: c.disabled ? !0 : void 0,
        "data-state": l(o) ? "checked" : "unchecked",
        "data-disabled": c.disabled ? "" : void 0,
        value: l(e),
        required: c.required,
        name: (v = l(i)) == null ? void 0 : v.name,
        onClick: p
      }), {
        default: y(() => [
          _(c.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "type", "as", "aria-checked", "aria-label", "as-child", "disabled", "data-state", "data-disabled", "value", "required", "name"]);
    };
  }
}), Bi = ["default-value", "required", "checked", "disabled"], Qa = Symbol(), Ai = {
  inheritAttrs: !1
}, Yu = /* @__PURE__ */ w({
  ...Ai,
  __name: "RadioGroupItem",
  props: {
    id: {},
    value: {},
    disabled: { type: Boolean, default: !1 },
    required: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(n) {
    const t = n, { value: e } = G(t), { primitiveElement: o, currentElement: a } = H(), s = T(po), i = D(() => (s == null ? void 0 : s.disabled.value) || t.disabled), r = D(() => (s == null ? void 0 : s.required.value) || t.required), u = D(() => {
      var f;
      return ((f = s == null ? void 0 : s.modelValue) == null ? void 0 : f.value) === t.value;
    });
    W(Qa, { disabled: i, checked: u });
    const d = S(!1), p = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
    ot("keydown", (f) => {
      p.includes(f.key) && (d.value = !0);
    }), ot("keyup", () => {
      d.value = !1;
    });
    function c() {
      setTimeout(() => {
        var f;
        d.value && ((f = a.value) == null || f.click());
      }, 0);
    }
    return (f, v) => (g(), C(l(mt), {
      checked: u.value,
      disabled: i.value,
      "as-child": "",
      focusable: !i.value,
      active: u.value
    }, {
      default: y(() => [
        L(Ti, k({
          ref_key: "primitiveElement",
          ref: o
        }, { ...f.$attrs, ...t }, {
          checked: u.value,
          onKeydown: v[0] || (v[0] = pe(oe(() => {
          }, ["prevent"]), ["enter"])),
          onFocus: c
        }), {
          default: y(() => [
            _(f.$slots, "default")
          ]),
          _: 3
        }, 16, ["checked"]),
        tn(St("input", {
          "onUpdate:modelValue": v[1] || (v[1] = (h) => it(e) ? e.value = h : null),
          type: "radio",
          "aria-hidden": "true",
          tabindex: "-1",
          "default-value": u.value,
          required: r.value,
          checked: u.value,
          disabled: i.value,
          style: ie(
            {
              transform: "translateX(-100%)",
              position: "absolute",
              pointerEvents: "none",
              opacity: "0",
              margin: "0px",
              width: "25px",
              height: "25px"
            }
          )
        }, null, 12, Bi), [
          [Ms, l(e)]
        ])
      ]),
      _: 3
    }, 8, ["checked", "disabled", "focusable", "active"]));
  }
}), Gu = /* @__PURE__ */ w({
  __name: "RadioGroupIndicator",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(n) {
    const t = T(Qa);
    return (e, o) => {
      var a, s, i;
      return (a = l(t)) != null && a.checked.value ? (g(), C(l(M), {
        key: 0,
        "data-state": (s = l(t)) != null && s.checked.value ? "checked" : "unchecked",
        "data-disabled": (i = l(t)) != null && i.disabled.value ? "" : void 0,
        "as-child": e.asChild,
        as: e.as
      }, {
        default: y(() => [
          _(e.$slots, "default")
        ]),
        _: 3
      }, 8, ["data-state", "data-disabled", "as-child", "as"])) : J("", !0);
    };
  }
}), je = Symbol(), Xu = /* @__PURE__ */ w({
  __name: "PaginationRoot",
  props: {
    page: {},
    defaultPage: { default: 1 },
    itemsPerPage: { default: 10 },
    total: { default: 0 },
    siblingCount: { default: 2 },
    disabled: { type: Boolean },
    showEdges: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: { default: "nav" }
  },
  emits: ["update:page"],
  setup(n, { emit: t }) {
    const e = n, { siblingCount: o, disabled: a, showEdges: s } = G(e), i = q(e, "page", t, {
      defaultValue: e.defaultPage,
      passive: !e.page
    }), r = D(() => Math.ceil(e.total / e.itemsPerPage));
    return W(je, {
      page: i,
      onPageChange(u) {
        i.value = u;
      },
      pageCount: r,
      siblingCount: o,
      disabled: a,
      showEdges: s
    }), (u, d) => (g(), C(l(M), {
      as: u.as,
      "as-child": u.asChild
    }, {
      default: y(() => [
        _(u.$slots, "default", { page: l(i) })
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), Ju = /* @__PURE__ */ w({
  __name: "PaginationEllipsis",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(M), k({ "data-type": "ellipsis" }, t), {
      default: y(() => [
        _(e.$slots, "default", {}, () => [
          de("")
        ])
      ]),
      _: 3
    }, 16));
  }
}), qu = /* @__PURE__ */ w({
  __name: "PaginationFirst",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(n) {
    const t = n, e = T(je);
    return (o, a) => {
      var s, i, r;
      return g(), C(l(M), k(t, {
        "aria-label": "First Page",
        type: o.as === "button" ? "button" : void 0,
        disabled: ((s = l(e)) == null ? void 0 : s.page.value) === 1 || ((r = (i = l(e)) == null ? void 0 : i.disabled) == null ? void 0 : r.value),
        onClick: a[0] || (a[0] = (u) => {
          var d;
          return (d = l(e)) == null ? void 0 : d.onPageChange(1);
        })
      }), {
        default: y(() => [
          _(o.$slots, "default", {}, () => [
            de("First page")
          ])
        ]),
        _: 3
      }, 16, ["type", "disabled"]);
    };
  }
}), ju = /* @__PURE__ */ w({
  __name: "PaginationLast",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(n) {
    const t = n, e = T(je);
    return (o, a) => {
      var s, i, r, u;
      return g(), C(l(M), k(t, {
        "aria-label": "Last Page",
        type: o.as === "button" ? "button" : void 0,
        disabled: ((s = l(e)) == null ? void 0 : s.page.value) === ((i = l(e)) == null ? void 0 : i.pageCount.value) || ((u = (r = l(e)) == null ? void 0 : r.disabled) == null ? void 0 : u.value),
        onClick: a[0] || (a[0] = (d) => {
          var p;
          return (p = l(e)) == null ? void 0 : p.onPageChange(l(e).pageCount.value);
        })
      }), {
        default: y(() => [
          _(o.$slots, "default", {}, () => [
            de("Last page")
          ])
        ]),
        _: 3
      }, 16, ["type", "disabled"]);
    };
  }
});
function Ue(n, t) {
  const e = t - n + 1;
  return Array.from({ length: e }, (o, a) => a + n);
}
function Ii(n) {
  return n.map((t) => typeof t == "number" ? { type: "page", value: t } : { type: "ellipsis" });
}
const Ht = "ellipsis";
function Di(n, t, e, o) {
  const s = t, i = Math.max(n - e, 1), r = Math.min(n + e, s), u = i > 1 + 1, d = r < s - 1;
  if (o) {
    const c = Math.min(2 * e + 5, t) - 2;
    if (!u && d)
      return [...Ue(1, c), Ht, s];
    if (u && !d) {
      const v = Ue(s - c + 1, s);
      return [1, Ht, ...v];
    }
    if (u && d) {
      const v = Ue(i, r);
      return [1, Ht, ...v, Ht, s];
    }
    return Ue(1, s);
  } else {
    const p = e * 2 + 1;
    return n <= e + 1 ? Ue(1, p) : t - n <= e ? Ue(t - p + 1, s) : Ue(i, r);
  }
}
const Zu = /* @__PURE__ */ w({
  __name: "PaginationList",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, e = T(je), o = D(() => Ii(
      Di(
        e.page.value,
        e.pageCount.value,
        e.siblingCount.value,
        e.showEdges.value
      )
    ));
    return (a, s) => (g(), C(l(M), N(K(t)), {
      default: y(() => [
        _(a.$slots, "default", { items: o.value })
      ]),
      _: 3
    }, 16));
  }
}), Qu = /* @__PURE__ */ w({
  __name: "PaginationListItem",
  props: {
    value: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(n) {
    const t = n, e = T(je), o = D(() => (e == null ? void 0 : e.page.value) === t.value);
    return (a, s) => {
      var i, r;
      return g(), C(l(M), k(t, {
        "data-type": "page",
        "aria-label": `Page ${a.value}`,
        "aria-current": o.value ? "page" : void 0,
        "data-selected": o.value ? "true" : void 0,
        disabled: (r = (i = l(e)) == null ? void 0 : i.disabled) == null ? void 0 : r.value,
        type: a.as === "button" ? "button" : void 0,
        onClick: s[0] || (s[0] = (u) => {
          var d;
          return (d = l(e)) == null ? void 0 : d.onPageChange(a.value);
        })
      }), {
        default: y(() => [
          _(a.$slots, "default", {}, () => [
            de(st(a.value), 1)
          ])
        ]),
        _: 3
      }, 16, ["aria-label", "aria-current", "data-selected", "disabled", "type"]);
    };
  }
}), ed = /* @__PURE__ */ w({
  __name: "PaginationNext",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(n) {
    const t = n, e = T(je);
    return (o, a) => {
      var s, i, r, u;
      return g(), C(l(M), k(t, {
        "aria-label": "Next Page",
        type: o.as === "button" ? "button" : void 0,
        disabled: ((s = l(e)) == null ? void 0 : s.page.value) === ((i = l(e)) == null ? void 0 : i.pageCount.value) || ((u = (r = l(e)) == null ? void 0 : r.disabled) == null ? void 0 : u.value),
        onClick: a[0] || (a[0] = (d) => {
          var p;
          return (p = l(e)) == null ? void 0 : p.onPageChange(l(e).page.value + 1);
        })
      }), {
        default: y(() => [
          _(o.$slots, "default", {}, () => [
            de("Next page")
          ])
        ]),
        _: 3
      }, 16, ["type", "disabled"]);
    };
  }
}), td = /* @__PURE__ */ w({
  __name: "PaginationPrev",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(n) {
    const t = n, e = T(je);
    return (o, a) => {
      var s, i, r;
      return g(), C(l(M), k(t, {
        "aria-label": "Previous Page",
        type: o.as === "button" ? "button" : void 0,
        disabled: ((s = l(e)) == null ? void 0 : s.page.value) === 1 || ((r = (i = l(e)) == null ? void 0 : i.disabled) == null ? void 0 : r.value),
        onClick: a[0] || (a[0] = (u) => {
          var d;
          return (d = l(e)) == null ? void 0 : d.onPageChange(l(e).page.value - 1);
        })
      }), {
        default: y(() => [
          _(o.$slots, "default", {}, () => [
            de("Prev page")
          ])
        ]),
        _: 3
      }, 16, ["type", "disabled"]);
    };
  }
}), Et = 100, es = Symbol(), fo = (n) => typeof n == "number";
function xi(n, t) {
  return n === null || fo(n) && !Number.isNaN(n) && n <= t && n >= 0 ? n : (console.error(`Invalid prop \`value\` of value \`${n}\` supplied to \`ProgressRoot\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${Et} if no \`max\` prop is set)
  - \`null\` if the progress is indeterminate.

Defaulting to \`null\`.`), null);
}
function ki(n) {
  return fo(n) && !Number.isNaN(n) && n > 0 ? n : (console.error(
    `Invalid prop \`max\` of value \`${n}\` supplied to \`ProgressRoot\`. Only numbers greater than 0 are valid max values. Defaulting to \`${Et}\`.`
  ), Et);
}
const nd = /* @__PURE__ */ w({
  __name: "ProgressRoot",
  props: {
    modelValue: {},
    max: { default: Et },
    getValueLabel: { type: Function, default: (n, t) => `${Math.round(n / t * Et)}%` },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue", "update:max"],
  setup(n, { emit: t }) {
    const e = n, o = q(e, "modelValue", t, {
      passive: !0
    }), a = q(e, "max", t, {
      passive: !0
    });
    X(
      () => o.value,
      async (i) => {
        const r = xi(i, e.max);
        r !== i && (await Z(), o.value = r);
      },
      { immediate: !0 }
    ), X(
      () => e.max,
      (i) => {
        const r = ki(e.max);
        r !== i && (a.value = r);
      },
      { immediate: !0 }
    );
    const s = D(() => o.value ? o.value === a.value ? "complete" : "loading" : "indeterminate");
    return W(es, {
      modelValue: o,
      max: a,
      progressState: s
    }), (i, r) => (g(), C(l(M), {
      "as-child": e.asChild,
      as: i.as,
      "aria-valuemax": l(a),
      "aria-valuemin": 0,
      "aria-valuenow": fo(l(o)) ? l(o) : void 0,
      "aria-valuetext": i.getValueLabel(l(o), l(a)),
      "aria-label": i.getValueLabel(l(o), l(a)),
      role: "progressbar",
      "data-state": s.value,
      "data-value": l(o) ?? void 0,
      "data-max": l(a)
    }, {
      default: y(() => [
        _(i.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-label", "data-state", "data-value", "data-max"]));
  }
}), od = /* @__PURE__ */ w({
  __name: "ProgressIndicator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, e = T(es);
    return (o, a) => {
      var s, i, r, u;
      return g(), C(l(M), k(t, {
        "data-state": (s = l(e)) == null ? void 0 : s.progressState.value,
        "data-value": ((r = (i = l(e)) == null ? void 0 : i.modelValue) == null ? void 0 : r.value) ?? void 0,
        "data-max": (u = l(e)) == null ? void 0 : u.max.value
      }), {
        default: y(() => [
          _(o.$slots, "default")
        ]),
        _: 3
      }, 16, ["data-state", "data-value", "data-max"]);
    };
  }
}), $e = Symbol(), Mi = /* @__PURE__ */ w({
  __name: "DialogRoot",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean, default: !1 },
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(n, { emit: t }) {
    const e = n, o = q(e, "open", t, {
      defaultValue: e.defaultOpen,
      passive: !0
    }), a = S(), s = S(), { modal: i } = G(e);
    return W($e, {
      open: o,
      modal: i,
      openModal: () => {
        o.value = !0;
      },
      onOpenChange: (r) => {
        o.value = r;
      },
      onOpenToggle: () => {
        o.value = !o.value;
      },
      contentId: te(),
      titleId: te(),
      descriptionId: te(),
      triggerElement: a,
      contentElement: s
    }), (r, u) => _(r.$slots, "default");
  }
}), Ri = /* @__PURE__ */ w({
  __name: "DialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(n) {
    const t = n, e = T($e), { primitiveElement: o, currentElement: a } = H();
    return Y(() => {
      e.triggerElement = a;
    }), (s, i) => {
      var r, u, d, p;
      return g(), C(l(M), k({
        ref_key: "primitiveElement",
        ref: o
      }, t, {
        type: s.as === "button" ? "button" : void 0,
        "aria-haspopup": "dialog",
        "aria-expanded": ((r = l(e)) == null ? void 0 : r.open.value) || !1,
        "aria-controls": (u = l(e)) == null ? void 0 : u.contentId,
        "data-state": (d = l(e)) != null && d.open.value ? "open" : "closed",
        onClick: (p = l(e)) == null ? void 0 : p.onOpenToggle
      }), {
        default: y(() => [
          _(s.$slots, "default")
        ]),
        _: 3
      }, 16, ["type", "aria-expanded", "aria-controls", "data-state", "onClick"]);
    };
  }
}), ad = /* @__PURE__ */ w({
  __name: "DialogPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(Le), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Dn = "focusScope.autoFocusOnMount", xn = "focusScope.autoFocusOnUnmount", Qo = { bubbles: !1, cancelable: !0 };
function zt(n, { select: t = !1 } = {}) {
  const e = document.activeElement;
  for (const o of n)
    if (Me(o, { select: t }), document.activeElement !== e)
      return !0;
}
function Fi(n) {
  const t = vo(n), e = ea(t, n), o = ea(t.reverse(), n);
  return [e, o];
}
function vo(n) {
  const t = [], e = document.createTreeWalker(n, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (o) => {
      const a = o.tagName === "INPUT" && o.type === "hidden";
      return o.disabled || o.hidden || a ? NodeFilter.FILTER_SKIP : o.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; e.nextNode(); )
    t.push(e.currentNode);
  return t;
}
function ea(n, t) {
  for (const e of n)
    if (!Ni(e, { upTo: t }))
      return e;
}
function Ni(n, { upTo: t }) {
  if (getComputedStyle(n).visibility === "hidden")
    return !0;
  for (; n; ) {
    if (t !== void 0 && n === t)
      return !1;
    if (getComputedStyle(n).display === "none")
      return !0;
    n = n.parentElement;
  }
  return !1;
}
function Li(n) {
  return n instanceof HTMLInputElement && "select" in n;
}
function Me(n, { select: t = !1 } = {}) {
  if (n && n.focus) {
    const e = document.activeElement;
    n.focus({ preventScroll: !0 }), n !== e && Li(n) && t && n.select();
  }
}
const Vi = Jn(() => S([]));
function Ki() {
  const n = Vi();
  return {
    add(t) {
      const e = n.value[0];
      t !== e && (e == null || e.pause()), n.value = ta(n.value, t), n.value.unshift(t);
    },
    remove(t) {
      var e;
      n.value = ta(n.value, t), (e = n.value[0]) == null || e.resume();
    }
  };
}
function ta(n, t) {
  const e = [...n], o = e.indexOf(t);
  return o !== -1 && e.splice(o, 1), e;
}
function Hi(n) {
  return n.filter((t) => t.tagName !== "A");
}
const fn = /* @__PURE__ */ w({
  __name: "FocusScope",
  props: {
    loop: { type: Boolean, default: !1 },
    trapped: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["mountAutoFocus", "unmountAutoFocus"],
  setup(n, { emit: t }) {
    const e = n, { primitiveElement: o, currentElement: a } = H(), s = S(null), i = Ki(), r = pa({
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    });
    ee((d) => {
      if (!Ce)
        return;
      const p = a.value;
      if (!e.trapped)
        return;
      function c(m) {
        if (r.paused || !p)
          return;
        const b = m.target;
        p.contains(b) ? s.value = b : Me(s.value, { select: !0 });
      }
      function f(m) {
        if (r.paused || !p)
          return;
        const b = m.relatedTarget;
        b !== null && (p.contains(b) || Me(s.value, { select: !0 }));
      }
      function v(m) {
        if (document.activeElement === document.body)
          for (const $ of m)
            $.removedNodes.length > 0 && Me(p);
      }
      document.addEventListener("focusin", c), document.addEventListener("focusout", f);
      const h = new MutationObserver(v);
      p && h.observe(p, { childList: !0, subtree: !0 }), d(() => {
        document.removeEventListener("focusin", c), document.removeEventListener("focusout", f), h.disconnect();
      });
    }), ee(async (d) => {
      const p = a.value;
      if (await Z(), !p)
        return;
      i.add(r);
      const c = document.activeElement;
      if (!p.contains(c)) {
        const v = new CustomEvent(Dn, Qo);
        p.addEventListener(
          Dn,
          (h) => t("mountAutoFocus", h)
        ), p.dispatchEvent(v), v.defaultPrevented || (zt(Hi(vo(p)), {
          select: !0
        }), document.activeElement === c && Me(p));
      }
      d(() => {
        p.removeEventListener(
          Dn,
          (m) => t("mountAutoFocus", m)
        );
        const v = new CustomEvent(xn, Qo), h = (m) => {
          t("unmountAutoFocus", m);
        };
        p.addEventListener(xn, h), p.dispatchEvent(v), setTimeout(() => {
          v.defaultPrevented || Me(c ?? document.body, { select: !0 }), p.removeEventListener(xn, h), i.remove(r);
        }, 0);
      });
    });
    function u(d) {
      if (!e.loop && !e.trapped || r.paused)
        return;
      const p = d.key === "Tab" && !d.altKey && !d.ctrlKey && !d.metaKey, c = document.activeElement;
      if (p && c) {
        const f = d.currentTarget, [v, h] = Fi(f);
        v && h ? !d.shiftKey && c === h ? (d.preventDefault(), e.loop && Me(v, { select: !0 })) : d.shiftKey && c === v && (d.preventDefault(), e.loop && Me(h, { select: !0 })) : c === f && d.preventDefault();
      }
    }
    return (d, p) => (g(), C(l(M), {
      ref_key: "primitiveElement",
      ref: o,
      tabindex: "-1",
      "as-child": e.asChild,
      as: e.as,
      onKeydown: u
    }, {
      default: y(() => [
        _(d.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
}), Wi = "menu.itemSelect", Vn = ["Enter", " "], Ui = ["ArrowDown", "PageUp", "Home"], ts = ["ArrowUp", "PageDown", "End"], zi = [...Ui, ...ts], Yi = {
  ltr: [...Vn, "ArrowRight"],
  rtl: [...Vn, "ArrowLeft"]
}, Gi = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
function mo(n) {
  return n ? "open" : "closed";
}
function Qt(n) {
  return n === "indeterminate";
}
function ho(n) {
  return Qt(n) ? "indeterminate" : n ? "checked" : "unchecked";
}
function Kn(n) {
  const t = document.activeElement;
  for (const e of n)
    if (e === t || (e.focus(), document.activeElement !== t))
      return;
}
function Xi(n, t) {
  const { x: e, y: o } = n;
  let a = !1;
  for (let s = 0, i = t.length - 1; s < t.length; i = s++) {
    const r = t[s].x, u = t[s].y, d = t[i].x, p = t[i].y;
    u > o != p > o && e < (d - r) * (o - u) / (p - u) + r && (a = !a);
  }
  return a;
}
function Ji(n, t) {
  if (!t)
    return !1;
  const e = { x: n.clientX, y: n.clientY };
  return Xi(e, t);
}
function $t(n) {
  return n.pointerType === "mouse";
}
const ns = /* @__PURE__ */ w({
  __name: "DialogContentImpl",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(n, { emit: t }) {
    const e = n, o = T($e);
    return (a, s) => (g(), C(l(fn), {
      "as-child": "",
      loop: "",
      trapped: e.trapFocus,
      onMountAutoFocus: s[5] || (s[5] = (i) => t("openAutoFocus", i)),
      onUnmountAutoFocus: s[6] || (s[6] = (i) => t("closeAutoFocus", i))
    }, {
      default: y(() => [
        L(l(Ne), k(a.$attrs, {
          id: l(o).contentId,
          as: a.as,
          "as-child": a.asChild,
          "disable-outside-pointer-events": a.disableOutsidePointerEvents,
          role: "dialog",
          "aria-describedby": l(o).descriptionId,
          "aria-labelledby": l(o).titleId,
          "data-state": l(mo)(l(o).open.value),
          onDismiss: s[0] || (s[0] = (i) => {
            var r;
            return (r = l(o)) == null ? void 0 : r.onOpenChange(!1);
          }),
          onEscapeKeyDown: s[1] || (s[1] = (i) => t("escapeKeyDown", i)),
          onFocusOutside: s[2] || (s[2] = (i) => t("focusOutside", i)),
          onInteractOutside: s[3] || (s[3] = (i) => t("interactOutside", i)),
          onPointerDownOutside: s[4] || (s[4] = (i) => t("pointerDownOutside", i))
        }), {
          default: y(() => [
            _(a.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "as", "as-child", "disable-outside-pointer-events", "aria-describedby", "aria-labelledby", "data-state"])
      ]),
      _: 3
    }, 8, ["trapped"]));
  }
}), qi = /* @__PURE__ */ w({
  __name: "DialogContentModal",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(n, { emit: t }) {
    const e = n, o = T($e), a = ae(t), { primitiveElement: s, currentElement: i } = H();
    return Pt(i), (r, u) => {
      var d;
      return g(), C(ns, k({
        ref_key: "primitiveElement",
        ref: s
      }, { ...e, ...l(a) }, {
        "trap-focus": (d = l(o)) == null ? void 0 : d.open.value,
        "disable-outside-pointer-events": !0,
        onCloseAutoFocus: u[0] || (u[0] = (p) => {
          var c, f;
          t("closeAutoFocus", p), p.defaultPrevented || (p.preventDefault(), (f = (c = l(o)) == null ? void 0 : c.triggerElement.value) == null || f.focus());
        }),
        onPointerDownOutside: u[1] || (u[1] = (p) => {
          const c = p.detail.originalEvent, f = c.button === 0 && c.ctrlKey === !0;
          (c.button === 2 || f) && p.preventDefault();
        }),
        onFocusOutside: u[2] || (u[2] = (p) => {
          p.preventDefault();
        }),
        onOpenAutoFocus: u[3] || (u[3] = (p) => t("openAutoFocus", p))
      }), {
        default: y(() => [
          _(r.$slots, "default")
        ]),
        _: 3
      }, 16, ["trap-focus"]);
    };
  }
}), ji = /* @__PURE__ */ w({
  __name: "DialogContentNonModal",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(n, { emit: t }) {
    const e = n, o = ae(t), a = T($e), s = S(!1), i = S(!1);
    return (r, u) => (g(), C(ns, k({ ...e, ...l(o) }, {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: u[0] || (u[0] = (d) => {
        var p, c;
        t("closeAutoFocus", d), d.defaultPrevented || (s.value || (c = (p = l(a)) == null ? void 0 : p.triggerElement.value) == null || c.focus(), d.preventDefault()), s.value = !1, i.value = !1;
      }),
      onInteractOutside: u[1] || (u[1] = (d) => {
        var f, v;
        d.defaultPrevented || (s.value = !0, d.detail.originalEvent.type === "pointerdown" && (i.value = !0));
        const p = d.target;
        ((v = (f = l(a)) == null ? void 0 : f.triggerElement.value) == null ? void 0 : v.contains(p)) && d.preventDefault(), d.detail.originalEvent.type === "focusin" && i.value && d.preventDefault();
      })
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Zi = /* @__PURE__ */ w({
  __name: "DialogContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(n, { emit: t }) {
    const e = n, o = T($e), a = ae(t);
    return (s, i) => (g(), C(l(ce), {
      present: l(o).open.value
    }, {
      default: y(() => {
        var r;
        return [
          (r = l(o)) != null && r.modal.value ? (g(), C(qi, k({ key: 0 }, { ...e, ...l(a), ...s.$attrs }, {
            onOpenAutoFocus: i[0] || (i[0] = (u) => t("openAutoFocus", u))
          }), {
            default: y(() => [
              _(s.$slots, "default")
            ]),
            _: 3
          }, 16)) : (g(), C(ji, N(k({ key: 1 }, { ...e, ...l(a), ...s.$attrs })), {
            default: y(() => [
              _(s.$slots, "default")
            ]),
            _: 3
          }, 16))
        ];
      }),
      _: 3
    }, 8, ["present"]));
  }
}), Qi = /* @__PURE__ */ w({
  __name: "DialogOverlay",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = T($e), e = Tt();
    return X(
      () => t == null ? void 0 : t.open.value,
      (o) => e.value = o ?? !1
    ), (o, a) => (g(), C(l(ce), {
      present: o.forceMount || l(t).open.value
    }, {
      default: y(() => {
        var s;
        return [
          L(l(M), k(o.$attrs, {
            as: o.as,
            "as-child": o.asChild,
            "data-state": (s = l(t)) != null && s.open.value ? "open" : "closed",
            style: { "pointer-events": "auto" },
            "data-aria-hidden": "true",
            "aria-hidden": "true"
          }), {
            default: y(() => [
              _(o.$slots, "default")
            ]),
            _: 3
          }, 16, ["as", "as-child", "data-state"])
        ];
      }),
      _: 3
    }, 8, ["present"]));
  }
}), os = /* @__PURE__ */ w({
  __name: "DialogClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(n) {
    const t = n, e = T($e);
    return (o, a) => (g(), C(l(M), k(t, {
      type: o.as === "button" ? "button" : void 0,
      "aria-label": "Close",
      onClick: a[0] || (a[0] = (s) => {
        var i;
        return (i = l(e)) == null ? void 0 : i.onOpenChange(!1);
      })
    }), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["type"]));
  }
}), er = /* @__PURE__ */ w({
  __name: "DialogTitle",
  props: {
    asChild: { type: Boolean },
    as: { default: "h2" }
  },
  setup(n) {
    const t = n, e = T($e);
    return (o, a) => {
      var s;
      return g(), C(l(M), k(t, {
        id: (s = l(e)) == null ? void 0 : s.titleId
      }), {
        default: y(() => [
          _(o.$slots, "default")
        ]),
        _: 3
      }, 16, ["id"]);
    };
  }
}), tr = /* @__PURE__ */ w({
  __name: "DialogDescription",
  props: {
    asChild: { type: Boolean },
    as: { default: "p" }
  },
  setup(n) {
    const t = n, e = T($e);
    return (o, a) => {
      var s;
      return g(), C(l(M), k(t, {
        id: (s = l(e)) == null ? void 0 : s.descriptionId
      }), {
        default: y(() => [
          _(o.$slots, "default")
        ]),
        _: 3
      }, 16, ["id"]);
    };
  }
}), sd = /* @__PURE__ */ w({
  __name: "AlertDialogRoot",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean }
  },
  emits: ["update:open"],
  setup(n, { emit: t }) {
    const e = n, o = ae(t);
    return (a, s) => (g(), C(l(Mi), k({ ...e, ...l(o) }, { modal: !0 }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ld = /* @__PURE__ */ w({
  __name: "AlertDialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(Ri), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), id = /* @__PURE__ */ w({
  __name: "AlertDialogPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(Le), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), as = Symbol(), rd = /* @__PURE__ */ w({
  __name: "AlertDialogContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(n, { emit: t }) {
    const e = n, o = ae(t), a = S();
    return W(as, {
      onCancelElementChange: (s) => {
        a.value = s;
      }
    }), (s, i) => (g(), C(l(Zi), k({ ...e, ...l(o) }, {
      role: "alertdialog",
      onPointerDownOutside: i[0] || (i[0] = oe(() => {
      }, ["prevent"])),
      onInteractOutside: i[1] || (i[1] = oe(() => {
      }, ["prevent"])),
      onOpenAutoFocus: i[2] || (i[2] = () => {
        Z(() => {
          var r;
          (r = a.value) == null || r.focus({
            preventScroll: !0
          });
        });
      })
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ud = /* @__PURE__ */ w({
  __name: "AlertDialogOverlay",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(Qi), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), dd = /* @__PURE__ */ w({
  __name: "AlertDialogCancel",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, e = T(as), { primitiveElement: o, currentElement: a } = H();
    return Y(() => {
      e.onCancelElementChange(a.value);
    }), (s, i) => (g(), C(l(os), k(t, {
      ref_key: "primitiveElement",
      ref: o
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), cd = /* @__PURE__ */ w({
  __name: "AlertDialogTitle",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(er), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), pd = /* @__PURE__ */ w({
  __name: "AlertDialogDescription",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(tr), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), fd = /* @__PURE__ */ w({
  __name: "AlertDialogAction",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(os), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), It = Symbol(), vd = /* @__PURE__ */ w({
  __name: "ToastProvider",
  props: {
    label: { default: "Notification" },
    duration: { default: 5e3 },
    swipeDirection: { default: "right" },
    swipeThreshold: { default: 50 }
  },
  setup(n) {
    const t = n, { label: e, duration: o, swipeDirection: a, swipeThreshold: s } = G(t), i = S(), r = S(0), u = S(!1), d = S(!1);
    if (t.label && typeof t.label == "string" && !t.label.trim()) {
      const p = "Invalid prop `label` supplied to `ToastProvider`. Expected non-empty `string`.";
      throw new Error(p);
    }
    return W(It, {
      label: e,
      duration: o,
      swipeDirection: a,
      swipeThreshold: s,
      toastCount: r,
      viewport: i,
      onViewportChange(p) {
        i.value = p;
      },
      onToastAdd() {
        r.value++;
      },
      onToastRemove() {
        r.value--;
      },
      isFocusedToastEscapeKeyDownRef: u,
      isClosePausedRef: d
    }), (p, c) => _(p.$slots, "default");
  }
}), nr = "toast.swipeStart", or = "toast.swipeMove", ar = "toast.swipeCancel", sr = "toast.swipeEnd", lr = ["F8"], Hn = "toast.viewportPause", Wn = "toast.viewportResume";
function Wt(n, t, e) {
  const o = e.originalEvent.currentTarget, a = new CustomEvent(n, {
    bubbles: !1,
    cancelable: !0,
    detail: e
  });
  t && o.addEventListener(n, t, { once: !0 }), o.dispatchEvent(a);
}
function na(n, t, e = 0) {
  const o = Math.abs(n.x), a = Math.abs(n.y), s = o > a;
  return t === "left" || t === "right" ? s && o > e : !s && a > e;
}
function ir(n) {
  return n.nodeType === n.ELEMENT_NODE;
}
function ss(n) {
  const t = [];
  return Array.from(n.childNodes).forEach((o) => {
    if (o.nodeType === o.TEXT_NODE && o.textContent && t.push(o.textContent), ir(o)) {
      const a = o.ariaHidden || o.hidden || o.style.display === "none", s = o.dataset.radixToastAnnounceExclude === "";
      if (!a)
        if (s) {
          const i = o.dataset.radixToastAnnounceAlt;
          i && t.push(i);
        } else
          t.push(...ss(o));
    }
  }), t;
}
const rr = /* @__PURE__ */ w({
  __name: "ToastAnnounce",
  setup(n) {
    const t = T(It), e = zs(1e3), o = S(!1);
    return Js(() => {
      o.value = !0;
    }), (a, s) => l(e) || o.value ? (g(), C(l(ft), { key: 0 }, {
      default: y(() => {
        var i;
        return [
          de(st((i = l(t)) == null ? void 0 : i.label.value) + " ", 1),
          _(a.$slots, "default")
        ];
      }),
      _: 3
    })) : J("", !0);
  }
}), ls = Symbol(), ur = {
  inheritAttrs: !1
}, dr = /* @__PURE__ */ w({
  ...ur,
  __name: "ToastImpl",
  props: {
    type: {},
    open: { type: Boolean, default: !1 },
    duration: {},
    asChild: { type: Boolean },
    as: { default: "li" }
  },
  emits: ["close", "escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd"],
  setup(n, { emit: t }) {
    const e = n, o = ba(), { primitiveElement: a, currentElement: s } = H(), i = T(It), r = S(null), u = S(null), d = D(() => e.duration || i.duration.value), p = S(0), c = S(d.value), f = S(0);
    function v(b) {
      !b || b === Number.POSITIVE_INFINITY || (window.clearTimeout(f.value), p.value = (/* @__PURE__ */ new Date()).getTime(), f.value = window.setTimeout(h, b));
    }
    function h() {
      var $, O;
      (($ = s.value) == null ? void 0 : $.contains(document.activeElement)) && ((O = i.viewport.value) == null || O.focus()), t("close");
    }
    const m = D(() => s.value ? ss(s.value) : null);
    if (e.type && !["foreground", "background"].includes(e.type)) {
      const b = "Invalid prop `type` supplied to `Toast`. Expected `foreground | background`.";
      throw new Error(b);
    }
    return ee((b) => {
      const $ = i == null ? void 0 : i.viewport.value;
      if ($) {
        const O = () => {
          v(c.value), t("resume");
        }, E = () => {
          const P = (/* @__PURE__ */ new Date()).getTime() - p.value;
          c.value = c.value - P, window.clearTimeout(f.value), t("pause");
        };
        return $.addEventListener(Hn, E), $.addEventListener(Wn, O), () => {
          $.removeEventListener(Hn, E), $.removeEventListener(Wn, O);
        };
      }
    }), ee(() => {
      e.open && !(i != null && i.isClosePausedRef.value) && v(d.value);
    }), Zn("Escape", (b) => {
      t("escapeKeyDown", b), b.defaultPrevented || (i.isFocusedToastEscapeKeyDownRef.value = !0, h());
    }), Y(() => {
      i == null || i.onToastAdd();
    }), ue(() => {
      i == null || i.onToastRemove();
    }), W(ls, {
      onClose: h
    }), (b, $) => {
      var O;
      return g(), Q(re, null, [
        m.value ? (g(), C(rr, {
          key: 0,
          role: "status",
          "aria-live": b.type === "foreground" ? "assertive" : "polite",
          "aria-atomic": ""
        }, {
          default: y(() => [
            de(st(m.value), 1)
          ]),
          _: 1
        }, 8, ["aria-live"])) : J("", !0),
        (g(), C(lt, {
          to: (O = l(i)) == null ? void 0 : O.viewport.value
        }, [
          L(l(M), k({
            ref: (E) => {
              l(o)(E), a.value = E;
            },
            role: "status",
            "aria-live": "off",
            "aria-atomic": "",
            tabindex: "0",
            "data-radix-vue-collection-item": ""
          }, b.$attrs, {
            as: b.as,
            "as-child": b.asChild,
            "data-state": b.open ? "open" : "closed",
            "data-swipe-direction": l(i).swipeDirection.value,
            style: { userSelect: "none", touchAction: "none" },
            onPointerdown: $[0] || ($[0] = oe((E) => {
              r.value = { x: E.clientX, y: E.clientY };
            }, ["left"])),
            onPointermove: $[1] || ($[1] = (E) => {
              if (!r.value)
                return;
              const P = E.clientX - r.value.x, B = E.clientY - r.value.y, I = !!u.value, x = ["left", "right"].includes(l(i).swipeDirection.value), V = ["left", "up"].includes(l(i).swipeDirection.value) ? Math.min : Math.max, A = x ? V(0, P) : 0, R = x ? 0 : V(0, B), F = E.pointerType === "touch" ? 10 : 2, U = { x: A, y: R }, z = { originalEvent: E, delta: U };
              I ? (u.value = U, l(Wt)(l(or), (j) => t("swipeMove", j), z)) : l(na)(U, l(i).swipeDirection.value, F) ? (u.value = U, l(Wt)(l(nr), (j) => t("swipeStart", j), z), E.target.setPointerCapture(E.pointerId)) : (Math.abs(P) > F || Math.abs(B) > F) && (r.value = null);
            }),
            onPointerup: $[2] || ($[2] = (E) => {
              const P = u.value, B = E.target;
              if (B.hasPointerCapture(E.pointerId) && B.releasePointerCapture(E.pointerId), u.value = null, r.value = null, P) {
                const I = E.currentTarget, x = { originalEvent: E, delta: P };
                l(na)(P, l(i).swipeDirection.value, l(i).swipeThreshold.value) ? l(Wt)(l(sr), (V) => t("swipeEnd", V), x) : l(Wt)(l(ar), (V) => t("swipeCancel", V), x), I == null || I.addEventListener("click", (V) => V.preventDefault(), {
                  once: !0
                });
              }
            })
          }), {
            default: y(() => [
              _(b.$slots, "default")
            ]),
            _: 3
          }, 16, ["as", "as-child", "data-state", "data-swipe-direction"])
        ], 8, ["to"]))
      ], 64);
    };
  }
}), md = /* @__PURE__ */ w({
  __name: "ToastRoot",
  props: {
    defaultOpen: { type: Boolean },
    forceMount: { type: Boolean },
    type: { default: "foreground" },
    open: { type: Boolean, default: !0 },
    duration: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["close", "escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd", "update:open"],
  setup(n, { emit: t }) {
    const e = n, o = q(e, "open", t, {
      defaultValue: e.defaultOpen,
      passive: !e.open
    });
    return (a, s) => (g(), C(l(ce), {
      present: a.forceMount || l(o)
    }, {
      default: y(() => [
        L(dr, k({
          open: l(o),
          type: a.type,
          duration: a.duration
        }, a.$attrs, {
          onClose: s[0] || (s[0] = (i) => o.value = !1),
          onPause: s[1] || (s[1] = (i) => t("pause")),
          onResume: s[2] || (s[2] = (i) => t("resume")),
          onEscapeKeyDown: s[3] || (s[3] = (i) => t("escapeKeyDown", i)),
          onSwipeStart: s[4] || (s[4] = (i) => {
            t("swipeStart", i), i.currentTarget.setAttribute("data-swipe", "start");
          }),
          onSwipeMove: s[5] || (s[5] = (i) => {
            const { x: r, y: u } = i.detail.delta, d = i.currentTarget;
            d.setAttribute("data-swipe", "move"), d.style.setProperty("--radix-toast-swipe-move-x", `${r}px`), d.style.setProperty("--radix-toast-swipe-move-y", `${u}px`);
          }),
          onSwipeCancel: s[6] || (s[6] = (i) => {
            const r = i.currentTarget;
            r.setAttribute("data-swipe", "cancel"), r.style.removeProperty("--radix-toast-swipe-move-x"), r.style.removeProperty("--radix-toast-swipe-move-y"), r.style.removeProperty("--radix-toast-swipe-end-x"), r.style.removeProperty("--radix-toast-swipe-end-y");
          }),
          onSwipeEnd: s[7] || (s[7] = (i) => {
            const { x: r, y: u } = i.detail.delta, d = i.currentTarget;
            d.setAttribute("data-swipe", "end"), d.style.removeProperty("--radix-toast-swipe-move-x"), d.style.removeProperty("--radix-toast-swipe-move-y"), d.style.setProperty("--radix-toast-swipe-end-x", `${r}px`), d.style.setProperty("--radix-toast-swipe-end-y", `${u}px`), o.value = !1;
          })
        }), {
          default: y(() => [
            _(a.$slots, "default")
          ]),
          _: 3
        }, 16, ["open", "type", "duration"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), is = /* @__PURE__ */ w({
  __name: "ToastAnnounceExclude",
  props: {
    altText: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    return (t, e) => (g(), C(l(M), {
      as: t.as,
      "as-child": t.asChild,
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": t.altText || void 0
    }, {
      default: y(() => [
        _(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-radix-toast-announce-alt"]));
  }
}), cr = /* @__PURE__ */ w({
  __name: "ToastClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(n) {
    const t = n, e = T(ls);
    return (o, a) => (g(), C(is, { "as-child": "" }, {
      default: y(() => [
        L(l(M), k(t, {
          type: o.as === "button" ? "button" : void 0,
          onClick: a[0] || (a[0] = (s) => {
            var i;
            return (i = l(e)) == null ? void 0 : i.onClose();
          })
        }), {
          default: y(() => [
            _(o.$slots, "default")
          ]),
          _: 3
        }, 16, ["type"])
      ]),
      _: 3
    }));
  }
}), hd = /* @__PURE__ */ w({
  __name: "ToastAction",
  props: {
    altText: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    if (!n.altText)
      throw new Error("Missing prop `altText` expected on `ToastAction`");
    return (e, o) => e.altText ? (g(), C(is, {
      key: 0,
      "alt-text": e.altText,
      "as-chld": ""
    }, {
      default: y(() => [
        L(cr, {
          as: e.as,
          "as-child": e.asChild
        }, {
          default: y(() => [
            _(e.$slots, "default")
          ]),
          _: 3
        }, 8, ["as", "as-child"])
      ]),
      _: 3
    }, 8, ["alt-text"])) : J("", !0);
  }
}), oa = /* @__PURE__ */ w({
  __name: "FocusProxy",
  emits: ["focusFromOutsideViewport"],
  setup(n, { emit: t }) {
    const e = T(It);
    return (o, a) => (g(), C(l(ft), {
      "aria-hidden": "",
      tabindex: "0",
      style: { position: "'fixed'" },
      onFocus: a[0] || (a[0] = (s) => {
        var u;
        const i = s.relatedTarget;
        !((u = l(e).viewport.value) != null && u.contains(i)) && t("focusFromOutsideViewport");
      })
    }, {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }));
  }
}), pr = {
  inheritAttrs: !1
}, yd = /* @__PURE__ */ w({
  ...pr,
  __name: "ToastViewport",
  props: {
    hotkey: { default: () => lr },
    label: { default: "Notifications ({hotkey})" },
    asChild: { type: Boolean },
    as: { default: "ol" }
  },
  setup(n) {
    const t = n, { hotkey: e, label: o } = G(t), { primitiveElement: a, currentElement: s } = H(), { createCollection: i } = le(), r = i(s), u = T(It), d = D(() => u.toastCount.value > 0), p = S(), c = S();
    Zn(e.value, () => {
      s.value.focus();
    }), Y(() => {
      u == null || u.onViewportChange(s.value);
    }), ee((v) => {
      const h = s.value;
      if (d.value && h && u) {
        const m = () => {
          if (!u.isClosePausedRef.value) {
            const P = new CustomEvent(Hn);
            h.dispatchEvent(P), u.isClosePausedRef.value = !0;
          }
        }, b = () => {
          if (u.isClosePausedRef.value) {
            const P = new CustomEvent(Wn);
            h.dispatchEvent(P), u.isClosePausedRef.value = !1;
          }
        }, $ = (P) => {
          !h.contains(P.relatedTarget) && b();
        }, O = () => {
          h.contains(document.activeElement) || b();
        }, E = (P) => {
          var x, V, A;
          const B = P.altKey || P.ctrlKey || P.metaKey;
          if (P.key === "Tab" && !B) {
            const R = document.activeElement, F = P.shiftKey;
            if (P.target === h && F) {
              (x = p.value) == null || x.focus();
              return;
            }
            const j = f({ tabbingDirection: F ? "backwards" : "forwards" }), ne = j.findIndex((se) => se === R);
            zt(j.slice(ne + 1)) ? P.preventDefault() : F ? (V = p.value) == null || V.focus() : (A = c.value) == null || A.focus();
          }
        };
        h.addEventListener("focusin", m), h.addEventListener("focusout", $), h.addEventListener("pointermove", m), h.addEventListener("pointerleave", O), h.addEventListener("keydown", E), window.addEventListener("blur", m), window.addEventListener("focus", b), v(() => {
          h.removeEventListener("focusin", m), h.removeEventListener("focusout", $), h.removeEventListener("pointermove", m), h.removeEventListener("pointerleave", O), h.removeEventListener("keydown", E), window.removeEventListener("blur", m), window.removeEventListener("focus", b);
        });
      }
    });
    function f({ tabbingDirection: v }) {
      const m = r.value.map((b) => {
        const $ = [b, ...vo(b)];
        return v === "forwards" ? $ : $.reverse();
      });
      return (v === "forwards" ? m.reverse() : m).flat();
    }
    return (v, h) => (g(), C(l(ti), {
      role: "region",
      "aria-label": l(o).replace("{hotkey}", l(e).join("+").replace(/Key/g, "").replace(/Digit/g, "")),
      tabindex: "-1",
      style: ie({
        // incase list has size when empty (e.g. padding), we remove pointer events so
        // it doesn't prevent interactions with page elements that it overlays
        pointerEvents: d.value ? void 0 : "none"
      })
    }, {
      default: y(() => [
        d.value ? (g(), C(oa, {
          key: 0,
          ref: (m) => {
            p.value = l(ye)(m);
          },
          onFocusFromOutsideViewport: h[0] || (h[0] = () => {
            const m = f({
              tabbingDirection: "forwards"
            });
            l(zt)(m);
          })
        }, null, 512)) : J("", !0),
        L(l(M), k({
          ref_key: "primitiveElement",
          ref: a,
          tabindex: "-1",
          as: v.as,
          "as-child": v.asChild
        }, v.$attrs), {
          default: y(() => [
            _(v.$slots, "default")
          ]),
          _: 3
        }, 16, ["as", "as-child"]),
        d.value ? (g(), C(oa, {
          key: 1,
          ref: (m) => {
            c.value = l(ye)(m);
          },
          onFocusFromOutsideViewport: h[1] || (h[1] = () => {
            const m = f({
              tabbingDirection: "backwards"
            });
            l(zt)(m);
          })
        }, null, 512)) : J("", !0)
      ]),
      _: 3
    }, 8, ["aria-label", "style"]));
  }
}), gd = /* @__PURE__ */ w({
  __name: "ToastTitle",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(M), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), bd = /* @__PURE__ */ w({
  __name: "ToastDescription",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(M), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), yo = Symbol(), _d = /* @__PURE__ */ w({
  __name: "ToolbarRoot",
  props: {
    orientation: { default: "horizontal" },
    dir: { default: "ltr" },
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, { orientation: e, dir: o } = G(t);
    return W(yo, { orientation: e, dir: o }), (a, s) => (g(), C(l(vt), {
      "as-child": "",
      orientation: l(e),
      dir: l(o),
      loop: a.loop
    }, {
      default: y(() => [
        L(l(M), {
          role: "toolbar",
          "aria-orientation": l(e),
          "as-child": a.asChild,
          as: a.as
        }, {
          default: y(() => [
            _(a.$slots, "default")
          ]),
          _: 3
        }, 8, ["aria-orientation", "as-child", "as"])
      ]),
      _: 3
    }, 8, ["orientation", "dir", "loop"]));
  }
}), fr = /* @__PURE__ */ w({
  __name: "ToolbarButton",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(mt), {
      "as-child": "",
      focusable: !e.disabled
    }, {
      default: y(() => [
        L(l(M), k({
          type: e.as === "button" ? "button" : void 0
        }, t), {
          default: y(() => [
            _(e.$slots, "default")
          ]),
          _: 3
        }, 16, ["type"])
      ]),
      _: 3
    }, 8, ["focusable"]));
  }
}), wd = /* @__PURE__ */ w({
  __name: "ToolbarLink",
  props: {
    asChild: { type: Boolean },
    as: { default: "a" }
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(mt), {
      "as-child": "",
      focusable: ""
    }, {
      default: y(() => [
        L(l(M), k(t, {
          onKeydown: o[0] || (o[0] = (a) => {
            var s;
            a.key === " " && ((s = a.currentTarget) == null || s.click());
          })
        }), {
          default: y(() => [
            _(e.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }));
  }
}), Cd = /* @__PURE__ */ w({
  __name: "ToolbarToggleGroup",
  props: {
    type: {},
    defaultValue: {},
    modelValue: {},
    rovingFocus: { type: Boolean },
    disabled: { type: Boolean },
    orientation: {},
    dir: {},
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(n, { emit: t }) {
    const e = n, o = T(yo), a = ae(t);
    return (s, i) => {
      var r, u;
      return g(), C(l(ci), k({ ...e, ...l(a) }, {
        "data-orientation": (r = l(o)) == null ? void 0 : r.orientation.value,
        dir: (u = l(o)) == null ? void 0 : u.dir.value,
        "roving-focus": !1
      }), {
        default: y(() => [
          _(s.$slots, "default")
        ]),
        _: 3
      }, 16, ["data-orientation", "dir"]);
    };
  }
}), Ed = /* @__PURE__ */ w({
  __name: "ToolbarToggleItem",
  props: {
    value: {},
    defaultValue: { type: Boolean },
    pressed: { type: Boolean },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(fr, { "as-child": "" }, {
      default: y(() => [
        L(l(pi), N(K(t)), {
          default: y(() => [
            _(e.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }));
  }
}), $d = /* @__PURE__ */ w({
  __name: "ToolbarSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, e = T(yo);
    return (o, a) => {
      var s;
      return g(), C(Ka, {
        orientation: (s = l(e)) == null ? void 0 : s.orientation.value,
        "as-child": t.asChild,
        as: o.as
      }, {
        default: y(() => [
          _(o.$slots, "default")
        ]),
        _: 3
      }, 8, ["orientation", "as-child", "as"]);
    };
  }
}), go = Symbol(), Od = /* @__PURE__ */ w({
  __name: "AvatarRoot",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(n) {
    const t = n, e = S("loading");
    return W(go, {
      imageLoadingStatus: e
    }), (o, a) => (g(), C(l(M), {
      as: o.as,
      "as-child": t.asChild
    }, {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
});
function vr(n) {
  const t = S("idle"), e = S(!1), o = (a) => () => {
    e.value && (t.value = a);
  };
  return Y(() => {
    e.value = !0, X(n, (a) => {
      if (!a)
        t.value = "error";
      else {
        const s = new window.Image();
        t.value = "loading", s.onload = o("loaded"), s.onerror = o("error"), s.src = a;
      }
    }, { immediate: !0 });
  }), ue(() => {
    e.value = !1;
  }), t;
}
const Sd = /* @__PURE__ */ w({
  __name: "AvatarImage",
  props: {
    src: {},
    asChild: { type: Boolean },
    as: { default: "img" }
  },
  emits: ["loadingStatusChange"],
  setup(n, { emit: t }) {
    const e = n, { src: o } = G(e), a = T(go), s = vr(o);
    return X(
      s,
      (i) => {
        t("loadingStatusChange", i), i !== "idle" && (a.imageLoadingStatus.value = i);
      },
      { immediate: !0 }
    ), (i, r) => l(s) === "loaded" ? (g(), C(l(M), {
      key: 0,
      role: "img",
      "as-child": i.asChild,
      as: i.as,
      src: l(o)
    }, {
      default: y(() => [
        _(i.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "src"])) : J("", !0);
  }
}), Pd = /* @__PURE__ */ w({
  __name: "AvatarFallback",
  props: {
    delayMs: { default: 0 },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(n) {
    const t = n, e = T(go), o = S(!1);
    let a;
    return X(() => e == null ? void 0 : e.imageLoadingStatus.value, (s) => {
      s === "loading" && (o.value = !1, t.delayMs ? a = setTimeout(() => {
        o.value = !0, clearTimeout(a);
      }, t.delayMs) : o.value = !0);
    }, { immediate: !0 }), (s, i) => {
      var r;
      return o.value && ((r = l(e)) == null ? void 0 : r.imageLoadingStatus.value) !== "loaded" ? (g(), C(l(M), {
        key: 0,
        "as-child": t.asChild,
        as: s.as
      }, {
        default: y(() => [
          _(s.$slots, "default")
        ]),
        _: 3
      }, 8, ["as-child", "as"])) : J("", !0);
    };
  }
}), rs = "tooltip.open";
function mr(n, t) {
  const e = Math.abs(t.top - n.y), o = Math.abs(t.bottom - n.y), a = Math.abs(t.right - n.x), s = Math.abs(t.left - n.x);
  switch (Math.min(e, o, a, s)) {
    case s:
      return "left";
    case a:
      return "right";
    case e:
      return "top";
    case o:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function hr(n, t, e = 5) {
  const o = [];
  switch (t) {
    case "top":
      o.push(
        { x: n.x - e, y: n.y + e },
        { x: n.x + e, y: n.y + e }
      );
      break;
    case "bottom":
      o.push(
        { x: n.x - e, y: n.y - e },
        { x: n.x + e, y: n.y - e }
      );
      break;
    case "left":
      o.push(
        { x: n.x + e, y: n.y - e },
        { x: n.x + e, y: n.y + e }
      );
      break;
    case "right":
      o.push(
        { x: n.x - e, y: n.y - e },
        { x: n.x - e, y: n.y + e }
      );
      break;
  }
  return o;
}
function yr(n) {
  const { top: t, right: e, bottom: o, left: a } = n;
  return [
    { x: a, y: t },
    { x: e, y: t },
    { x: e, y: o },
    { x: a, y: o }
  ];
}
function gr(n, t) {
  const { x: e, y: o } = n;
  let a = !1;
  for (let s = 0, i = t.length - 1; s < t.length; i = s++) {
    const r = t[s].x, u = t[s].y, d = t[i].x, p = t[i].y;
    u > o != p > o && e < (d - r) * (o - u) / (p - u) + r && (a = !a);
  }
  return a;
}
function br(n) {
  const t = n.slice();
  return t.sort((e, o) => e.x < o.x ? -1 : e.x > o.x ? 1 : e.y < o.y ? -1 : e.y > o.y ? 1 : 0), _r(t);
}
function _r(n) {
  if (n.length <= 1)
    return n.slice();
  const t = [];
  for (let o = 0; o < n.length; o++) {
    const a = n[o];
    for (; t.length >= 2; ) {
      const s = t[t.length - 1], i = t[t.length - 2];
      if ((s.x - i.x) * (a.y - i.y) >= (s.y - i.y) * (a.x - i.x))
        t.pop();
      else
        break;
    }
    t.push(a);
  }
  t.pop();
  const e = [];
  for (let o = n.length - 1; o >= 0; o--) {
    const a = n[o];
    for (; e.length >= 2; ) {
      const s = e[e.length - 1], i = e[e.length - 2];
      if ((s.x - i.x) * (a.y - i.y) >= (s.y - i.y) * (a.x - i.x))
        e.pop();
      else
        break;
    }
    e.push(a);
  }
  return e.pop(), t.length === 1 && e.length === 1 && t[0].x === e[0].x && t[0].y === e[0].y ? t : t.concat(e);
}
const [bo, wr] = Ca("TooltipProvider"), Td = /* @__PURE__ */ w({
  __name: "TooltipProvider",
  props: {
    delayDuration: { default: 700 },
    skipDelayDuration: { default: 300 },
    disableHoverableContent: { type: Boolean, default: !1 }
  },
  setup(n) {
    const t = n, { delayDuration: e, skipDelayDuration: o, disableHoverableContent: a } = G(t), s = S(!0), i = S(!1), { start: r, stop: u } = jn(() => {
      s.value = !0;
    }, o, { immediate: !1 });
    return wr({
      isOpenDelayed: s,
      delayDuration: e,
      onOpen() {
        u(), s.value = !1;
      },
      onClose() {
        r();
      },
      isPointerInTransitRef: i,
      onPointerInTransitChange(d) {
        i.value = d;
      },
      disableHoverableContent: a
    }), (d, p) => _(d.$slots, "default");
  }
}), [vn, Cr] = Ca("TooltipRoot"), Bd = /* @__PURE__ */ w({
  __name: "TooltipRoot",
  props: {
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    delayDuration: { default: void 0 },
    disableHoverableContent: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(n, { emit: t }) {
    const e = n, o = bo(), a = D(() => e.disableHoverableContent ?? o.disableHoverableContent.value), s = D(() => e.delayDuration ?? o.delayDuration.value), i = q(e, "open", t, {
      defaultValue: e.defaultOpen,
      passive: !0
    });
    X(i, (m) => {
      o.onClose && (m ? (o.onOpen(), document.dispatchEvent(new CustomEvent(rs))) : o.onClose());
    });
    const r = S(!1), u = S(), d = D(() => i.value ? r.value ? "delayed-open" : "instant-open" : "closed"), { start: p, stop: c } = jn(() => {
      r.value = !0, i.value = !0;
    }, s, { immediate: !1 });
    function f() {
      c(), r.value = !1, i.value = !0;
    }
    function v() {
      c(), i.value = !1;
    }
    function h() {
      p();
    }
    return Cr({
      contentId: te(),
      open: i,
      stateAttribute: d,
      trigger: u,
      onTriggerChange(m) {
        u.value = m;
      },
      onTriggerEnter() {
        o.isOpenDelayed.value ? h() : f();
      },
      onTriggerLeave() {
        a.value ? v() : c();
      },
      onOpen: f,
      onClose: v,
      disableHoverableContent: a
    }), (m, b) => (g(), C(l(Je), null, {
      default: y(() => [
        _(m.$slots, "default")
      ]),
      _: 3
    }));
  }
}), Ad = /* @__PURE__ */ w({
  __name: "TooltipTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(n) {
    const t = n, e = vn(), o = bo(), { primitiveElement: a, currentElement: s } = H(), i = S(!1), r = S(!1);
    function u() {
      i.value = !1;
    }
    function d() {
      i.value = !0, document.addEventListener("pointerup", u, { once: !0 });
    }
    return Y(() => {
      e.onTriggerChange(s.value);
    }), (p, c) => (g(), C(l(qe), { "as-child": "" }, {
      default: y(() => [
        L(l(M), {
          ref_key: "primitiveElement",
          ref: a,
          "aria-describedby": l(e).open.value ? l(e).contentId : void 0,
          "data-state": l(e).stateAttribute.value,
          as: p.as,
          "as-child": t.asChild,
          onPointermove: c[0] || (c[0] = (f) => {
            f.pointerType !== "touch" && !r.value && !l(o).isPointerInTransitRef.value && (l(e).onTriggerEnter(), r.value = !0);
          }),
          onPointerleave: c[1] || (c[1] = (f) => {
            l(e).onTriggerLeave(), r.value = !1;
          }),
          onPointerdown: d,
          onFocus: c[2] || (c[2] = () => {
            i.value || l(e).onOpen();
          }),
          onBlur: c[3] || (c[3] = (f) => l(e).onClose()),
          onClick: c[4] || (c[4] = (f) => l(e).onClose())
        }, {
          default: y(() => [
            _(p.$slots, "default")
          ]),
          _: 3
        }, 8, ["aria-describedby", "data-state", "as", "as-child"])
      ]),
      _: 3
    }));
  }
}), us = /* @__PURE__ */ w({
  __name: "TooltipContentImpl",
  props: {
    ariaLabel: {},
    asChild: { type: Boolean, default: !1 },
    as: {},
    side: { default: "top" },
    sideOffset: { default: 0 },
    align: { default: "center" },
    alignOffset: {},
    avoidCollisions: { type: Boolean, default: !0 },
    collisionBoundary: { default: () => [] },
    collisionPadding: { default: 0 },
    arrowPadding: { default: 0 },
    sticky: { default: "partial" },
    hideWhenDetached: { type: Boolean, default: !1 }
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(n, { emit: t }) {
    const e = n, o = S(), a = vn(), s = D(() => {
      var p, c;
      if (e.ariaLabel)
        return e.ariaLabel;
      const r = (c = (p = Gn()).default) == null ? void 0 : c.call(p);
      let u = "";
      function d(f) {
        typeof f.children == "string" ? u += f.children : Array.isArray(f.children) && f.children.forEach((v) => d(v));
      }
      return r == null || r.forEach((f) => d(f)), u;
    }), i = D(() => {
      const { ariaLabel: r, ...u } = e;
      return u;
    });
    return Y(() => {
      ot(window, "scroll", (r) => {
        const u = r.target;
        u != null && u.contains(a.trigger.value) && a.onClose();
      }), ot(window, rs, a.onClose);
    }), (r, u) => (g(), C(l(Ne), {
      "as-child": "",
      "disable-outside-pointer-events": !1,
      onEscapeKeyDown: u[0] || (u[0] = (d) => t("escapeKeyDown", d)),
      onPointerDownOutside: u[1] || (u[1] = (d) => t("pointerDownOutside", d)),
      onFocusOutside: u[2] || (u[2] = oe(() => {
      }, ["prevent"])),
      onDismiss: u[3] || (u[3] = (d) => l(a).onClose())
    }, {
      default: y(() => [
        L(l(ct), k({
          ref_key: "contentElement",
          ref: o,
          "data-state": l(a).stateAttribute.value
        }, { ...r.$attrs, ...i.value }, { style: {
          "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
          "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
          "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
        } }), {
          default: y(() => [
            _(r.$slots, "default"),
            L(l(ft), {
              id: l(a).contentId,
              role: "tooltip"
            }, {
              default: y(() => [
                de(st(s.value), 1)
              ]),
              _: 1
            }, 8, ["id"])
          ]),
          _: 3
        }, 16, ["data-state", "style"])
      ]),
      _: 3
    }));
  }
}), Er = /* @__PURE__ */ w({
  __name: "TooltipContentHoverable",
  props: {
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean }
  },
  setup(n) {
    const t = n, { primitiveElement: e, currentElement: o } = H(), { trigger: a, onClose: s } = vn(), i = bo(), r = S(null);
    function u() {
      r.value = null, i.onPointerInTransitChange(!1);
    }
    function d(p, c) {
      const f = p.currentTarget, v = { x: p.clientX, y: p.clientY }, h = mr(v, f.getBoundingClientRect()), m = hr(v, h), b = yr(c.getBoundingClientRect()), $ = br([...m, ...b]);
      r.value = $, i.onPointerInTransitChange(!0);
    }
    return ee((p) => {
      if (a.value && o.value) {
        const c = (v) => d(v, o.value), f = (v) => d(v, a.value);
        a.value.addEventListener("pointerleave", c), o.value.addEventListener("pointerleave", f), p(() => {
          var v, h;
          (v = a.value) == null || v.removeEventListener("pointerleave", c), (h = o.value) == null || h.removeEventListener("pointerleave", f);
        });
      }
    }), ee((p) => {
      if (r.value) {
        const c = (f) => {
          var $, O;
          if (!r.value)
            return;
          const v = f.target, h = { x: f.clientX, y: f.clientY }, m = (($ = a.value) == null ? void 0 : $.contains(v)) || ((O = o.value) == null ? void 0 : O.contains(v)), b = !gr(h, r.value);
          m ? u() : b && (u(), s());
        };
        document.addEventListener("pointermove", c), p(() => document.removeEventListener("pointermove", c));
      }
    }), (p, c) => (g(), C(us, k({
      ref_key: "primitiveElement",
      ref: e
    }, t), {
      default: y(() => [
        _(p.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Id = /* @__PURE__ */ w({
  __name: "TooltipContent",
  props: {
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: { default: "top" },
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(n, { emit: t }) {
    const e = n, o = vn(), a = fe(e, t);
    return (s, i) => l(o).open.value ? (g(), C(Fe(l(o).disableHoverableContent.value ? us : Er), N(k({ key: 0 }, l(a))), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16)) : J("", !0);
  }
}), Dd = /* @__PURE__ */ w({
  __name: "TooltipArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(pt), N(K(t)), null, 16));
  }
}), xd = /* @__PURE__ */ w({
  __name: "TooltipPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(Le), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), mn = Symbol(), kd = /* @__PURE__ */ w({
  __name: "HoverCardRoot",
  props: {
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    openDelay: { default: 700 },
    closeDelay: { default: 300 }
  },
  emits: ["update:open"],
  setup(n, { emit: t }) {
    const e = n, { openDelay: o, closeDelay: a } = G(e), s = q(e, "open", t, {
      defaultValue: e.defaultOpen,
      passive: !0
    }), i = S(0), r = S(0), u = S(!1), d = S(!1);
    function p() {
      clearTimeout(r.value), i.value = window.setTimeout(() => s.value = !0, o.value);
    }
    function c() {
      clearTimeout(i.value), !u.value && !d.value && (r.value = window.setTimeout(() => s.value = !1, a.value));
    }
    function f() {
      s.value = !1;
    }
    return W(mn, {
      open: s,
      onOpenChange(v) {
        s.value = v;
      },
      onOpen: p,
      onClose: c,
      onDismiss: f,
      hasSelectionRef: u,
      isPointerDownOnContentRef: d
    }), (v, h) => (g(), C(l(Je), null, {
      default: y(() => [
        _(v.$slots, "default")
      ]),
      _: 3
    }));
  }
});
function en(n) {
  return (t) => t.pointerType === "touch" ? void 0 : n();
}
function $r(n) {
  const t = [], e = document.createTreeWalker(n, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (o) => o.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
  });
  for (; e.nextNode(); )
    t.push(e.currentNode);
  return t;
}
const Md = /* @__PURE__ */ w({
  __name: "HoverCardTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "a" }
  },
  setup(n) {
    const t = T(mn);
    return (e, o) => (g(), C(l(qe), { "as-child": "" }, {
      default: y(() => {
        var a;
        return [
          L(l(M), {
            "as-child": e.asChild,
            as: e.as,
            "data-state": (a = l(t)) != null && a.open.value ? "open" : "closed",
            onPointerenter: o[0] || (o[0] = (s) => l(en)(l(t).onOpen)(s)),
            onPointerleave: o[1] || (o[1] = (s) => l(en)(l(t).onClose)(s)),
            onFocus: o[2] || (o[2] = (s) => l(t).onOpen()),
            onBlur: l(t).onClose,
            onTouchstart: oe(() => {
            }, ["prevent"])
          }, {
            default: y(() => [
              _(e.$slots, "default")
            ]),
            _: 3
          }, 8, ["as-child", "as", "data-state", "onBlur", "onTouchstart"])
        ];
      }),
      _: 3
    }));
  }
}), Rd = /* @__PURE__ */ w({
  __name: "HoverCardPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(Le), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Or = /* @__PURE__ */ w({
  __name: "HoverCardContentImpl",
  props: {
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(n, { emit: t }) {
    const o = sn(n), { primitiveElement: a, currentElement: s } = H(), i = T(mn), r = S(!1);
    let u;
    ee((p) => {
      if (r.value) {
        const c = document.body;
        u = c.style.userSelect || c.style.webkitUserSelect, c.style.userSelect = "none", c.style.webkitUserSelect = "none", p(() => {
          c.style.userSelect = u, c.style.webkitUserSelect = u;
        });
      }
    });
    function d() {
      r.value = !1, i.isPointerDownOnContentRef.value = !1, Z(() => {
        var c;
        ((c = document.getSelection()) == null ? void 0 : c.toString()) !== "" && (i.hasSelectionRef.value = !0);
      });
    }
    return Y(() => {
      s.value && (document.addEventListener("pointerup", d), $r(s.value).forEach((c) => c.setAttribute("tabindex", "-1")));
    }), ue(() => {
      document.removeEventListener("pointerup", d), i.hasSelectionRef.value = !1, i.isPointerDownOnContentRef.value = !1;
    }), (p, c) => {
      var f;
      return g(), C(l(Ne), {
        "as-child": "",
        "disable-outside-pointer-events": !1,
        onEscapeKeyDown: c[1] || (c[1] = (v) => t("escapeKeyDown", v)),
        onPointerDownOutside: c[2] || (c[2] = (v) => t("pointerDownOutside", v)),
        onFocusOutside: c[3] || (c[3] = oe((v) => t("focusOutside", v), ["prevent"])),
        onDismiss: (f = l(i)) == null ? void 0 : f.onDismiss
      }, {
        default: y(() => {
          var v;
          return [
            L(l(ct), k({
              ref_key: "primitiveElement",
              ref: a
            }, { ...l(o), ...p.$attrs }, {
              "data-state": (v = l(i)) != null && v.open.value ? "open" : "closed",
              style: {
                userSelect: r.value ? "text" : void 0,
                // Safari requires prefix
                WebkitUserSelect: r.value ? "text" : void 0,
                // re-namespace exposed content custom properties
                "--radix-hover-card-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-hover-card-content-available-width": "var(--radix-popper-available-width)",
                "--radix-hover-card-content-available-height": "var(--radix-popper-available-height)",
                "--radix-hover-card-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-hover-card-trigger-height": "var(--radix-popper-anchor-height)"
              },
              onPointerdown: c[0] || (c[0] = (h) => {
                h.currentTarget.contains(h.target) && (r.value = !0), l(i).hasSelectionRef.value = !1, l(i).isPointerDownOnContentRef.value = !0;
              })
            }), {
              default: y(() => [
                _(p.$slots, "default")
              ]),
              _: 3
            }, 16, ["data-state", "style"])
          ];
        }),
        _: 3
      }, 8, ["onDismiss"]);
    };
  }
}), Fd = /* @__PURE__ */ w({
  __name: "HoverCardContent",
  props: {
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(n, { emit: t }) {
    const o = fe(n, t), a = T(mn);
    return (s, i) => (g(), C(l(ce), {
      present: l(a).open.value
    }, {
      default: y(() => [
        L(Or, k(l(o), {
          onPointerenter: i[0] || (i[0] = (r) => l(en)(l(a).onOpen)(r)),
          onPointerleave: i[1] || (i[1] = (r) => l(en)(l(a).onClose)(r))
        }), {
          default: y(() => [
            _(s.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), Nd = /* @__PURE__ */ w({
  __name: "HoverCardArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(pt), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ve = Symbol(), Ld = /* @__PURE__ */ w({
  __name: "PopoverRoot",
  props: {
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    modal: { type: Boolean, default: !1 }
  },
  emits: ["update:open"],
  setup(n, { emit: t }) {
    const e = n, { modal: o } = G(e), a = q(e, "open", t, {
      defaultValue: e.defaultOpen,
      passive: !0
    }), s = S(), i = S(!1);
    return W(Ve, {
      contentId: te(),
      modal: o,
      open: a,
      onOpenChange: (r) => {
        a.value = r;
      },
      onOpenToggle: () => {
        a.value = !a.value;
      },
      triggerElement: s,
      hasCustomAnchor: i
    }), (r, u) => (g(), C(l(Je), null, {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }));
  }
}), Vd = /* @__PURE__ */ w({
  __name: "PopoverTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(n, { expose: t }) {
    const e = n, o = T(Ve), { primitiveElement: a, currentElement: s } = H();
    return Y(() => {
      o.triggerElement.value = s.value;
    }), t({ $el: s }), (i, r) => {
      var u;
      return g(), C(Fe((u = l(o)) != null && u.hasCustomAnchor.value ? l(M) : l(qe)), { "as-child": "" }, {
        default: y(() => {
          var d, p, c;
          return [
            L(l(M), {
              ref_key: "primitiveElement",
              ref: a,
              type: i.as === "button" ? "button" : void 0,
              "aria-haspopup": "dialog",
              "aria-expanded": (d = l(o)) == null ? void 0 : d.open.value,
              "aria-controls": (p = l(o)) == null ? void 0 : p.contentId,
              "data-state": (c = l(o)) != null && c.open.value ? "open" : "closed",
              as: i.as,
              "as-child": e.asChild,
              onClick: l(o).onOpenToggle
            }, {
              default: y(() => [
                _(i.$slots, "default")
              ]),
              _: 3
            }, 8, ["type", "aria-expanded", "aria-controls", "data-state", "as", "as-child", "onClick"])
          ];
        }),
        _: 3
      });
    };
  }
}), Kd = /* @__PURE__ */ w({
  __name: "PopoverPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(Le), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ds = /* @__PURE__ */ w({
  __name: "PopoverContentImpl",
  props: {
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(n, { emit: t }) {
    const o = sn(n), a = T(Ve);
    return Qn(), (s, i) => (g(), C(l(fn), {
      "as-child": "",
      loop: "",
      trapped: s.trapFocus,
      onMountAutoFocus: i[5] || (i[5] = (r) => t("openAutoFocus", r)),
      onUnmountAutoFocus: i[6] || (i[6] = (r) => t("closeAutoFocus", r))
    }, {
      default: y(() => [
        L(l(Ne), {
          "as-child": "",
          "disable-outside-pointer-events": s.disableOutsidePointerEvents,
          onPointerDownOutside: i[0] || (i[0] = (r) => t("pointerDownOutside", r)),
          onInteractOutside: i[1] || (i[1] = (r) => t("interactOutside", r)),
          onEscapeKeyDown: i[2] || (i[2] = (r) => t("escapeKeyDown", r)),
          onFocusOutside: i[3] || (i[3] = (r) => t("focusOutside", r)),
          onDismiss: i[4] || (i[4] = (r) => {
            var u;
            return (u = l(a)) == null ? void 0 : u.onOpenChange(!1);
          })
        }, {
          default: y(() => {
            var r, u;
            return [
              L(l(ct), k(l(o), {
                id: (r = l(a)) == null ? void 0 : r.contentId,
                "data-state": (u = l(a)) != null && u.open.value ? "open" : "closed",
                role: "dialog",
                style: {
                  "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                }
              }), {
                default: y(() => [
                  _(s.$slots, "default")
                ]),
                _: 3
              }, 16, ["id", "data-state", "style"])
            ];
          }),
          _: 3
        }, 8, ["disable-outside-pointer-events"])
      ]),
      _: 3
    }, 8, ["trapped"]));
  }
}), Sr = /* @__PURE__ */ w({
  __name: "PopoverContentModal",
  props: {
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(n, { emit: t }) {
    const e = n, o = T(Ve), a = S(!1);
    Tt(!0);
    const s = fe(e, t), { primitiveElement: i, currentElement: r } = H();
    return Pt(r), (u, d) => {
      var p;
      return g(), C(ds, k({
        ref_key: "primitiveElement",
        ref: i
      }, l(s), {
        "trap-focus": (p = l(o)) == null ? void 0 : p.open.value,
        "disable-outside-pointer-events": "",
        onCloseAutoFocus: d[0] || (d[0] = oe(
          (c) => {
            var f, v;
            t("closeAutoFocus", c), a.value || (v = (f = l(o)) == null ? void 0 : f.triggerElement.value) == null || v.focus();
          },
          ["prevent"]
        )),
        onPointerDownOutside: d[1] || (d[1] = (c) => {
          t("pointerDownOutside", c);
          const f = c.detail.originalEvent, v = f.button === 0 && f.ctrlKey === !0, h = f.button === 2 || v;
          a.value = h;
        }),
        onFocusOutside: d[2] || (d[2] = oe(() => {
        }, ["prevent"]))
      }), {
        default: y(() => [
          _(u.$slots, "default")
        ]),
        _: 3
      }, 16, ["trap-focus"]);
    };
  }
}), Pr = /* @__PURE__ */ w({
  __name: "PopoverContentNonModal",
  props: {
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(n, { emit: t }) {
    const e = n, o = T(Ve), a = S(!1), s = S(!1), i = fe(e, t);
    return (r, u) => (g(), C(ds, k(l(i), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: u[0] || (u[0] = (d) => {
        var p, c;
        t("closeAutoFocus", d), d.defaultPrevented || (a.value || (c = (p = l(o)) == null ? void 0 : p.triggerElement.value) == null || c.focus(), d.preventDefault()), a.value = !1, s.value = !1;
      }),
      onInteractOutside: u[1] || (u[1] = async (d) => {
        var f, v;
        t("interactOutside", d), d.defaultPrevented || (a.value = !0, d.detail.originalEvent.type === "pointerdown" && (s.value = !0));
        const p = d.target;
        ((v = (f = l(o)) == null ? void 0 : f.triggerElement.value) == null ? void 0 : v.contains(p)) && d.preventDefault(), d.detail.originalEvent.type === "focusin" && s.value && d.preventDefault();
      })
    }), {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Hd = /* @__PURE__ */ w({
  __name: "PopoverContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(n, { emit: t }) {
    const e = n, o = T(Ve), a = fe(e, t);
    return (s, i) => (g(), C(l(ce), {
      present: s.forceMount || l(o).open.value
    }, {
      default: y(() => {
        var r;
        return [
          (r = l(o)) != null && r.modal.value ? (g(), C(Sr, N(k({ key: 0 }, l(a))), {
            default: y(() => [
              _(s.$slots, "default")
            ]),
            _: 3
          }, 16)) : (g(), C(Pr, N(k({ key: 1 }, l(a))), {
            default: y(() => [
              _(s.$slots, "default")
            ]),
            _: 3
          }, 16))
        ];
      }),
      _: 3
    }, 8, ["present"]));
  }
}), Wd = /* @__PURE__ */ w({
  __name: "PopoverArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(pt), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ud = /* @__PURE__ */ w({
  __name: "PopoverClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(n) {
    const t = n, e = T(Ve);
    return (o, a) => (g(), C(l(M), {
      type: o.as === "button" ? "button" : void 0,
      as: o.as,
      "as-child": t.asChild,
      onClick: a[0] || (a[0] = (s) => {
        var i;
        return (i = l(e)) == null ? void 0 : i.onOpenChange(!1);
      })
    }, {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 8, ["type", "as", "as-child"]));
  }
}), zd = /* @__PURE__ */ w({
  __name: "PopoverAnchor",
  props: {
    element: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, e = T(Ve);
    return fa(() => {
      e.hasCustomAnchor.value = !0;
    }), ue(() => {
      e.hasCustomAnchor.value = !1;
    }), (o, a) => (g(), C(l(qe), N(K(t)), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), hn = /* @__PURE__ */ w({
  __name: "MenuAnchor",
  props: {
    element: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(qe), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _o = /* @__PURE__ */ w({
  __name: "MenuArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(pt), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), De = Symbol(), ht = Symbol(), wo = /* @__PURE__ */ w({
  __name: "MenuRoot",
  props: {
    open: { type: Boolean, default: !1 },
    onOpenChange: {},
    dir: { default: "ltr" },
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(n, { emit: t }) {
    const e = n, { modal: o, dir: a } = G(e), s = q(e, "open", t), i = S(), r = S(!1);
    return ee((u) => {
      if (!Ce)
        return;
      const d = () => {
        r.value = !0, document.addEventListener("pointerdown", p, {
          capture: !0,
          once: !0
        }), document.addEventListener("pointermove", p, {
          capture: !0,
          once: !0
        });
      }, p = () => r.value = !1;
      document.addEventListener("keydown", d, { capture: !0 }), u(() => {
        document.removeEventListener("keydown", d, { capture: !0 }), document.removeEventListener("pointerdown", p, {
          capture: !0
        }), document.removeEventListener("pointermove", p, {
          capture: !0
        });
      });
    }), W(De, {
      open: s,
      onOpenChange: (u) => {
        s.value = u;
      },
      content: i,
      onContentChange: (u) => {
        i.value = u;
      }
    }), W(ht, {
      onClose: () => {
        s.value = !1;
      },
      isUsingKeyboardRef: r,
      dir: a,
      modal: o
    }), (u, d) => (g(), C(l(Je), null, {
      default: y(() => [
        _(u.$slots, "default")
      ]),
      _: 3
    }));
  }
}), yn = Symbol(), Co = /* @__PURE__ */ w({
  __name: "MenuContentImpl",
  props: ca({
    loop: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    disableOutsideScroll: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  }, {
    ...ka
  }),
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(n, { emit: t }) {
    const e = n, o = T(De), a = T(ht), { trapFocus: s, disableOutsidePointerEvents: i, loop: r } = G(e);
    Qn(), Tt(i.value);
    const u = S(""), d = S(0), p = S(0), c = S(null), f = S("right"), v = S(0), h = S(null), { createCollection: m } = le(), { primitiveElement: b, currentElement: $ } = H(), O = m($);
    X($, (A) => {
      o.onContentChange(A);
    });
    const { handleTypeaheadSearch: E } = eo(O);
    ue(() => {
      window.clearTimeout(d.value);
    });
    function P(A) {
      var F, U;
      return f.value === ((F = c.value) == null ? void 0 : F.side) && Ji(A, (U = c.value) == null ? void 0 : U.area);
    }
    async function B(A) {
      var R;
      t("openAutoFocus", A), A.preventDefault(), (R = $.value) == null || R.focus();
    }
    function I(A) {
      const F = A.target.closest("[data-radix-menu-content]") === A.currentTarget, U = A.ctrlKey || A.altKey || A.metaKey, z = A.key.length === 1, j = an(
        A,
        document.activeElement,
        $.value,
        {
          loop: r.value,
          arrowKeyOptions: "vertical",
          dir: a == null ? void 0 : a.dir.value,
          focus: !0
        }
      );
      if (j)
        return j == null ? void 0 : j.focus();
      if (A.code === "Space" || (F && (A.key === "Tab" && A.preventDefault(), !U && z && E(A.key)), A.target !== $.value) || !zi.includes(A.key))
        return;
      A.preventDefault();
      const ne = O.value;
      ts.includes(A.key) && ne.reverse(), Kn(ne);
    }
    function x(A) {
      var R, F;
      (F = (R = A == null ? void 0 : A.currentTarget) == null ? void 0 : R.contains) != null && F.call(R, A.target) || (window.clearTimeout(d.value), u.value = "");
    }
    function V(A) {
      var U;
      if (!$t(A))
        return;
      const R = A.target, F = v.value !== A.clientX;
      if ((U = A == null ? void 0 : A.currentTarget) != null && U.contains(R) && F) {
        const z = A.clientX > v.value ? "right" : "left";
        f.value = z, v.value = A.clientX;
      }
    }
    return W(yn, {
      onItemEnter: (A) => {
        P(A) && A.preventDefault();
      },
      onItemLeave: (A) => {
        var R;
        P(A) || ((R = $.value) == null || R.focus(), h.value = null);
      },
      onTriggerLeave: (A) => {
        P(A) && A.preventDefault();
      },
      searchRef: u,
      pointerGraceTimerRef: p,
      onPointerGraceIntentChange: (A) => {
        c.value = A;
      }
    }), (A, R) => (g(), C(l(fn), {
      "as-child": "",
      trapped: l(s),
      onMountAutoFocus: B,
      onUnmountAutoFocus: R[7] || (R[7] = (F) => t("closeAutoFocus", F))
    }, {
      default: y(() => [
        L(l(Ne), {
          "as-child": "",
          "disable-outside-pointer-events": l(i),
          onEscapeKeyDown: R[2] || (R[2] = (F) => t("escapeKeyDown", F)),
          onPointerDownOutside: R[3] || (R[3] = (F) => t("pointerDownOutside", F)),
          onFocusOutside: R[4] || (R[4] = (F) => t("focusOutside", F)),
          onInteractOutside: R[5] || (R[5] = (F) => t("interactOutside", F)),
          onDismiss: R[6] || (R[6] = (F) => t("dismiss"))
        }, {
          default: y(() => {
            var F;
            return [
              L(l(vt), {
                "current-tab-stop-id": h.value,
                "onUpdate:currentTabStopId": R[0] || (R[0] = (U) => h.value = U),
                "as-child": "",
                orientation: "vertical",
                dir: (F = l(a)) == null ? void 0 : F.dir.value,
                loop: l(r),
                onEntryFocus: R[1] || (R[1] = (U) => {
                  var z;
                  t("entryFocus", U), (z = l(a)) != null && z.isUsingKeyboardRef.value || U.preventDefault();
                })
              }, {
                default: y(() => [
                  L(l(ct), {
                    ref_key: "primitiveElement",
                    ref: b,
                    role: "menu",
                    as: A.as,
                    "as-child": A.asChild,
                    "aria-orientation": "vertical",
                    "data-radix-menu-content": "",
                    "data-state": l(mo)(l(o).open.value),
                    dir: l(a).dir.value,
                    side: A.side,
                    "side-offset": A.sideOffset,
                    align: A.align,
                    "align-offset": A.alignOffset,
                    "avoid-collisions": A.avoidCollisions,
                    "collision-boundary": A.collisionBoundary,
                    "collision-padding": A.collisionPadding,
                    "arrow-padding": A.arrowPadding,
                    sticky: A.sticky,
                    "hide-when-detached": A.hideWhenDetached,
                    onKeydown: I,
                    onBlur: x,
                    onPointermove: V
                  }, {
                    default: y(() => [
                      _(A.$slots, "default")
                    ]),
                    _: 3
                  }, 8, ["as", "as-child", "data-state", "dir", "side", "side-offset", "align", "align-offset", "avoid-collisions", "collision-boundary", "collision-padding", "arrow-padding", "sticky", "hide-when-detached"])
                ]),
                _: 3
              }, 8, ["current-tab-stop-id", "dir", "loop"])
            ];
          }),
          _: 3
        }, 8, ["disable-outside-pointer-events"])
      ]),
      _: 3
    }, 8, ["trapped"]));
  }
}), cs = /* @__PURE__ */ w({
  __name: "MenuItemImpl",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(n, { expose: t }) {
    const e = n, { primitiveElement: o, currentElement: a } = H(), s = T(yn), i = S(!1);
    async function r(d) {
      if (await Z(), !d.defaultPrevented && $t(d)) {
        if (e.disabled)
          s.onItemLeave(d);
        else if (s.onItemEnter(d), !d.defaultPrevented) {
          const p = d.currentTarget;
          p && p.focus();
        }
      }
    }
    async function u(d) {
      await Z(), !d.defaultPrevented && $t(d) && s.onItemLeave(d);
    }
    return t({
      el: a
    }), (d, p) => (g(), C(l(M), {
      ref_key: "primitiveElement",
      ref: o,
      role: "menuitem",
      tabindex: "-1",
      as: d.as,
      "as-child": d.asChild,
      "data-radix-vue-collection-item": "",
      "aria-disabled": d.disabled || void 0,
      "data-disabled": d.disabled ? "" : void 0,
      disabled: d.disabled,
      "data-highlighted": i.value ? "" : void 0,
      onPointermove: r,
      onPointerleave: u,
      onFocus: p[0] || (p[0] = async (c) => {
        await Z(), !(c.defaultPrevented || d.disabled) && (i.value = !0);
      }),
      onBlur: p[1] || (p[1] = async (c) => {
        await Z(), !c.defaultPrevented && (i.value = !1);
      })
    }, {
      default: y(() => [
        _(d.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "aria-disabled", "data-disabled", "disabled", "data-highlighted"]));
  }
}), Dt = /* @__PURE__ */ w({
  __name: "MenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(n, { emit: t }) {
    const e = n, { primitiveElement: o, currentElement: a } = H(), s = T(ht), i = T(yn), r = S(!1);
    async function u() {
      const d = a.value;
      if (!e.disabled && d) {
        const p = new CustomEvent(Wi, {
          bubbles: !0,
          cancelable: !0
        });
        t("select", p), await Z(), p.defaultPrevented ? r.value = !1 : s.onClose();
      }
    }
    return (d, p) => (g(), C(cs, k(e, {
      ref_key: "primitiveElement",
      ref: o,
      onClick: u,
      onPointerdown: p[0] || (p[0] = () => {
        r.value = !0;
      }),
      onPointerup: p[1] || (p[1] = async (c) => {
        var f;
        await Z(), !c.defaultPrevented && (r.value || (f = c.currentTarget) == null || f.click());
      }),
      onKeydown: p[2] || (p[2] = async (c) => {
        const f = l(i).searchRef.value !== "";
        d.disabled || f && c.key === " " || l(Vn).includes(c.key) && (c.currentTarget.click(), c.preventDefault());
      })
    }), {
      default: y(() => [
        _(d.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Eo = Symbol(), $o = /* @__PURE__ */ w({
  __name: "MenuItemIndicator",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(n) {
    const t = T(Eo, {
      checked: S(!1)
    });
    return (e, o) => {
      var a, s;
      return g(), C(l(ce), {
        present: l(Qt)((a = l(t)) == null ? void 0 : a.checked.value) || ((s = l(t)) == null ? void 0 : s.checked.value) === !0
      }, {
        default: y(() => [
          L(l(M), {
            as: e.as,
            "as-child": e.asChild,
            "data-state": l(ho)(l(t).checked.value)
          }, {
            default: y(() => [
              _(e.$slots, "default")
            ]),
            _: 3
          }, 8, ["as", "as-child", "data-state"])
        ]),
        _: 3
      }, 8, ["present"]);
    };
  }
}), Oo = /* @__PURE__ */ w({
  __name: "MenuCheckboxItem",
  props: {
    checked: { type: [Boolean, String], default: !1 },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:checked"],
  setup(n, { emit: t }) {
    const e = n, o = q(e, "checked", t);
    return W(Eo, {
      checked: o
    }), (a, s) => (g(), C(Dt, k({ role: "menuitemcheckbox" }, e, {
      "aria-checked": l(Qt)(l(o)) ? "mixed" : l(o),
      "data-state": l(ho)(l(o)),
      onSelect: s[0] || (s[0] = async (i) => {
        t("select", i), l(Qt)(l(o)) ? o.value = !0 : o.value = !l(o);
      })
    }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-checked", "data-state"]));
  }
}), Tr = /* @__PURE__ */ w({
  __name: "MenuRootContentModal",
  props: {
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(n, { emit: t }) {
    const e = n, o = T(De), a = ae(t), { primitiveElement: s, currentElement: i } = H();
    return Pt(i), (r, u) => {
      var d, p;
      return g(), C(Co, k({
        ref_key: "primitiveElement",
        ref: s
      }, { ...e, ...l(a) }, {
        "trap-focus": (d = l(o)) == null ? void 0 : d.open.value,
        "disable-outside-pointer-events": (p = l(o)) == null ? void 0 : p.open.value,
        "disable-outside-scroll": !0,
        onDismiss: u[0] || (u[0] = (c) => {
          var f;
          return (f = l(o)) == null ? void 0 : f.onOpenChange(!1);
        }),
        onFocusOutside: u[1] || (u[1] = oe((c) => t("focusOutside", c), ["prevent"]))
      }), {
        default: y(() => [
          _(r.$slots, "default")
        ]),
        _: 3
      }, 16, ["trap-focus", "disable-outside-pointer-events"]);
    };
  }
}), Br = /* @__PURE__ */ w({
  __name: "MenuRootContentNonModal",
  props: {
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(n, { emit: t }) {
    const e = n, o = T(De), a = ae(t);
    return (s, i) => (g(), C(Co, k({ ...e, ...l(a) }, {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      "disable-outside-scroll": !1,
      onDismiss: i[0] || (i[0] = (r) => {
        var u;
        return (u = l(o)) == null ? void 0 : u.onOpenChange(!1);
      })
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), So = /* @__PURE__ */ w({
  __name: "MenuContent",
  props: {
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(n, { emit: t }) {
    const e = n, o = T(De), a = T(ht), s = ae(t);
    return (i, r) => (g(), C(l(ce), {
      present: l(o).open.value
    }, {
      default: y(() => {
        var u;
        return [
          (u = l(a)) != null && u.modal.value ? (g(), C(Tr, N(k({ key: 0 }, { ...i.$attrs, ...e, ...l(s) })), {
            default: y(() => [
              _(i.$slots, "default")
            ]),
            _: 3
          }, 16)) : (g(), C(Br, N(k({ key: 1 }, { ...i.$attrs, ...e, ...l(s) })), {
            default: y(() => [
              _(i.$slots, "default")
            ]),
            _: 3
          }, 16))
        ];
      }),
      _: 3
    }, 8, ["present"]));
  }
}), gn = /* @__PURE__ */ w({
  __name: "MenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(M), k({ role: "group" }, t), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Po = /* @__PURE__ */ w({
  __name: "MenuLabel",
  props: {
    asChild: { type: Boolean },
    as: { default: "label" }
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(M), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), To = /* @__PURE__ */ w({
  __name: "MenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(Le), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ps = Symbol(), Bo = /* @__PURE__ */ w({
  __name: "MenuRadioGroup",
  props: {
    modelValue: { default: "" },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(n, { emit: t }) {
    const e = n, o = q(e, "modelValue", t);
    return W(ps, {
      modelValue: o,
      onValueChange: (a) => {
        o.value = a;
      }
    }), (a, s) => (g(), C(gn, N(K(e)), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ao = /* @__PURE__ */ w({
  __name: "MenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(n, { emit: t }) {
    const e = n, { value: o } = G(e), a = T(ps), s = D(
      () => (a == null ? void 0 : a.modelValue.value) === (o == null ? void 0 : o.value)
    );
    return W(Eo, {
      checked: s
    }), (i, r) => (g(), C(Dt, k({ role: "menuitemradio" }, e, {
      "aria-checked": s.value,
      "data-state": l(ho)(s.value),
      onSelect: r[0] || (r[0] = async (u) => {
        var d;
        t("select", u), (d = l(a)) == null || d.onValueChange(l(o));
      })
    }), {
      default: y(() => [
        _(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-checked", "data-state"]));
  }
}), Io = /* @__PURE__ */ w({
  __name: "MenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(M), k(t, {
      role: "separator",
      "aria-orientation": "horizontal"
    }), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Do = Symbol(), xo = /* @__PURE__ */ w({
  __name: "MenuSub",
  props: {
    open: { type: Boolean }
  },
  emits: ["update:open"],
  setup(n, { emit: t }) {
    const o = q(n, "open", t, {
      defaultValue: !1,
      passive: !0
    }), a = T(De), s = S(), i = S();
    return ee((r) => {
      (a == null ? void 0 : a.open.value) === !1 && (o.value = !1), r(() => o.value = !1);
    }), W(De, {
      open: o,
      onOpenChange: (r) => {
        o.value = r;
      },
      content: i,
      onContentChange: (r) => {
        i.value = r;
      }
    }), W(Do, {
      triggerId: te(),
      contentId: te(),
      trigger: s,
      onTriggerChange: (r) => {
        s.value = r;
      }
    }), (r, u) => (g(), C(l(Je), null, {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }));
  }
}), ko = /* @__PURE__ */ w({
  __name: "MenuSubContent",
  props: {
    loop: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    disableOutsideScroll: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(n, { emit: t }) {
    const o = fe(n, t), a = T(De), s = T(ht), i = T(Do), { primitiveElement: r, currentElement: u } = H();
    return (d, p) => (g(), C(l(ce), {
      present: l(a).open.value
    }, {
      default: y(() => [
        L(Co, k(l(o), {
          id: l(i).contentId,
          ref_key: "primitiveElement",
          ref: r,
          "aria-labelledby": l(i).triggerId,
          align: "start",
          side: l(s).dir.value === "rtl" ? "left" : "right",
          "disable-outside-pointer-events": !1,
          "disable-outside-scroll": !1,
          "trap-focus": !1,
          onOpenAutoFocus: p[0] || (p[0] = (c) => {
            var f;
            l(s).isUsingKeyboardRef.value && ((f = l(u)) == null || f.focus());
          }),
          onCloseAutoFocus: p[1] || (p[1] = oe(() => {
          }, ["prevent"])),
          onFocusOutside: p[2] || (p[2] = async (c) => {
            c.defaultPrevented || c.target !== l(i).trigger.value && l(a).onOpenChange(!1);
          }),
          onEscapeKeyDown: p[3] || (p[3] = (c) => {
            var f;
            (f = l(s)) == null || f.onClose(), c.preventDefault();
          }),
          onKeydown: p[4] || (p[4] = (c) => {
            var h, m;
            const f = (h = c.currentTarget) == null ? void 0 : h.contains(c.target), v = l(Gi)[l(s).dir.value].includes(c.key);
            f && v && (l(a).onOpenChange(!1), (m = l(i).trigger.value) == null || m.focus(), c.preventDefault());
          })
        }), {
          default: y(() => [
            _(d.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "aria-labelledby", "side"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), Mo = /* @__PURE__ */ w({
  __name: "MenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, e = T(De), o = T(ht), a = T(Do), s = T(yn), i = S(null), r = D(
      () => s == null ? void 0 : s.pointerGraceTimerRef.value
    );
    function u() {
      i.value && window.clearTimeout(i.value), i.value = null;
    }
    ue(() => {
      u();
    });
    function d(f) {
      $t(f) && (s.onItemEnter(f), e.onOpenChange(!0), !f.defaultPrevented && !t.disabled && !(e != null && e.open.value) && !i.value && (s.onPointerGraceIntentChange(null), i.value = window.setTimeout(() => {
        u();
      }, 100)));
    }
    function p(f) {
      var h, m;
      if (!$t(f))
        return;
      u();
      const v = (h = e.content.value) == null ? void 0 : h.getBoundingClientRect();
      if (v) {
        const b = (m = e.content.value) == null ? void 0 : m.dataset.side, $ = b === "right", O = $ ? -5 : 5, E = v[$ ? "left" : "right"], P = v[$ ? "right" : "left"];
        s.onPointerGraceIntentChange({
          area: [
            // Apply a bleed on clientX to ensure that our exit point is
            // consistently within polygon bounds
            { x: f.clientX + O, y: f.clientY },
            { x: E, y: v.top },
            { x: P, y: v.top },
            { x: P, y: v.bottom },
            { x: E, y: v.bottom }
          ],
          side: b
        }), window.clearTimeout(r.value), s.pointerGraceTimerRef.value = window.setTimeout(
          () => s.onPointerGraceIntentChange(null),
          300
        );
      } else {
        if (s.onTriggerLeave(f), f.defaultPrevented)
          return;
        s.onPointerGraceIntentChange(null);
      }
    }
    async function c(f) {
      var h;
      const v = s.searchRef.value !== "";
      t.disabled || v && f.key === " " || Yi[o.dir.value].includes(f.key) && (e.onOpenChange(!0), await Z(), (h = e.content.value) == null || h.focus(), f.preventDefault());
    }
    return (f, v) => (g(), C(hn, { "as-child": "" }, {
      default: y(() => {
        var h;
        return [
          L(cs, {
            id: l(a).triggerId,
            ref: (m) => {
              var b;
              (b = l(a)) == null || b.onTriggerChange(m == null ? void 0 : m.el);
            },
            "aria-haspopup": "menu",
            "aria-expanded": l(e).open.value,
            "aria-controls": (h = l(a)) == null ? void 0 : h.contentId,
            "data-state": l(mo)(l(e).open.value),
            onClick: v[0] || (v[0] = async (m) => {
              t.disabled || m.defaultPrevented || (m.currentTarget.focus(), l(e).open.value || l(e).onOpenChange(!0));
            }),
            onPointermove: d,
            onPointerleave: p,
            onKeydown: c
          }, {
            default: y(() => [
              _(f.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "aria-expanded", "aria-controls", "data-state"])
        ];
      }),
      _: 3
    }));
  }
}), Ro = Symbol(), Yd = /* @__PURE__ */ w({
  __name: "DropdownMenuRoot",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean },
    dir: { default: "ltr" },
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(n, { emit: t }) {
    const e = n, o = q(e, "open", t, {
      defaultValue: e.defaultOpen,
      passive: !0
    }), a = S(), { modal: s, dir: i } = G(e);
    return W(Ro, {
      open: o,
      onOpenChange: (r) => {
        o.value = r;
      },
      onOpenToggle: () => {
        o.value = !o.value;
      },
      triggerId: te(),
      triggerElement: a,
      contentId: te(),
      modal: s,
      dir: i
    }), (r, u) => (g(), C(l(wo), {
      open: l(o),
      "onUpdate:open": u[0] || (u[0] = (d) => it(o) ? o.value = d : null),
      dir: l(i),
      modal: l(s)
    }, {
      default: y(() => [
        _(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["open", "dir", "modal"]));
  }
}), Gd = /* @__PURE__ */ w({
  __name: "DropdownMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(n) {
    const t = n, e = T(Ro), { primitiveElement: o, currentElement: a } = H();
    return Y(() => {
      e.triggerElement = a;
    }), (s, i) => (g(), C(l(hn), { "as-child": "" }, {
      default: y(() => {
        var r, u, d, p, c;
        return [
          L(l(M), {
            id: (r = l(e)) == null ? void 0 : r.triggerId,
            ref_key: "primitiveElement",
            ref: o,
            type: s.as === "button" ? "button" : void 0,
            "as-child": t.asChild,
            as: s.as,
            "aria-haspopup": "menu",
            "aria-expanded": (u = l(e)) == null ? void 0 : u.open.value,
            "aria-controls": (d = l(e)) != null && d.open.value ? (p = l(e)) == null ? void 0 : p.contentId : void 0,
            "data-disabled": s.disabled ? "" : void 0,
            disabled: s.disabled,
            "data-state": (c = l(e)) != null && c.open.value ? "open" : "closed",
            onPointerdown: i[0] || (i[0] = (f) => {
              var v, h;
              !s.disabled && f.button === 0 && f.ctrlKey === !1 && ((v = l(e)) == null || v.onOpenToggle(), (h = l(e)) != null && h.open.value && f.preventDefault());
            }),
            onKeydown: i[1] || (i[1] = pe(
              (f) => {
                var v, h;
                s.disabled || (["Enter", " "].includes(f.key) && ((v = l(e)) == null || v.onOpenToggle()), f.key === "ArrowDown" && ((h = l(e)) == null || h.onOpenChange(!0)), ["Enter", " ", "ArrowDown"].includes(f.key) && f.preventDefault());
              },
              ["enter", "space", "arrow-down"]
            ))
          }, {
            default: y(() => [
              _(s.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "type", "as-child", "as", "aria-expanded", "aria-controls", "data-disabled", "disabled", "data-state"])
        ];
      }),
      _: 3
    }));
  }
}), Xd = /* @__PURE__ */ w({
  __name: "DropdownMenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(To), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Jd = /* @__PURE__ */ w({
  __name: "DropdownMenuContent",
  props: {
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(n, { emit: t }) {
    const o = fe(n, t), a = T(Ro), s = S(!1);
    function i(r) {
      t("closeAutoFocus", r), !r.defaultPrevented && (s.value || setTimeout(() => {
        var u;
        (u = a == null ? void 0 : a.triggerElement.value) == null || u.focus();
      }, 0), s.value = !1, r.preventDefault());
    }
    return (r, u) => {
      var d, p;
      return g(), C(l(So), k(l(o), {
        id: (d = l(a)) == null ? void 0 : d.contentId,
        "aria-labelledby": (p = l(a)) == null ? void 0 : p.triggerId,
        style: {
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        },
        onCloseAutoFocus: i,
        onInteractOutside: u[0] || (u[0] = (c) => {
          var m;
          if (t("interactOutside", c), c.defaultPrevented)
            return;
          const f = c.detail.originalEvent, v = f.button === 0 && f.ctrlKey === !0, h = f.button === 2 || v;
          (!((m = l(a)) != null && m.modal.value) || h) && (s.value = !0);
        })
      }), {
        default: y(() => [
          _(r.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "aria-labelledby", "style"]);
    };
  }
}), qd = /* @__PURE__ */ w({
  __name: "DropdownMenuArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(_o), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), jd = /* @__PURE__ */ w({
  __name: "DropdownMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(n, { emit: t }) {
    const e = n, o = ae(t);
    return (a, s) => (g(), C(l(Dt), N(K({ ...e, ...l(o) })), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Zd = /* @__PURE__ */ w({
  __name: "DropdownMenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(gn), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Qd = /* @__PURE__ */ w({
  __name: "DropdownMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(Io), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ec = /* @__PURE__ */ w({
  __name: "DropdownMenuCheckboxItem",
  props: {
    checked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:checked"],
  setup(n, { emit: t }) {
    const e = n, o = ae(t);
    return (a, s) => (g(), C(l(Oo), N(K({ ...e, ...l(o) })), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), tc = /* @__PURE__ */ w({
  __name: "DropdownMenuItemIndicator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l($o), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), nc = /* @__PURE__ */ w({
  __name: "DropdownMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(Po), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), oc = /* @__PURE__ */ w({
  __name: "DropdownMenuRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(n, { emit: t }) {
    const e = n, o = ae(t);
    return (a, s) => (g(), C(l(Bo), N(K({ ...e, ...l(o) })), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ac = /* @__PURE__ */ w({
  __name: "DropdownMenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(n, { emit: t }) {
    const e = n;
    return (o, a) => (g(), C(l(Ao), N(K({ ...e, ...t })), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), sc = /* @__PURE__ */ w({
  __name: "DropdownMenuSub",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean }
  },
  emits: ["update:open"],
  setup(n, { emit: t }) {
    const e = n, o = q(e, "open", t, {
      passive: !0,
      defaultValue: e.defaultOpen ?? !1
    });
    return (a, s) => (g(), C(l(xo), {
      open: l(o),
      "onUpdate:open": s[0] || (s[0] = (i) => it(o) ? o.value = i : null)
    }, {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["open"]));
  }
}), lc = /* @__PURE__ */ w({
  __name: "DropdownMenuSubContent",
  props: {
    loop: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    disableOutsideScroll: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(n, { emit: t }) {
    const o = fe(n, t);
    return (a, s) => (g(), C(l(ko), k(l(o), { style: {
      "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
    } }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["style"]));
  }
}), ic = /* @__PURE__ */ w({
  __name: "DropdownMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(Mo), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Fo = Symbol(), rc = /* @__PURE__ */ w({
  __name: "ContextMenuRoot",
  props: {
    dir: { default: "ltr" },
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(n, { emit: t }) {
    const e = n, { dir: o, modal: a } = G(e), s = S(!1);
    return W(Fo, {
      open: s,
      onOpenChange: (i) => {
        s.value = i, t("update:open", i);
      },
      dir: o,
      modal: a
    }), (i, r) => (g(), C(l(wo), {
      open: s.value,
      "onUpdate:open": r[0] || (r[0] = (u) => s.value = u),
      dir: l(o),
      modal: l(a)
    }, {
      default: y(() => [
        _(i.$slots, "default")
      ]),
      _: 3
    }, 8, ["open", "dir", "modal"]));
  }
});
function aa(n) {
  return n.pointerType !== "mouse";
}
const Ar = {
  inheritAttrs: !1
}, uc = /* @__PURE__ */ w({
  ...Ar,
  __name: "ContextMenuTrigger",
  props: {
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(n) {
    const t = n, { disabled: e } = G(t), o = T(Fo), a = S({ x: 0, y: 0 }), s = D(() => ({
      getBoundingClientRect: () => ({
        width: 0,
        height: 0,
        left: a.value.x,
        right: a.value.x,
        top: a.value.y,
        bottom: a.value.y,
        ...a.value
      })
    })), i = S(0);
    function r() {
      window.clearTimeout(i.value);
    }
    function u(f) {
      a.value = { x: f.clientX, y: f.clientY }, o == null || o.onOpenChange(!0);
    }
    async function d(f) {
      e.value || (await Z(), f.defaultPrevented || (r(), u(f), f.preventDefault()));
    }
    async function p(f) {
      e.value || (await Z(), aa(f) && !f.defaultPrevented && (r(), i.value = window.setTimeout(() => u(f), 700)));
    }
    async function c(f) {
      e.value || (await Z(), aa(f) && !f.defaultPrevented && r());
    }
    return (f, v) => {
      var h;
      return g(), Q(re, null, [
        L(l(hn), {
          as: "div",
          element: s.value
        }, null, 8, ["element"]),
        L(l(M), k({
          as: f.as,
          "as-child": f.asChild,
          "data-state": (h = l(o)) != null && h.open.value ? "open" : "closed",
          "data-disabled": l(e) ? "" : void 0,
          style: {
            WebkitTouchCallout: "none"
          }
        }, f.$attrs, {
          onContextmenu: d,
          onPointerdown: p,
          onPointermove: c,
          onPointercancel: c,
          onPointerup: c
        }), {
          default: y(() => [
            _(f.$slots, "default")
          ]),
          _: 3
        }, 16, ["as", "as-child", "data-state", "data-disabled"])
      ], 64);
    };
  }
}), dc = /* @__PURE__ */ w({
  __name: "ContextMenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(To), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), cc = /* @__PURE__ */ w({
  __name: "ContextMenuContent",
  props: {
    loop: { type: Boolean },
    alignOffset: { default: 0 },
    avoidCollisions: { type: Boolean, default: !0 },
    collisionBoundary: { default: () => [] },
    collisionPadding: { default: 0 },
    sticky: { default: "partial" },
    hideWhenDetached: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(n, { emit: t }) {
    const e = n, o = T(Fo), a = S(!1);
    return (s, i) => (g(), C(l(So), k(e, {
      side: "right",
      "side-offset": 2,
      align: "start",
      style: {
        "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
      },
      onCloseAutoFocus: i[0] || (i[0] = (r) => {
        t("closeAutoFocus", r), !r.defaultPrevented && a.value && r.preventDefault(), a.value = !1;
      }),
      onInteractOutside: i[1] || (i[1] = (r) => {
        var u;
        t("interactOutside", r), !r.defaultPrevented && !((u = l(o)) != null && u.modal.value) && (a.value = !0);
      })
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["style"]));
  }
}), pc = /* @__PURE__ */ w({
  __name: "ContextMenuArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(_o), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), fc = /* @__PURE__ */ w({
  __name: "ContextMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(n, { emit: t }) {
    const e = n, o = ae(t);
    return (a, s) => (g(), C(l(Dt), N(K({ ...e, ...l(o) })), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), vc = /* @__PURE__ */ w({
  __name: "ContextMenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(gn), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), mc = /* @__PURE__ */ w({
  __name: "ContextMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(Io), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), hc = /* @__PURE__ */ w({
  __name: "ContextMenuCheckboxItem",
  props: {
    checked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:checked"],
  setup(n, { emit: t }) {
    const e = n, o = ae(t);
    return (a, s) => (g(), C(l(Oo), N(K({ ...e, ...l(o) })), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), yc = /* @__PURE__ */ w({
  __name: "ContextMenuItemIndicator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l($o), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), gc = /* @__PURE__ */ w({
  __name: "ContextMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(Po), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), bc = /* @__PURE__ */ w({
  __name: "ContextMenuRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(n, { emit: t }) {
    const e = n, o = ae(t);
    return (a, s) => (g(), C(l(Bo), N(K({ ...e, ...l(o) })), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _c = /* @__PURE__ */ w({
  __name: "ContextMenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(n, { emit: t }) {
    const e = n, o = ae(t);
    return (a, s) => (g(), C(l(Ao), N(K({ ...e, ...l(o) })), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), wc = /* @__PURE__ */ w({
  __name: "ContextMenuSub",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean }
  },
  emits: ["update:open"],
  setup(n, { emit: t }) {
    const e = n, o = q(e, "open", t, {
      passive: !0,
      defaultValue: e.defaultOpen
    });
    return (a, s) => (g(), C(l(xo), {
      open: l(o),
      "onUpdate:open": s[0] || (s[0] = (i) => it(o) ? o.value = i : null)
    }, {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["open"]));
  }
}), Cc = /* @__PURE__ */ w({
  __name: "ContextMenuSubContent",
  props: {
    loop: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    disableOutsideScroll: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(n, { emit: t }) {
    const o = fe(n, t);
    return (a, s) => (g(), C(l(ko), k(l(o), { style: {
      "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
    } }), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["style"]));
  }
}), Ec = /* @__PURE__ */ w({
  __name: "ContextMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(Mo), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ir = ["default-value"], Dr = /* @__PURE__ */ w({
  __name: "BubbleSelect",
  props: {
    autocomplete: {},
    autofocus: { type: Boolean },
    disabled: { type: Boolean },
    form: {},
    multiple: { type: Boolean },
    name: {},
    required: { type: Boolean },
    size: {},
    value: {}
  },
  setup(n) {
    const t = n, { value: e } = G(t);
    js(e);
    const o = S();
    return (a, s) => (g(), C(l(ft), { "as-child": "" }, {
      default: y(() => [
        tn(St("select", k({
          ref_key: "selectElement",
          ref: o
        }, t, {
          "onUpdate:modelValue": s[0] || (s[0] = (i) => it(e) ? e.value = i : null),
          "default-value": l(e)
        }), [
          _(a.$slots, "default")
        ], 16, Ir), [
          [Rs, l(e)]
        ])
      ]),
      _: 3
    }));
  }
}), xr = {
  key: 0,
  value: ""
}, Oe = Symbol(), fs = Symbol(), $c = /* @__PURE__ */ w({
  __name: "SelectRoot",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean },
    defaultValue: { default: "" },
    modelValue: { default: void 0 },
    orientation: { default: "vertical" },
    dir: { default: "ltr" },
    name: {},
    autocomplete: {},
    disabled: { type: Boolean },
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "update:open"],
  setup(n, { emit: t }) {
    const e = n, o = q(e, "modelValue", t, {
      defaultValue: e.defaultValue,
      passive: !e.modelValue
    }), a = q(e, "open", t, {
      defaultValue: e.defaultOpen,
      passive: !0
    }), s = S(), i = S(), r = S({
      x: 0,
      y: 0
    }), u = S(!1), { required: d, disabled: p, dir: c } = G(e);
    W(Oe, {
      triggerElement: s,
      onTriggerChange: (m) => {
        s.value = m;
      },
      valueElement: i,
      onValueElementChange: (m) => {
        i.value = m;
      },
      valueElementHasChildren: u,
      onValueElementHasChildrenChange: (m) => {
        u.value = m;
      },
      contentId: te(),
      modelValue: o,
      onValueChange: (m) => {
        o.value = m;
      },
      open: a,
      required: d,
      onOpenChange: (m) => {
        a.value = m;
      },
      dir: c,
      triggerPointerDownPosRef: r,
      disabled: p
    });
    const f = D(
      () => s.value ? !!s.value.closest("form") : !0
    ), v = S(/* @__PURE__ */ new Set()), h = D(() => Array.from(v.value).map((m) => {
      var b;
      return (b = m.props) == null ? void 0 : b.value;
    }).join(";"));
    return W(fs, {
      onNativeOptionAdd: (m) => {
        v.value.add(m);
      },
      onNativeOptionRemove: (m) => {
        v.value.delete(m);
      }
    }), (m, b) => (g(), C(l(Je), null, {
      default: y(() => [
        _(m.$slots, "default"),
        f.value ? (g(), C(Dr, k({ key: h.value }, m.$attrs, {
          "aria-hidden": "",
          tabindex: "-1",
          required: l(d),
          name: m.name,
          autocomplete: m.autocomplete,
          disabled: l(p),
          value: l(o),
          onChange: b[0] || (b[0] = ($) => o.value = $.target.value)
        }), {
          default: y(() => [
            l(o) === void 0 ? (g(), Q("option", xr)) : J("", !0),
            (g(!0), Q(re, null, Xn(Array.from(v.value), ($) => (g(), C(Fe($), k($.props, {
              key: $.key ?? ""
            }), null, 16))), 128))
          ]),
          _: 1
        }, 16, ["required", "name", "autocomplete", "disabled", "value"])) : J("", !0)
      ]),
      _: 3
    }));
  }
}), kr = [" ", "Enter", "ArrowUp", "ArrowDown"], Mr = [" ", "Enter"], Se = 10;
function vs(n) {
  return n === "" || n === void 0;
}
const Oc = /* @__PURE__ */ w({
  __name: "SelectTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(n) {
    const t = n, e = T(Oe), o = D(() => {
      var f;
      return ((f = e == null ? void 0 : e.disabled) == null ? void 0 : f.value) || t.disabled;
    }), { primitiveElement: a, currentElement: s } = H();
    Y(() => {
      e.triggerElement = s;
    });
    const { injectCollection: i } = le(), r = i(), { search: u, handleTypeaheadSearch: d, resetTypeahead: p } = eo(r);
    function c() {
      o.value || (e.onOpenChange(!0), p());
    }
    return (f, v) => (g(), C(l(qe), { "as-child": "" }, {
      default: y(() => {
        var h, m, b, $, O, E, P, B;
        return [
          L(l(M), {
            ref_key: "primitiveElement",
            ref: a,
            role: "combobox",
            type: f.as === "button" ? "button" : void 0,
            "aria-controls": (h = l(e)) == null ? void 0 : h.contentId,
            "aria-expanded": ((m = l(e)) == null ? void 0 : m.open.value) || !1,
            "aria-required": ($ = (b = l(e)) == null ? void 0 : b.required) == null ? void 0 : $.value,
            "aria-autocomplete": "none",
            dir: (O = l(e)) == null ? void 0 : O.dir.value,
            "data-state": (E = l(e)) != null && E.open.value ? "open" : "closed",
            "data-disabled": o.value ? "" : void 0,
            "data-placeholder": l(vs)((B = (P = l(e)) == null ? void 0 : P.modelValue) == null ? void 0 : B.value) ? "" : void 0,
            "as-child": f.asChild,
            as: f.as,
            onClick: v[0] || (v[0] = (I) => {
              var x;
              (x = I == null ? void 0 : I.currentTarget) == null || x.focus();
            }),
            onPointerdown: v[1] || (v[1] = (I) => {
              const x = I.target;
              x.hasPointerCapture(I.pointerId) && x.releasePointerCapture(I.pointerId), I.button === 0 && I.ctrlKey === !1 && (c(), l(e).triggerPointerDownPosRef.value = {
                x: Math.round(I.pageX),
                y: Math.round(I.pageY)
              }, I.preventDefault());
            }),
            onPointerup: v[2] || (v[2] = oe(() => {
            }, ["prevent"])),
            onKeydown: v[3] || (v[3] = (I) => {
              const x = l(u) !== "";
              !(I.ctrlKey || I.altKey || I.metaKey) && I.key.length === 1 && x && I.key === " " || (l(d)(I.key), l(kr).includes(I.key) && (c(), I.preventDefault()));
            })
          }, {
            default: y(() => [
              _(f.$slots, "default")
            ]),
            _: 3
          }, 8, ["type", "aria-controls", "aria-expanded", "aria-required", "dir", "data-state", "data-disabled", "data-placeholder", "as-child", "as"])
        ];
      }),
      _: 3
    }));
  }
}), Sc = /* @__PURE__ */ w({
  __name: "SelectPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(Le), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), bn = Symbol(), Pc = /* @__PURE__ */ w({
  __name: "SelectViewport",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, e = T(xe, yt), o = (e == null ? void 0 : e.position) === "item-aligned" ? T(bn) : void 0, { primitiveElement: a, currentElement: s } = H();
    Y(() => {
      e == null || e.onViewportChange(s.value);
    });
    const i = S(0);
    function r(u) {
      const d = u.currentTarget, { shouldExpandOnScrollRef: p, contentWrapper: c } = o ?? {};
      if (p != null && p.value && (c != null && c.value)) {
        const f = Math.abs(i.value - d.scrollTop);
        if (f > 0) {
          const v = window.innerHeight - Se * 2, h = Number.parseFloat(
            c.value.style.minHeight
          ), m = Number.parseFloat(c.value.style.height), b = Math.max(h, m);
          if (b < v) {
            const $ = b + f, O = Math.min(v, $), E = $ - O;
            c.value.style.height = `${O}px`, c.value.style.bottom === "0px" && (d.scrollTop = E > 0 ? E : 0, c.value.style.justifyContent = "flex-end");
          }
        }
      }
      i.value = d.scrollTop;
    }
    return (u, d) => (g(), Q(re, null, [
      L(l(M), { as: "style" }, {
        default: y(() => [
          de(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-select-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-select-viewport]::-webkit-scrollbar { display: none; } ")
        ]),
        _: 1
      }),
      L(l(M), k({
        ref_key: "primitiveElement",
        ref: a,
        "data-radix-select-viewport": "",
        role: "presentation"
      }, { ...u.$attrs, ...t }, {
        style: {
          // we use position: 'relative' here on the `viewport` so that when we call
          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
          // (independent of the scrollUpButton).
          position: "relative",
          flex: 1,
          overflow: "auto"
        },
        onScroll: r
      }), {
        default: y(() => [
          _(u.$slots, "default")
        ]),
        _: 3
      }, 16, ["style"])
    ], 64));
  }
}), Rr = {
  inheritAttrs: !1
}, Fr = /* @__PURE__ */ w({
  ...Rr,
  __name: "SelectItemAlignedPosition",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["placed"],
  setup(n, { emit: t }) {
    const e = n, { injectCollection: o } = le(), a = T(Oe), s = T(xe), i = o(), r = S(!1), u = S(!0), d = S(), { primitiveElement: p, currentElement: c } = H(), { viewport: f, selectedItem: v, selectedItemText: h, focusSelectedItem: m } = s;
    function b() {
      if (a && a.triggerElement.value && a.valueElement.value && d.value && c.value && (f != null && f.value) && (v != null && v.value) && (h != null && h.value)) {
        const E = a.triggerElement.value.getBoundingClientRect(), P = c.value.getBoundingClientRect(), B = a.valueElement.value.getBoundingClientRect(), I = h.value.getBoundingClientRect();
        if (a.dir.value !== "rtl") {
          const Ke = I.left - P.left, ke = B.left - Ke, He = E.left - ke, We = E.width + He, On = Math.max(We, P.width), Sn = window.innerWidth - Se, Pn = Ko(ke, Se, Sn - On);
          d.value.style.minWidth = `${We}px`, d.value.style.left = `${Pn}px`;
        } else {
          const Ke = P.right - I.right, ke = window.innerWidth - B.right - Ke, He = window.innerWidth - E.right - ke, We = E.width + He, On = Math.max(We, P.width), Sn = window.innerWidth - Se, Pn = Ko(
            ke,
            Se,
            Sn - On
          );
          d.value.style.minWidth = `${We}px`, d.value.style.right = `${Pn}px`;
        }
        const x = i.value, V = window.innerHeight - Se * 2, A = f.value.scrollHeight, R = window.getComputedStyle(c.value), F = Number.parseInt(
          R.borderTopWidth,
          10
        ), U = Number.parseInt(R.paddingTop, 10), z = Number.parseInt(
          R.borderBottomWidth,
          10
        ), j = Number.parseInt(
          R.paddingBottom,
          10
        ), ne = F + U + A + j + z, se = Math.min(
          v.value.offsetHeight * 5,
          ne
        ), Ze = window.getComputedStyle(f.value), gt = Number.parseInt(Ze.paddingTop, 10), Es = Number.parseInt(
          Ze.paddingBottom,
          10
        ), Rt = E.top + E.height / 2 - Se, $s = V - Rt, $n = v.value.offsetHeight / 2, Os = v.value.offsetTop + $n, Ft = F + U + Os, Ss = ne - Ft;
        if (Ft <= Rt) {
          const Ke = v.value === x[x.length - 1];
          d.value.style.bottom = "0px";
          const ke = c.value.clientHeight - f.value.offsetTop - f.value.offsetHeight, He = Math.max(
            $s,
            $n + (Ke ? Es : 0) + ke + z
          ), We = Ft + He;
          d.value.style.height = `${We}px`;
        } else {
          const Ke = v.value === x[0];
          d.value.style.top = "0px";
          const He = Math.max(
            Rt,
            F + f.value.offsetTop + (Ke ? gt : 0) + $n
          ) + Ss;
          d.value.style.height = `${He}px`, f.value.scrollTop = Ft - Rt + f.value.offsetTop;
        }
        d.value.style.margin = `${Se}px 0`, d.value.style.minHeight = `${se}px`, d.value.style.maxHeight = `${V}px`, t("placed"), requestAnimationFrame(() => r.value = !0);
      }
    }
    const $ = S("");
    Y(() => {
      b(), c.value && ($.value = window.getComputedStyle(c.value).zIndex);
    });
    function O(E) {
      E && u.value === !0 && (b(), m == null || m(), u.value = !1);
    }
    return W(bn, {
      contentWrapper: d,
      shouldExpandOnScrollRef: r,
      onScrollButtonChange: O
    }), (E, P) => (g(), Q("div", {
      ref_key: "contentWrapperElement",
      ref: d,
      style: ie({
        display: "flex",
        flexDirection: "column",
        position: "fixed",
        zIndex: $.value
      })
    }, [
      L(l(M), k({
        ref_key: "primitiveElement",
        ref: p,
        style: {
          // When we get the height of the content, it includes borders. If we were to set
          // the height without having `boxSizing: 'border-box'` it would be too big.
          boxSizing: "border-box",
          // We need to ensure the content doesn't get taller than the wrapper
          maxHeight: "100%"
        }
      }, { ...E.$attrs, ...e }), {
        default: y(() => [
          _(E.$slots, "default")
        ]),
        _: 3
      }, 16, ["style"])
    ], 4));
  }
}), Nr = /* @__PURE__ */ w({
  __name: "SelectPopperPosition",
  props: {
    side: {},
    sideOffset: {},
    align: { default: "start" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: { default: Se },
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const e = sn(n);
    return (o, a) => (g(), C(l(ct), k(l(e), { style: {
      // Ensure border-box for floating-ui calculations
      boxSizing: "border-box",
      "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-select-content-available-width": "var(--radix-popper-available-width)",
      "--radix-select-content-available-height": "var(--radix-popper-available-height)",
      "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
    } }), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["style"]));
  }
}), yt = {
  onViewportChange: () => {
  },
  itemTextRefCallback: () => {
  },
  itemRefCallback: () => {
  }
}, xe = Symbol(), Lr = /* @__PURE__ */ w({
  __name: "SelectContentImpl",
  props: {
    position: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(n, { emit: t }) {
    const e = n, o = T(Oe);
    Qn(), Tt(!0);
    const { createCollection: a } = le(), s = S();
    Pt(s);
    const i = a(s), { search: r, handleTypeaheadSearch: u } = eo(i), d = S(), p = S(), c = S(), f = S(!1), v = S(!1);
    function h() {
      p.value && s.value && Kn([p.value, s.value]);
    }
    X(f, () => {
      h();
    });
    const { onOpenChange: m, triggerPointerDownPosRef: b } = o;
    ee((E) => {
      if (!s.value)
        return;
      let P = { x: 0, y: 0 };
      const B = (x) => {
        var V, A;
        P = {
          x: Math.abs(
            Math.round(x.pageX) - (((V = b.value) == null ? void 0 : V.x) ?? 0)
          ),
          y: Math.abs(
            Math.round(x.pageY) - (((A = b.value) == null ? void 0 : A.y) ?? 0)
          )
        };
      }, I = (x) => {
        var V;
        P.x <= 10 && P.y <= 10 ? x.preventDefault() : (V = s.value) != null && V.contains(x.target) || m(!1), document.removeEventListener("pointermove", B), b.value = null;
      };
      b.value !== null && (document.addEventListener("pointermove", B), document.addEventListener("pointerup", I, {
        capture: !0,
        once: !0
      })), E(() => {
        document.removeEventListener("pointermove", B), document.removeEventListener("pointerup", I, {
          capture: !0
        });
      });
    });
    function $(E) {
      const P = E.ctrlKey || E.altKey || E.metaKey;
      if (E.key === "Tab" && E.preventDefault(), !P && E.key.length === 1 && u(E.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(E.key)) {
        let B = i.value;
        if (["ArrowUp", "End"].includes(E.key) && (B = B.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(E.key)) {
          const I = E.target, x = B.indexOf(I);
          B = B.slice(x + 1);
        }
        setTimeout(() => Kn(B)), E.preventDefault();
      }
    }
    const O = D(() => e.position === "popper" ? e : {});
    return W(xe, {
      content: s,
      viewport: d,
      onViewportChange: (E) => {
        d.value = E;
      },
      itemRefCallback: (E, P, B) => {
        var V, A;
        const I = !v.value && !B;
        (((V = o == null ? void 0 : o.modelValue) == null ? void 0 : V.value) !== void 0 && ((A = o == null ? void 0 : o.modelValue) == null ? void 0 : A.value) === P || I) && (p.value = E, I && (v.value = !0));
      },
      selectedItem: p,
      selectedItemText: c,
      onItemLeave: () => {
        var E;
        (E = s.value) == null || E.focus();
      },
      itemTextRefCallback: (E, P, B) => {
        var V, A;
        const I = !v.value && !B;
        (((V = o == null ? void 0 : o.modelValue) == null ? void 0 : V.value) !== void 0 && ((A = o == null ? void 0 : o.modelValue) == null ? void 0 : A.value) === P || I) && (c.value = E);
      },
      focusSelectedItem: h,
      position: e.position,
      isPositioned: f,
      searchRef: r
    }), (E, P) => (g(), C(l(fn), {
      "as-child": "",
      onMountAutoFocus: P[6] || (P[6] = oe(() => {
      }, ["prevent"])),
      onUnmountAutoFocus: P[7] || (P[7] = (B) => {
        var I, x;
        t("closeAutoFocus", B), !B.defaultPrevented && ((x = (I = l(o)) == null ? void 0 : I.triggerElement.value) == null || x.focus({ preventScroll: !0 }), B.preventDefault());
      })
    }, {
      default: y(() => [
        L(l(Ne), {
          "as-child": "",
          "disable-outside-pointer-events": "",
          onFocusOutside: P[2] || (P[2] = oe(() => {
          }, ["prevent"])),
          onDismiss: P[3] || (P[3] = (B) => {
            var I;
            return (I = l(o)) == null ? void 0 : I.onOpenChange(!1);
          }),
          onEscapeKeyDown: P[4] || (P[4] = (B) => t("escapeKeyDown", B)),
          onPointerDownOutside: P[5] || (P[5] = (B) => t("pointerDownOutside", B))
        }, {
          default: y(() => {
            var B, I, x;
            return [
              (g(), C(Fe(
                E.position === "popper" ? Nr : Fr
              ), k({ ...E.$attrs, ...O.value }, {
                id: (B = l(o)) == null ? void 0 : B.contentId,
                ref: (V) => {
                  s.value = l(ye)(V);
                },
                role: "listbox",
                "data-state": (I = l(o)) != null && I.open.value ? "open" : "closed",
                dir: (x = l(o)) == null ? void 0 : x.dir.value,
                style: {
                  // flex layout so we can place the scroll buttons properly
                  display: "flex",
                  flexDirection: "column",
                  // reset the outline by default as the content MAY get focused
                  outline: "none"
                },
                onContextmenu: P[0] || (P[0] = oe(() => {
                }, ["prevent"])),
                onPlaced: P[1] || (P[1] = (V) => f.value = !0),
                onKeydown: $
              }), {
                default: y(() => [
                  _(E.$slots, "default")
                ]),
                _: 3
              }, 16, ["id", "data-state", "dir"]))
            ];
          }),
          _: 3
        })
      ]),
      _: 3
    }));
  }
}), Vr = /* @__PURE__ */ w({
  __name: "SelectProvider",
  props: {
    context: {}
  },
  setup(n) {
    return W(Oe, n.context), (e, o) => _(e.$slots, "default");
  }
}), Kr = {
  inheritAttrs: !1
}, Tc = /* @__PURE__ */ w({
  ...Kr,
  __name: "SelectContent",
  props: {
    position: { default: "item-aligned" },
    side: {},
    sideOffset: {},
    align: { default: "start" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(n, { emit: t }) {
    const o = fe(n, t), a = T(Oe), s = S();
    Y(() => {
      s.value = new DocumentFragment();
    });
    const i = S();
    return (r, u) => {
      var d;
      return g(), Q(re, null, [
        L(l(ce), {
          ref_key: "presenceRef",
          ref: i,
          present: l(a).open.value
        }, {
          default: y(() => [
            L(Lr, N(K({ ...l(o), ...r.$attrs })), {
              default: y(() => [
                _(r.$slots, "default")
              ]),
              _: 3
            }, 16)
          ]),
          _: 3
        }, 8, ["present"]),
        !((d = i.value) != null && d.present) && s.value ? (g(), C(lt, {
          key: 0,
          to: s.value
        }, [
          L(Vr, {
            context: l(a)
          }, {
            default: y(() => [
              St("div", null, [
                _(r.$slots, "default")
              ])
            ]),
            _: 3
          }, 8, ["context"])
        ], 8, ["to"])) : J("", !0)
      ], 64);
    };
  }
}), Bc = /* @__PURE__ */ w({
  __name: "SelectArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, e = T(Oe), o = T(xe);
    return (a, s) => {
      var i, r;
      return (i = l(e)) != null && i.open.value && ((r = l(o)) == null ? void 0 : r.position) === "popper" ? (g(), C(l(pt), N(k({ key: 0 }, t)), {
        default: y(() => [
          _(a.$slots, "default")
        ]),
        _: 3
      }, 16)) : J("", !0);
    };
  }
}), Ac = /* @__PURE__ */ w({
  __name: "SelectSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(M), k({ "aria-hidden": "" }, t), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), No = Symbol(), Ic = /* @__PURE__ */ w({
  __name: "SelectItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, { disabled: e } = G(t), o = T(Oe), a = T(xe, yt), { primitiveElement: s, currentElement: i } = H(), r = D(() => {
      var m;
      return ((m = o == null ? void 0 : o.modelValue) == null ? void 0 : m.value) === t.value;
    }), u = S(!1), d = S(t.textValue ?? ""), p = te();
    async function c(m) {
      await Z(), !(m != null && m.defaultPrevented) && (e.value || (o.onValueChange(t.value), o.onOpenChange(!1)));
    }
    async function f(m) {
      var b;
      await Z(), !m.defaultPrevented && (e.value ? (b = a.onItemLeave) == null || b.call(a) : m.currentTarget.focus({ preventScroll: !0 }));
    }
    async function v(m) {
      var b;
      await Z(), !m.defaultPrevented && m.currentTarget === document.activeElement && ((b = a.onItemLeave) == null || b.call(a));
    }
    async function h(m) {
      var $;
      await Z(), !(m.defaultPrevented || (($ = a.searchRef) == null ? void 0 : $.value) !== "" && m.key === " ") && (Mr.includes(m.key) && c(), m.key === " " && m.preventDefault());
    }
    if (t.value === "")
      throw new Error(
        "A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return Y(() => {
      i.value && (a == null || a.itemRefCallback(
        i.value,
        t.value,
        t.disabled
      ));
    }), W(No, {
      value: t.value,
      disabled: e,
      textId: p,
      isSelected: r,
      onItemTextChange: (m) => {
        d.value = ((d.value || (m == null ? void 0 : m.textContent)) ?? "").trim();
      }
    }), (m, b) => (g(), C(l(M), {
      ref_key: "primitiveElement",
      ref: s,
      role: "option",
      "data-radix-vue-collection-item": "",
      "aria-labelledby": l(p),
      "data-highlighted": u.value ? "" : void 0,
      "aria-selected": r.value && u.value,
      "data-state": r.value ? "checked" : "unchecked",
      "aria-disabled": l(e) || void 0,
      "data-disabled": l(e) ? "" : void 0,
      tabindex: l(e) ? void 0 : -1,
      as: m.as,
      "as-child": m.asChild,
      onFocus: b[0] || (b[0] = ($) => u.value = !0),
      onBlur: b[1] || (b[1] = ($) => u.value = !1),
      onPointerup: c,
      onPointermove: f,
      onPointerleave: v,
      onKeydown: h
    }, {
      default: y(() => [
        _(m.$slots, "default")
      ]),
      _: 3
    }, 8, ["aria-labelledby", "data-highlighted", "aria-selected", "data-state", "aria-disabled", "data-disabled", "tabindex", "as", "as-child"]));
  }
}), Dc = /* @__PURE__ */ w({
  __name: "SelectItemIndicator",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(n) {
    const t = n, e = T(No);
    return (o, a) => {
      var s;
      return (s = l(e)) != null && s.isSelected.value ? (g(), C(l(M), k({
        key: 0,
        "aria-hidden": ""
      }, t), {
        default: y(() => [
          _(o.$slots, "default")
        ]),
        _: 3
      }, 16)) : J("", !0);
    };
  }
}), ms = Symbol(), xc = /* @__PURE__ */ w({
  __name: "SelectGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, e = te();
    return W(ms, {
      id: e
    }), (o, a) => (g(), C(l(M), k({ role: "group" }, t, { "aria-labelledby": l(e) }), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-labelledby"]));
  }
}), kc = /* @__PURE__ */ w({
  __name: "SelectLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: { default: "label" }
  },
  setup(n) {
    const t = n, e = T(ms, {
      id: ""
    });
    return (o, a) => (g(), C(l(M), k(t, {
      id: l(e).id
    }), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16, ["id"]));
  }
}), Hr = {
  inheritAttrs: !1
}, Mc = /* @__PURE__ */ w({
  ...Hr,
  __name: "SelectItemText",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(n) {
    const t = n, e = T(Oe), o = T(xe, yt), a = T(fs), s = T(No), { primitiveElement: i, currentElement: r } = H(), u = D(() => {
      var c;
      return Gt("option", {
        key: s == null ? void 0 : s.value,
        value: s == null ? void 0 : s.value,
        disabled: s == null ? void 0 : s.disabled.value,
        innerHTML: (c = r.value) == null ? void 0 : c.textContent
      });
    }), { onNativeOptionAdd: d, onNativeOptionRemove: p } = a;
    return Y(() => {
      r.value && (s == null || s.onItemTextChange(r.value), o == null || o.itemTextRefCallback(
        r.value,
        s.value,
        s.disabled.value
      ), d(u.value));
    }), (c, f) => {
      var v, h, m, b;
      return g(), Q(re, null, [
        L(l(M), k({
          id: (v = l(s)) == null ? void 0 : v.textId,
          ref_key: "primitiveElement",
          ref: i
        }, { ...t, ...c.$attrs }), {
          default: y(() => [
            _(c.$slots, "default")
          ]),
          _: 3
        }, 16, ["id"]),
        (h = l(s)) != null && h.isSelected.value && ((m = l(e)) != null && m.valueElement.value) && !l(e).valueElementHasChildren.value ? (g(), C(lt, {
          key: 0,
          to: (b = l(e)) == null ? void 0 : b.valueElement.value
        }, [
          _(c.$slots, "default")
        ], 8, ["to"])) : J("", !0)
      ], 64);
    };
  }
}), hs = /* @__PURE__ */ w({
  __name: "SelectScrollButtonImpl",
  emits: ["autoScroll"],
  setup(n, { emit: t }) {
    const { injectCollection: e } = le(), o = e(), a = T(xe, yt), s = S(null);
    function i() {
      s.value !== null && (window.clearInterval(s.value), s.value = null);
    }
    ee(() => {
      const d = o.value.find(
        (p) => p === document.activeElement
      );
      d == null || d.scrollIntoView({ block: "nearest" });
    });
    function r() {
      s.value === null && (s.value = window.setInterval(() => {
        t("autoScroll");
      }, 50));
    }
    function u() {
      var d;
      (d = a.onItemLeave) == null || d.call(a), s.value === null && (s.value = window.setInterval(() => {
        t("autoScroll");
      }, 50));
    }
    return da(() => i()), (d, p) => {
      var c;
      return g(), C(l(M), k({
        "aria-hidden": "",
        style: {
          flexShrink: 0
        }
      }, (c = d.$parent) == null ? void 0 : c.$props, {
        onPointerdown: r,
        onPointermove: u,
        onPointerleave: p[0] || (p[0] = () => {
          i();
        })
      }), {
        default: y(() => [
          _(d.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
}), Rc = /* @__PURE__ */ w({
  __name: "SelectScrollUpButton",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = T(xe, yt), e = t.position === "item-aligned" ? T(bn) : void 0, { primitiveElement: o, currentElement: a } = H(), s = S(!1);
    return ee((i) => {
      var r, u;
      if ((r = t.viewport) != null && r.value && ((u = t.isPositioned) != null && u.value)) {
        let d = function() {
          s.value = p.scrollTop > 0;
        };
        const p = t.viewport.value;
        d(), p.addEventListener("scroll", d), i(() => p.removeEventListener("scroll", d));
      }
    }), X(a, () => {
      a.value && (e == null || e.onScrollButtonChange(a.value));
    }), (i, r) => s.value ? (g(), C(hs, {
      key: 0,
      ref_key: "primitiveElement",
      ref: o,
      onAutoScroll: r[0] || (r[0] = () => {
        const { viewport: u, selectedItem: d } = l(t);
        u != null && u.value && (d != null && d.value) && (u.value.scrollTop = u.value.scrollTop - d.value.offsetHeight);
      })
    }, {
      default: y(() => [
        _(i.$slots, "default")
      ]),
      _: 3
    }, 512)) : J("", !0);
  }
}), Fc = /* @__PURE__ */ w({
  __name: "SelectScrollDownButton",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = T(xe, yt), e = t.position === "item-aligned" ? T(bn) : void 0, { primitiveElement: o, currentElement: a } = H(), s = S(!1);
    return ee((i) => {
      var r, u;
      if ((r = t.viewport) != null && r.value && ((u = t.isPositioned) != null && u.value)) {
        let d = function() {
          const c = p.scrollHeight - p.clientHeight;
          s.value = Math.ceil(p.scrollTop) < c;
        };
        const p = t.viewport.value;
        d(), p.addEventListener("scroll", d), i(() => p.removeEventListener("scroll", d));
      }
    }), X(a, () => {
      a.value && (e == null || e.onScrollButtonChange(a.value));
    }), (i, r) => s.value ? (g(), C(hs, {
      key: 0,
      ref_key: "primitiveElement",
      ref: o,
      onAutoScroll: r[0] || (r[0] = () => {
        const { viewport: u, selectedItem: d } = l(t);
        u != null && u.value && (d != null && d.value) && (u.value.scrollTop = u.value.scrollTop + d.value.offsetHeight);
      })
    }, {
      default: y(() => [
        _(i.$slots, "default")
      ]),
      _: 3
    }, 512)) : J("", !0);
  }
}), Nc = /* @__PURE__ */ w({
  __name: "SelectValue",
  props: {
    placeholder: { default: "" },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(n) {
    const { primitiveElement: t, currentElement: e } = H(), o = T(Oe), a = Gn();
    return fa(() => {
      var i;
      const s = !!ln((i = a == null ? void 0 : a.default) == null ? void 0 : i.call(a)).length;
      o.onValueElementHasChildrenChange(s);
    }), Y(() => {
      o.valueElement = e;
    }), (s, i) => (g(), C(l(M), {
      ref_key: "primitiveElement",
      ref: t,
      as: s.as,
      "as-child": s.asChild,
      style: { pointerEvents: "none" }
    }, {
      default: y(() => {
        var r, u;
        return [
          l(vs)((u = (r = l(o)) == null ? void 0 : r.modelValue) == null ? void 0 : u.value) ? (g(), Q(re, { key: 0 }, [
            de(st(s.placeholder), 1)
          ], 64)) : _(s.$slots, "default", { key: 1 })
        ];
      }),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), Lc = /* @__PURE__ */ w({
  __name: "SelectIcon",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(n) {
    return (t, e) => (g(), C(l(M), {
      "aria-hidden": "",
      as: t.as,
      "as-child": t.asChild
    }, {
      default: y(() => [
        _(t.$slots, "default", {}, () => [
          de("")
        ])
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), xt = Symbol(), Vc = /* @__PURE__ */ w({
  __name: "MenubarRoot",
  props: {
    modelValue: {},
    defaultValue: {},
    dir: { default: "ltr" },
    loop: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(n, { emit: t }) {
    const e = n, { primitiveElement: o, currentElement: a } = H(), { createCollection: s } = le("menubar");
    s(a);
    const i = q(e, "modelValue", t, {
      passive: !0,
      defaultValue: e.defaultValue ?? ""
    }), r = S(null), { dir: u, loop: d } = G(e);
    return W(xt, {
      modelValue: i,
      dir: u,
      loop: d,
      onMenuOpen: (p) => {
        i.value = p, r.value = p;
      },
      onMenuClose: () => {
        i.value = "";
      },
      onMenuToggle: (p) => {
        i.value = i.value ? "" : p, r.value = p;
      }
    }), (p, c) => (g(), C(l(vt), {
      "current-tab-stop-id": r.value,
      "onUpdate:currentTabStopId": c[0] || (c[0] = (f) => r.value = f),
      orientation: "horizontal",
      loop: l(d),
      dir: l(u),
      "as-child": ""
    }, {
      default: y(() => [
        L(l(M), {
          ref_key: "primitiveElement",
          ref: o,
          role: "menubar"
        }, {
          default: y(() => [
            _(p.$slots, "default")
          ]),
          _: 3
        }, 512)
      ]),
      _: 3
    }, 8, ["current-tab-stop-id", "loop", "dir"]));
  }
}), _n = Symbol(), Kc = /* @__PURE__ */ w({
  __name: "MenubarMenu",
  props: {
    value: {}
  },
  setup(n) {
    const e = n.value ?? te(), o = T(xt), a = S(), s = S(!1), i = D(() => (o == null ? void 0 : o.modelValue.value) === e);
    return X(i, () => {
      i.value || (s.value = !1);
    }), W(_n, {
      value: e,
      triggerElement: a,
      triggerId: e,
      contentId: te(),
      wasKeyboardTriggerOpenRef: s
    }), (r, u) => {
      var d;
      return g(), C(l(wo), {
        open: i.value,
        modal: !1,
        dir: (d = l(o)) == null ? void 0 : d.dir.value,
        "onUpdate:open": u[0] || (u[0] = (p) => {
          var c;
          p || (c = l(o)) == null || c.onMenuClose();
        })
      }, {
        default: y(() => [
          _(r.$slots, "default")
        ]),
        _: 3
      }, 8, ["open", "dir"]);
    };
  }
}), Hc = /* @__PURE__ */ w({
  __name: "MenubarTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(n) {
    const t = T(xt), e = T(_n), { primitiveElement: o, currentElement: a } = H(), s = S(!1), i = D(() => (t == null ? void 0 : t.modelValue.value) === (e == null ? void 0 : e.value));
    return Y(() => {
      e.triggerElement = a;
    }), (r, u) => {
      var d;
      return g(), C(l(mt), {
        "as-child": "",
        focusable: !r.disabled,
        "tab-stop-id": (d = l(e)) == null ? void 0 : d.value
      }, {
        default: y(() => [
          L(l(hn), { "as-child": "" }, {
            default: y(() => {
              var p, c, f;
              return [
                L(l(M), {
                  id: (p = l(e)) == null ? void 0 : p.triggerId,
                  ref_key: "primitiveElement",
                  ref: o,
                  as: r.as,
                  type: r.as === "button" ? "button" : void 0,
                  role: "menuitem",
                  "aria-haspopup": "menu",
                  "aria-expanded": i.value,
                  "aria-controls": i.value ? (c = l(e)) == null ? void 0 : c.contentId : void 0,
                  "data-highlighted": s.value ? "" : void 0,
                  "data-state": i.value ? "open" : "closed",
                  "data-disabled": r.disabled ? "" : void 0,
                  disabled: r.disabled,
                  "data-value": (f = l(e)) == null ? void 0 : f.value,
                  "data-radix-vue-collection-item": "",
                  onPointerdown: u[0] || (u[0] = (v) => {
                    !r.disabled && v.button === 0 && v.ctrlKey === !1 && (l(t).onMenuOpen(l(e).value), i.value || v.preventDefault());
                  }),
                  onPointerenter: u[1] || (u[1] = () => {
                    var h;
                    !!l(t).modelValue.value && !i.value && (l(t).onMenuOpen(l(e).value), (h = l(a)) == null || h.focus());
                  }),
                  onKeydown: u[2] || (u[2] = pe((v) => {
                    var h, m;
                    r.disabled || (["Enter", " "].includes(v.key) && ((h = l(t)) == null || h.onMenuToggle(l(e).value)), v.key === "ArrowDown" && ((m = l(t)) == null || m.onMenuOpen(l(e).value)), ["Enter", " ", "ArrowDown"].includes(v.key) && (l(e).wasKeyboardTriggerOpenRef.value = !0, v.preventDefault()));
                  }, ["enter", "space", "arrow-down"])),
                  onFocus: u[3] || (u[3] = (v) => s.value = !0),
                  onBlur: u[4] || (u[4] = (v) => s.value = !1)
                }, {
                  default: y(() => [
                    _(r.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["id", "as", "type", "aria-expanded", "aria-controls", "data-highlighted", "data-state", "data-disabled", "disabled", "data-value"])
              ];
            }),
            _: 3
          })
        ]),
        _: 3
      }, 8, ["focusable", "tab-stop-id"]);
    };
  }
}), Wc = /* @__PURE__ */ w({
  __name: "MenubarPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(To), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Uc = /* @__PURE__ */ w({
  __name: "MenubarContent",
  props: {
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: { default: "start" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(n, { emit: t }) {
    const o = fe(n, t), a = T(xt), s = T(_n), { injectCollection: i } = le("menubar"), r = i(), u = S(!1);
    function d(p) {
      const f = p.target.hasAttribute(
        "data-radix-menubar-subtrigger"
      ), h = ((a == null ? void 0 : a.dir.value) === "rtl" ? "ArrowRight" : "ArrowLeft") === p.key;
      if (!h && f)
        return;
      let b = r.value.map((E) => E.dataset.value);
      h && b.reverse();
      const $ = b.indexOf(s == null ? void 0 : s.value);
      b = a != null && a.loop.value ? to(b, $ + 1) : b.slice($ + 1);
      const [O] = b;
      O && (a == null || a.onMenuOpen(O));
    }
    return (p, c) => {
      var f, v;
      return g(), C(l(So), k({
        id: (f = l(s)) == null ? void 0 : f.contentId,
        "aria-labelledby": (v = l(s)) == null ? void 0 : v.triggerId,
        "data-radix-menubar-content": ""
      }, l(o), {
        style: {
          "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
          "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
          "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
        },
        onCloseAutoFocus: c[0] || (c[0] = (h) => {
          var b, $;
          !!!((b = l(a)) != null && b.modelValue.value) && !u.value && (($ = l(s).triggerElement.value) == null || $.focus()), u.value = !1, h.preventDefault();
        }),
        onFocusOutside: c[1] || (c[1] = (h) => {
          const m = h.target;
          l(r).some(($) => $.contains(m)) && h.preventDefault();
        }),
        onInteractOutside: c[2] || (c[2] = (h) => {
          u.value = !0;
        }),
        onOpenAutoFocus: c[3] || (c[3] = (h) => {
          var m;
          (m = l(s)) != null && m.wasKeyboardTriggerOpenRef.value || h.preventDefault();
        }),
        onEntryFocus: c[4] || (c[4] = (h) => {
          var m;
          (m = l(s)) != null && m.wasKeyboardTriggerOpenRef.value || h.preventDefault();
        }),
        onKeydown: pe(d, ["arrow-right", "arrow-left"])
      }), {
        default: y(() => [
          _(p.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "aria-labelledby", "style", "onKeydown"]);
    };
  }
}), zc = /* @__PURE__ */ w({
  __name: "MenubarArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(_o), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Yc = /* @__PURE__ */ w({
  __name: "MenubarItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(n, { emit: t }) {
    const e = n, o = ae(t);
    return (a, s) => (g(), C(l(Dt), N(K({ ...e, ...l(o) })), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Gc = /* @__PURE__ */ w({
  __name: "MenubarGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(gn), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Xc = /* @__PURE__ */ w({
  __name: "MenubarSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(Io), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Jc = /* @__PURE__ */ w({
  __name: "MenubarCheckboxItem",
  props: {
    checked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:checked"],
  setup(n, { emit: t }) {
    const e = n, o = ae(t);
    return (a, s) => (g(), C(l(Oo), N(K({ ...e, ...l(o) })), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), qc = /* @__PURE__ */ w({
  __name: "MenubarItemIndicator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l($o), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), jc = /* @__PURE__ */ w({
  __name: "MenubarLabel",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(Po), N(K(t)), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Zc = /* @__PURE__ */ w({
  __name: "MenubarRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(n, { emit: t }) {
    const e = n, o = ae(t);
    return (a, s) => (g(), C(l(Bo), N(K({ ...e, ...l(o) })), {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Qc = /* @__PURE__ */ w({
  __name: "MenubarRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(n, { emit: t }) {
    const e = n;
    return (o, a) => (g(), C(l(Ao), N(K({ ...e, ...t })), {
      default: y(() => [
        _(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ep = /* @__PURE__ */ w({
  __name: "MenubarSub",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean }
  },
  emits: ["update:open"],
  setup(n, { emit: t }) {
    const e = n, o = q(e, "open", t, {
      passive: !0,
      defaultValue: e.defaultOpen ?? !1
    });
    return (a, s) => (g(), C(l(xo), {
      open: l(o),
      "onUpdate:open": s[0] || (s[0] = (i) => it(o) ? o.value = i : null)
    }, {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["open"]));
  }
}), tp = /* @__PURE__ */ w({
  __name: "MenubarSubContent",
  props: {
    loop: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    disableOutsideScroll: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(n, { emit: t }) {
    const o = fe(n, t), { injectCollection: a } = le("menubar"), s = T(xt), i = T(_n), r = a();
    function u(d) {
      if (d.target.hasAttribute(
        "data-radix-menubar-subtrigger"
      ))
        return;
      let f = r.value.map((m) => m.dataset.value);
      const v = f.indexOf(i == null ? void 0 : i.value);
      f = s != null && s.loop.value ? to(f, v + 1) : f.slice(v + 1);
      const [h] = f;
      h && (s == null || s.onMenuOpen(h));
    }
    return (d, p) => (g(), C(l(ko), k(l(o), {
      "data-radix-menubar-content": "",
      style: {
        "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
        "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
        "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
      },
      onKeydown: pe(u, ["arrow-right"])
    }), {
      default: y(() => [
        _(d.$slots, "default")
      ]),
      _: 3
    }, 16, ["style", "onKeydown"]));
  }
}), np = /* @__PURE__ */ w({
  __name: "MenubarSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n;
    return (e, o) => (g(), C(l(Mo), k({ "data-radix-menubar-subtrigger": "" }, t), {
      default: y(() => [
        _(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), we = Symbol(), op = /* @__PURE__ */ w({
  __name: "NavigationMenuRoot",
  props: {
    modelValue: { default: void 0 },
    defaultValue: {},
    dir: { default: "ltr" },
    orientation: { default: "horizontal" },
    delayDuration: { default: 200 },
    skipDelayDuration: { default: 300 },
    asChild: { type: Boolean },
    as: { default: "nav" }
  },
  emits: ["update:modelValue"],
  setup(n, { emit: t }) {
    const e = n, o = q(e, "modelValue", t, {
      passive: !0,
      defaultValue: e.defaultValue ?? ""
    }), a = S(""), { primitiveElement: s, currentElement: i } = H(), r = S(), u = S(), { createCollection: d } = le("nav");
    d(r);
    const { delayDuration: p, skipDelayDuration: c } = G(e), f = ma(!1, c), v = D(() => o.value !== "" || f.value ? 150 : p.value), h = qn((m) => {
      a.value = o.value, o.value = m;
    }, v);
    return W(we, {
      isRootMenu: !0,
      modelValue: o,
      previousValue: a,
      baseId: te(),
      dir: e.dir,
      orientation: e.orientation,
      rootNavigationMenu: i,
      indicatorTrack: r,
      onIndicatorTrackChange: (m) => {
        r.value = m;
      },
      viewport: u,
      onViewportChange: (m) => {
        u.value = m;
      },
      onTriggerEnter: (m) => {
        h(m);
      },
      onTriggerLeave: () => {
        f.value = !0, h("");
      },
      onContentEnter: (m) => {
        h(m);
      },
      onContentLeave: () => {
        h("");
      },
      onItemSelect: (m) => {
        a.value = o.value, o.value = m;
      },
      onItemDismiss: () => {
        a.value = o.value, o.value = "";
      }
    }), (m, b) => (g(), C(l(M), {
      ref_key: "primitiveElement",
      ref: s,
      "aria-label": "Main",
      as: m.as,
      "as-child": m.asChild,
      "data-orientation": m.orientation,
      dir: m.dir
    }, {
      default: y(() => [
        _(m.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-orientation", "dir"]));
  }
});
function wn(n) {
  return n ? "open" : "closed";
}
function ys(n, t) {
  return `${n}-trigger-${t}`;
}
function Lo(n, t) {
  return `${n}-content-${t}`;
}
const Yt = "navigationMenu.rootContentDismiss";
function Un(n) {
  const t = [], e = document.createTreeWalker(n, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (o) => {
      const a = o.tagName === "INPUT" && o.type === "hidden";
      return o.disabled || o.hidden || a ? NodeFilter.FILTER_SKIP : o.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; e.nextNode(); )
    t.push(e.currentNode);
  return t;
}
function gs(n) {
  const t = document.activeElement;
  return n.some((e) => e === t ? !0 : (e.focus(), document.activeElement !== t));
}
function Wr(n) {
  return n.forEach((t) => {
    t.dataset.tabindex = t.getAttribute("tabindex") || "", t.setAttribute("tabindex", "-1");
  }), () => {
    n.forEach((t) => {
      const e = t.dataset.tabindex;
      t.setAttribute("tabindex", e);
    });
  };
}
const Cn = Symbol(), ap = /* @__PURE__ */ w({
  __name: "NavigationMenuItem",
  props: {
    value: {},
    asChild: { type: Boolean },
    as: { default: "li" }
  },
  setup(n) {
    const t = n, { injectCollection: e } = le("nav"), o = e(), a = T(we), s = t.value || te(), i = S(), r = S(), u = Lo(a.baseId, s);
    let d = () => ({});
    const p = S(!1);
    async function c(m = "start") {
      const b = document.getElementById(u);
      if (b) {
        d();
        const $ = Un(b);
        $.length && gs(m === "start" ? $ : $.reverse());
      }
    }
    function f() {
      const m = document.getElementById(u);
      if (m) {
        const b = Un(m);
        b.length && (d = Wr(b));
      }
    }
    W(Cn, {
      value: s,
      contentId: u,
      triggerRef: i,
      focusProxyRef: r,
      wasEscapeCloseRef: p,
      onEntryKeyDown: c,
      onFocusProxyEnter: c,
      onContentFocusOutside: f,
      onRootContentClose: f
    });
    function v() {
      var m;
      a == null || a.onItemDismiss(), (m = i.value) == null || m.focus();
    }
    function h(m) {
      const b = document.activeElement;
      if (m.keyCode === 32 || m.key === "Enter")
        if ((a == null ? void 0 : a.modelValue.value) === s) {
          v(), m.preventDefault();
          return;
        } else {
          m.target.click(), m.preventDefault();
          return;
        }
      const $ = o.value.filter(
        (E) => {
          var P;
          return (P = E.parentElement) == null ? void 0 : P.hasAttribute("data-menu-item");
        }
      ), O = an(m, b, void 0, {
        itemsArray: $,
        loop: !1
      });
      O && (O == null || O.focus()), m.preventDefault(), m.stopPropagation();
    }
    return (m, b) => (g(), C(l(M), {
      "as-child": t.asChild,
      as: m.as,
      "data-menu-item": "",
      onKeydown: pe(h, ["up", "down", "left", "right", "home", "end", "space"])
    }, {
      default: y(() => [
        _(m.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "onKeydown"]));
  }
}), Ur = /* @__PURE__ */ w({
  __name: "NavigationMenuContentImpl",
  props: {
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(n, { emit: t }) {
    const e = n, { injectCollection: o } = le("nav"), a = o(), { primitiveElement: s, currentElement: i } = H(), r = T(we), u = T(Cn), d = ys(r.baseId, u.value), p = Lo(r.baseId, u.value), c = S(null), f = D(() => {
      const E = a.value.map((A) => A.id.split("trigger-")[1]);
      (r == null ? void 0 : r.dir) === "rtl" && E.reverse();
      const P = E.indexOf(r.modelValue.value), B = E.indexOf(r.previousValue.value), I = u.value === (r == null ? void 0 : r.modelValue.value), x = B === E.indexOf(u.value);
      if (!I && !x)
        return c.value;
      const V = (() => {
        if (P !== B) {
          if (I && B !== -1)
            return P > B ? "from-end" : "from-start";
          if (x && P !== -1)
            return P > B ? "to-start" : "to-end";
        }
        return null;
      })();
      return c.value = V, V;
    });
    function v(O) {
      var E, P;
      if (t("focusOutside", O), t("interactOutside", O), !O.defaultPrevented) {
        u.onContentFocusOutside();
        const B = O.target;
        (P = (E = r.rootNavigationMenu) == null ? void 0 : E.value) != null && P.contains(B) && O.preventDefault();
      }
    }
    function h(O) {
      var E;
      if (t("pointerDownOutside", O), !O.defaultPrevented) {
        const P = O.target, B = a.value.some(
          (x) => x.contains(P)
        ), I = (r == null ? void 0 : r.isRootMenu) && ((E = r.viewport.value) == null ? void 0 : E.contains(P));
        (B || I || !(r != null && r.isRootMenu)) && O.preventDefault();
      }
    }
    ee((O) => {
      const E = i.value;
      if (r != null && r.isRootMenu && E) {
        const P = () => {
          var B;
          u.onRootContentClose(), E.contains(document.activeElement) && ((B = u.triggerRef.value) == null || B.focus());
        };
        E.addEventListener(Yt, P), O(
          () => E.removeEventListener(Yt, P)
        );
      }
    });
    function m(O) {
      var E, P;
      t("escapeKeyDown", O), O.defaultPrevented || (r.onItemDismiss(), (P = (E = u.triggerRef) == null ? void 0 : E.value) == null || P.focus(), u.wasEscapeCloseRef.value = !0);
    }
    function b(O) {
      var x;
      const E = O.altKey || O.ctrlKey || O.metaKey, P = O.key === "Tab" && !E, B = Un(O.currentTarget);
      if (P) {
        const V = document.activeElement, A = B.findIndex(
          (U) => U === V
        ), F = O.shiftKey ? B.slice(0, A).reverse() : B.slice(A + 1, B.length);
        if (gs(F))
          O.preventDefault();
        else {
          (x = u.focusProxyRef.value) == null || x.focus();
          return;
        }
      }
      const I = an(
        O,
        document.activeElement,
        void 0,
        { itemsArray: B, loop: !1 }
      );
      I == null || I.focus(), !(O.key === "Enter" || O.key === "Escape") && (O.preventDefault(), O.stopPropagation());
    }
    function $() {
      var E;
      const O = new Event(Yt, {
        bubbles: !0,
        cancelable: !0
      });
      (E = i.value) == null || E.dispatchEvent(O);
    }
    return (O, E) => {
      var P, B;
      return g(), C(l(Ne), k({
        id: l(p),
        ref_key: "primitiveElement",
        ref: s,
        "aria-labelledby": l(d),
        "data-motion": f.value,
        "data-state": l(wn)(((P = l(r)) == null ? void 0 : P.modelValue.value) === l(u).value),
        "data-orientation": (B = l(r)) == null ? void 0 : B.orientation
      }, e, {
        onKeydown: b,
        onEscapeKeyDown: m,
        onPointerDownOutside: h,
        onFocusOutside: v,
        onDismiss: $
      }), {
        default: y(() => [
          _(O.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "aria-labelledby", "data-motion", "data-state", "data-orientation"]);
    };
  }
}), zr = {
  inheritAttrs: !1
}, sp = /* @__PURE__ */ w({
  ...zr,
  __name: "NavigationMenuContent",
  props: {
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(n, { emit: t }) {
    const e = n, o = ae(t), a = on(), s = T(we), i = T(Cn), r = D(() => (i == null ? void 0 : i.value) === (s == null ? void 0 : s.modelValue.value)), u = D(() => !(s != null && s.modelValue.value) && (s != null && s.previousValue.value) ? (s == null ? void 0 : s.previousValue.value) === (i == null ? void 0 : i.value) : !1);
    function d(p) {
      t("pointerDownOutside", p), p.preventDefault || s == null || s.onContentLeave();
    }
    return (p, c) => {
      var f, v;
      return l(a) ? (g(), C(lt, {
        key: 0,
        to: (f = l(s)) == null ? void 0 : f.viewport.value,
        disabled: !((v = l(s)) != null && v.viewport.value)
      }, [
        L(l(ce), {
          present: r.value || u.value
        }, {
          default: y(() => {
            var h;
            return [
              L(Ur, k({
                "data-state": l(wn)(r.value),
                style: {
                  pointerEvents: !r.value && ((h = l(s)) != null && h.isRootMenu) ? "none" : void 0
                }
              }, { ...p.$attrs, ...e, ...l(o) }, {
                onPointerenter: c[0] || (c[0] = (m) => {
                  var b;
                  return (b = l(s)) == null ? void 0 : b.onContentEnter(l(i).value);
                }),
                onPointerleave: c[1] || (c[1] = (m) => {
                  var b;
                  return (b = l(s)) == null ? void 0 : b.onContentLeave();
                }),
                onPointerdown: d,
                onFocusOutside: c[2] || (c[2] = (m) => t("focusOutside", m)),
                onInteractOutside: c[3] || (c[3] = (m) => t("interactOutside", m))
              }), {
                default: y(() => [
                  _(p.$slots, "default")
                ]),
                _: 3
              }, 16, ["data-state", "style"])
            ];
          }),
          _: 3
        }, 8, ["present"])
      ], 8, ["to", "disabled"])) : J("", !0);
    };
  }
}), Yr = {
  inheritAttrs: !1
}, lp = /* @__PURE__ */ w({
  ...Yr,
  __name: "NavigationMenuIndicator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, { injectCollection: e } = le("nav"), o = e(), a = T(we), s = S(), i = D(() => (a == null ? void 0 : a.orientation) === "horizontal"), r = D(() => !!(a != null && a.modelValue.value)), u = S();
    function d() {
      u.value && (s.value = {
        size: i.value ? u.value.offsetWidth : u.value.offsetHeight,
        offset: i.value ? u.value.offsetLeft : u.value.offsetTop
      });
    }
    return ee(() => {
      if (!(a != null && a.modelValue.value)) {
        s.value = void 0;
        return;
      }
      const p = o.value;
      u.value = p.find(
        (c) => c.id.includes(a == null ? void 0 : a.modelValue.value)
      ), d();
    }), Be(u, d), Be(a.indicatorTrack, d), (p, c) => {
      var f, v;
      return (f = l(a)) != null && f.indicatorTrack.value ? (g(), C(lt, {
        key: 0,
        to: (v = l(a)) == null ? void 0 : v.indicatorTrack.value
      }, [
        L(l(ce), { present: r.value }, {
          default: y(() => {
            var h, m, b, $;
            return [
              L(l(M), k({
                "aria-hidden": "",
                "data-state": r.value ? "visible" : "hidden",
                "data-orientation": l(a).orientation,
                "as-child": t.asChild,
                as: p.as,
                style: {
                  position: "absolute",
                  ...i.value ? {
                    left: 0,
                    width: `${(h = s.value) == null ? void 0 : h.size}px`,
                    transform: `translateX(${(m = s.value) == null ? void 0 : m.offset}px)`
                  } : {
                    top: 0,
                    height: `${(b = s.value) == null ? void 0 : b.size}px`,
                    transform: `translateY(${($ = s.value) == null ? void 0 : $.offset}px)`
                  }
                }
              }, p.$attrs), {
                default: y(() => [
                  _(p.$slots, "default")
                ]),
                _: 3
              }, 16, ["data-state", "data-orientation", "as-child", "as", "style"])
            ];
          }),
          _: 3
        }, 8, ["present"])
      ], 8, ["to"])) : J("", !0);
    };
  }
}), ip = /* @__PURE__ */ w({
  __name: "NavigationMenuLink",
  props: {
    active: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "a" }
  },
  emits: ["select"],
  setup(n, { emit: t }) {
    const e = n;
    async function o(a) {
      var s;
      if (t("select", a), await Z(), !a.defaultPrevented && !a.metaKey) {
        const i = new CustomEvent(
          Yt,
          {
            bubbles: !0,
            cancelable: !0
          }
        );
        (s = a.target) == null || s.dispatchEvent(i);
      }
    }
    return (a, s) => (g(), C(l(M), {
      as: a.as,
      "data-active": a.active ? "" : void 0,
      "aria-current": a.active ? "page" : void 0,
      "as-child": e.asChild,
      "data-radix-vue-collection-item": "",
      onClick: o
    }, {
      default: y(() => [
        _(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "data-active", "aria-current", "as-child"]));
  }
}), Gr = {
  inheritAttrs: !1
}, rp = /* @__PURE__ */ w({
  ...Gr,
  __name: "NavigationMenuList",
  props: {
    asChild: { type: Boolean },
    as: { default: "ul" }
  },
  setup(n) {
    const t = n, e = T(we), { primitiveElement: o, currentElement: a } = H();
    return Y(() => {
      e == null || e.onIndicatorTrackChange(a.value);
    }), (s, i) => (g(), C(l(M), {
      ref_key: "primitiveElement",
      ref: o,
      style: { position: "relative" }
    }, {
      default: y(() => {
        var r;
        return [
          L(l(M), k(s.$attrs, {
            "as-child": t.asChild,
            as: s.as,
            "data-orientation": (r = l(e)) == null ? void 0 : r.orientation
          }), {
            default: y(() => [
              _(s.$slots, "default")
            ]),
            _: 3
          }, 16, ["as-child", "as", "data-orientation"])
        ];
      }),
      _: 3
    }, 512));
  }
}), up = /* @__PURE__ */ w({
  __name: "NavigationMenuSub",
  props: {
    modelValue: {},
    defaultValue: {},
    orientation: { default: "horizontal" },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(n, { emit: t }) {
    const e = n, o = q(e, "modelValue", t, {
      passive: !0,
      defaultValue: e.defaultValue ?? ""
    }), a = S(""), s = T(we), { primitiveElement: i, currentElement: r } = H(), u = S(), d = S(), { createCollection: p } = le("nav");
    return p(u), W(we, {
      ...s,
      isRootMenu: !1,
      modelValue: o,
      previousValue: a,
      orientation: e.orientation,
      rootNavigationMenu: r,
      indicatorTrack: u,
      onIndicatorTrackChange: (c) => {
        u.value = c;
      },
      viewport: d,
      onViewportChange: (c) => {
        d.value = c;
      },
      onTriggerEnter: (c) => {
        o.value = c;
      },
      onTriggerLeave: () => {
      },
      onContentEnter: () => {
      },
      onContentLeave: () => {
      },
      onItemSelect: (c) => {
        o.value = c;
      },
      onItemDismiss: () => {
        o.value = "";
      }
    }), (c, f) => (g(), C(l(M), {
      ref_key: "primitiveElement",
      ref: i,
      "data-orientation": c.orientation,
      "as-child": e.asChild,
      as: c.as
    }, {
      default: y(() => [
        _(c.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-orientation", "as-child", "as"]));
  }
}), Xr = ["aria-owns"], Jr = {
  inheritAttrs: !1
}, dp = /* @__PURE__ */ w({
  ...Jr,
  __name: "NavigationMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(n) {
    const t = n, e = T(we), o = T(Cn), { primitiveElement: a, currentElement: s } = H(), i = S(""), r = S(""), u = S(!1), d = S(!1), p = D(() => (o == null ? void 0 : o.value) === (e == null ? void 0 : e.modelValue.value));
    Y(() => {
      o.triggerRef = s, i.value = ys(e.baseId, o.value), r.value = Lo(e.baseId, o.value);
    });
    function c() {
      d.value = !1, o.wasEscapeCloseRef.value = !1;
    }
    function f(O) {
      if (O.pointerType === "mouse") {
        if (t.disabled || d.value || o.wasEscapeCloseRef.value || u.value)
          return;
        e.onTriggerEnter(o.value), u.value = !0;
      }
    }
    function v(O) {
      if (O.pointerType === "mouse") {
        if (t.disabled)
          return;
        e.onTriggerLeave(), u.value = !1;
      }
    }
    function h() {
      u.value || (p.value ? e == null || e.onItemSelect("") : e == null || e.onItemSelect(o.value), d.value = p.value);
    }
    function m(O) {
      const P = { horizontal: "ArrowDown", vertical: e.dir === "rtl" ? "ArrowLeft" : "ArrowRight" }[e.orientation];
      p.value && O.key === P && (o.onEntryKeyDown(), O.preventDefault(), O.stopPropagation());
    }
    function b(O) {
      o.focusProxyRef.value = ye(O);
    }
    function $(O) {
      const E = document.getElementById(o.contentId), P = O.relatedTarget, B = P === s.value, I = E == null ? void 0 : E.contains(P);
      (B || !I) && o.onFocusProxyEnter(B ? "start" : "end");
    }
    return (O, E) => {
      var P;
      return g(), Q(re, null, [
        L(l(M), k({
          id: i.value,
          ref_key: "primitiveElement",
          ref: a,
          disabled: O.disabled,
          "data-disabled": O.disabled ? "" : void 0,
          "data-state": l(wn)(p.value),
          "aria-expanded": p.value,
          "aria-controls": r.value,
          "as-child": t.asChild,
          as: O.as
        }, O.$attrs, {
          "data-radix-vue-collection-item": "",
          onPointerenter: c,
          onPointermove: f,
          onPointerleave: v,
          onClick: h,
          onKeydown: m
        }), {
          default: y(() => [
            _(O.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "disabled", "data-disabled", "data-state", "aria-expanded", "aria-controls", "as-child", "as"]),
        p.value ? (g(), Q(re, { key: 0 }, [
          L(l(ft), {
            ref: b,
            "aria-hidden": "",
            tabindex: 0,
            onFocus: $
          }),
          (P = l(e)) != null && P.viewport ? (g(), Q("span", {
            key: 0,
            "aria-owns": r.value
          }, null, 8, Xr)) : J("", !0)
        ], 64)) : J("", !0)
      ], 64);
    };
  }
}), qr = {
  inheritAttrs: !1
}, cp = /* @__PURE__ */ w({
  ...qr,
  __name: "NavigationMenuViewport",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const { primitiveElement: t, currentElement: e } = H(), o = T(we), a = S(), s = D(() => !!(o != null && o.modelValue.value)), i = D(() => o.modelValue.value);
    X(e, () => {
      e.value && o.onViewportChange(e.value);
    });
    const r = S();
    return X([i, s], async () => {
      var d, p;
      if (await Z(), !e.value)
        return;
      const u = (p = (d = e.value.querySelector("[data-state=open]")) == null ? void 0 : d.children) == null ? void 0 : p[0];
      r.value = u;
    }, { immediate: !0 }), Be(r, () => {
      r.value && (a.value = {
        width: r.value.offsetWidth,
        height: r.value.offsetHeight
      });
    }), (u, d) => (g(), C(l(ce), { present: s.value }, {
      default: y(() => {
        var p, c, f, v;
        return [
          L(l(M), k(u.$attrs, {
            ref_key: "primitiveElement",
            ref: t,
            as: u.as,
            "as-child": u.asChild,
            "data-state": l(wn)(s.value),
            "data-orientation": (p = l(o)) == null ? void 0 : p.orientation,
            style: {
              // Prevent interaction when animating out
              pointerEvents: !s.value && ((c = l(o)) != null && c.isRootMenu) ? "none" : void 0,
              ["--radix-navigation-menu-viewport-width"]: a.value ? `${(f = a.value) == null ? void 0 : f.width}px` : void 0,
              ["--radix-navigation-menu-viewport-height"]: a.value ? `${(v = a.value) == null ? void 0 : v.height}px` : void 0
            },
            onPointerenter: d[0] || (d[0] = (h) => {
              var m;
              return (m = l(o)) == null ? void 0 : m.onContentEnter(l(o).modelValue.value);
            }),
            onPointerleave: d[1] || (d[1] = (h) => {
              var m;
              return (m = l(o)) == null ? void 0 : m.onContentLeave();
            })
          }), {
            default: y(() => [
              _(u.$slots, "default")
            ]),
            _: 3
          }, 16, ["as", "as-child", "data-state", "data-orientation", "style"])
        ];
      }),
      _: 3
    }, 8, ["present"]));
  }
}), ve = Symbol(), pp = /* @__PURE__ */ w({
  __name: "ScrollAreaRoot",
  props: {
    type: { default: "hover" },
    dir: { default: "ltr" },
    scrollHideDelay: { default: 600 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, { primitiveElement: e, currentElement: o } = H(), a = S(0), s = S(0), i = S(), r = S(), u = S(), d = S(), p = S(!1), c = S(!1);
    function f(x) {
      i.value = x;
    }
    function v(x) {
      r.value = x;
    }
    function h(x) {
      u.value = x;
    }
    function m(x) {
      d.value = x;
    }
    function b(x) {
      p.value = x;
    }
    function $(x) {
      c.value = x;
    }
    function O(x) {
      a.value = x;
    }
    function E(x) {
      s.value = x;
    }
    const { type: P, dir: B, scrollHideDelay: I } = G(t);
    return W(ve, {
      type: P,
      dir: B,
      scrollHideDelay: I,
      scrollArea: o,
      viewport: i,
      onViewportChange: f,
      content: r,
      onContentChange: v,
      scrollbarX: u,
      scrollbarXEnabled: p,
      scrollbarY: d,
      scrollbarYEnabled: c,
      onScrollbarXChange: h,
      onScrollbarYChange: m,
      onScrollbarXEnabledChange: b,
      onScrollbarYEnabledChange: $,
      onCornerWidthChange: O,
      onCornerHeightChange: E
    }), (x, V) => (g(), C(l(M), {
      ref_key: "primitiveElement",
      ref: e,
      "as-child": t.asChild,
      as: x.as,
      dir: t.dir,
      style: ie({
        position: "relative",
        // Pass corner sizes as CSS vars to reduce re-renders of context consumers
        ["--radix-scroll-area-corner-width"]: `${a.value}px`,
        ["--radix-scroll-area-corner-height"]: `${s.value}px`
      })
    }, {
      default: y(() => [
        _(x.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "dir", "style"]));
  }
}), jr = {
  inheritAttrs: !1
}, fp = /* @__PURE__ */ w({
  ...jr,
  __name: "ScrollAreaViewport",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, e = T(ve), { primitiveElement: o, currentElement: a } = H(), s = S();
    return Y(() => {
      e == null || e.onViewportChange(s.value), e == null || e.onContentChange(a.value);
    }), (i, r) => {
      var u, d;
      return g(), Q(re, null, [
        L(l(M), { as: "style" }, {
          default: y(() => [
            de(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-scroll-area-viewport] { scrollbar-width:none; -ms-overflow-style:none; -webkit-overflow-scrolling:touch; } [data-radix-scroll-area-viewport]::-webkit-scrollbar { display:none; } ")
          ]),
          _: 1
        }),
        St("div", k({
          ref_key: "viewportElement",
          ref: s,
          "data-radix-scroll-area-viewport": "",
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflowed#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: (u = l(e)) != null && u.scrollbarXEnabled.value ? "scroll" : "hidden",
            overflowY: (d = l(e)) != null && d.scrollbarYEnabled.value ? "scroll" : "hidden"
          }
        }, i.$attrs, { tabindex: 0 }), [
          L(l(M), {
            ref_key: "primitiveElement",
            ref: o,
            style: { minWidth: "100%", display: "table" },
            "as-child": t.asChild,
            as: i.as
          }, {
            default: y(() => [
              _(i.$slots, "default")
            ]),
            _: 3
          }, 8, ["as-child", "as"])
        ], 16)
      ], 64);
    };
  }
});
function Zr(n, [t, e]) {
  return Math.min(e, Math.max(t, n));
}
function bs(n, t) {
  return (e) => {
    if (n[0] === n[1] || t[0] === t[1])
      return t[0];
    const o = (t[1] - t[0]) / (n[1] - n[0]);
    return t[0] + o * (e - n[0]);
  };
}
function En(n) {
  const t = _s(n.viewport, n.content), e = n.scrollbar.paddingStart + n.scrollbar.paddingEnd, o = (n.scrollbar.size - e) * t;
  return Math.max(o, 18);
}
function _s(n, t) {
  const e = n / t;
  return Number.isNaN(e) ? 0 : e;
}
function Qr(n, t = () => {
}) {
  let e = { left: n.scrollLeft, top: n.scrollTop }, o = 0;
  return function a() {
    const s = { left: n.scrollLeft, top: n.scrollTop }, i = e.left !== s.left, r = e.top !== s.top;
    (i || r) && t(), e = s, o = window.requestAnimationFrame(a);
  }(), () => window.cancelAnimationFrame(o);
}
function sa(n, t, e = "ltr") {
  const o = En(t), a = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, s = t.scrollbar.size - a, i = t.content - t.viewport, r = s - o, u = e === "ltr" ? [0, i] : [i * -1, 0], d = Zr(
    n,
    u
  );
  return bs([0, i], [0, r])(d);
}
function Ut(n) {
  return n ? Number.parseInt(n, 10) : 0;
}
function eu(n, t, e, o = "ltr") {
  const a = En(e), s = a / 2, i = t || s, r = a - i, u = e.scrollbar.paddingStart + i, d = e.scrollbar.size - e.scrollbar.paddingEnd - r, p = e.content - e.viewport, c = o === "ltr" ? [0, p] : [p * -1, 0];
  return bs(
    [u, d],
    c
  )(n);
}
function la(n, t) {
  return n > 0 && n < t;
}
const ws = /* @__PURE__ */ w({
  __name: "ScrollAreaScrollbarImpl",
  props: {
    isHorizontal: { type: Boolean }
  },
  emits: ["onDragScroll", "onWheelScroll", "onThumbPointerDown"],
  setup(n, { emit: t }) {
    const e = n, o = T(ve), a = T(
      kt
    ), s = T(Mt), { primitiveElement: i, currentElement: r } = H(), u = S(""), d = S();
    function p(b) {
      var $, O;
      if (d.value) {
        const E = b.clientX - (($ = d.value) == null ? void 0 : $.left), P = b.clientY - ((O = d.value) == null ? void 0 : O.top);
        t("onDragScroll", { x: E, y: P });
      }
    }
    function c(b) {
      b.button === 0 && (b.target.setPointerCapture(b.pointerId), d.value = r.value.getBoundingClientRect(), u.value = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", o != null && o.viewport && (o.viewport.value.style.scrollBehavior = "auto"), p(b));
    }
    function f(b) {
      p(b);
    }
    function v(b) {
      const $ = b.target;
      $.hasPointerCapture(b.pointerId) && $.releasePointerCapture(b.pointerId), document.body.style.webkitUserSelect = u.value, o != null && o.viewport && (o.viewport.value.style.scrollBehavior = ""), d.value = void 0;
    }
    function h(b) {
      var P;
      if (!a)
        return;
      const $ = b.target, O = (P = r.value) == null ? void 0 : P.contains($), E = a.sizes.value.content - a.sizes.value.viewport;
      O && a.handleWheelScroll(b, E);
    }
    Y(() => {
      document.addEventListener("wheel", h, { passive: !1 });
    }), ue(() => {
      document.removeEventListener("wheel", h);
    });
    function m() {
      var b, $, O, E, P, B;
      r.value && (e.isHorizontal ? a == null || a.handleSizeChange({
        content: ((b = o == null ? void 0 : o.viewport.value) == null ? void 0 : b.scrollWidth) ?? 0,
        viewport: (($ = o == null ? void 0 : o.viewport.value) == null ? void 0 : $.offsetWidth) ?? 0,
        scrollbar: {
          size: ((O = r.value) == null ? void 0 : O.clientWidth) ?? 0,
          paddingStart: Ut(getComputedStyle(r.value).paddingLeft),
          paddingEnd: Ut(getComputedStyle(r.value).paddingRight)
        }
      }) : a == null || a.handleSizeChange({
        content: ((E = o == null ? void 0 : o.viewport.value) == null ? void 0 : E.scrollHeight) ?? 0,
        viewport: ((P = o == null ? void 0 : o.viewport.value) == null ? void 0 : P.offsetHeight) ?? 0,
        scrollbar: {
          size: ((B = r.value) == null ? void 0 : B.clientHeight) ?? 0,
          paddingStart: Ut(getComputedStyle(r.value).paddingLeft),
          paddingEnd: Ut(getComputedStyle(r.value).paddingRight)
        }
      }));
    }
    return Be(r, m), Be(o == null ? void 0 : o.content, m), (b, $) => {
      var O, E;
      return g(), C(l(M), {
        ref_key: "primitiveElement",
        ref: i,
        style: { position: "absolute" },
        "data-scrollbarimpl": "",
        as: (O = l(s)) == null ? void 0 : O.as.value,
        "as-child": (E = l(s)) == null ? void 0 : E.asChild.value,
        onPointerdown: c,
        onPointermove: f,
        onPointerup: v
      }, {
        default: y(() => [
          _(b.$slots, "default")
        ]),
        _: 3
      }, 8, ["as", "as-child"]);
    };
  }
}), tu = /* @__PURE__ */ w({
  __name: "ScrollAreaScrollbarX",
  setup(n) {
    const t = T(ve), e = T(
      kt
    ), { primitiveElement: o, currentElement: a } = H();
    Y(() => {
      a.value && (t == null || t.onScrollbarXChange(a.value));
    });
    const s = D(() => e == null ? void 0 : e.sizes.value);
    return (i, r) => {
      var u, d, p, c;
      return g(), C(ws, {
        ref_key: "primitiveElement",
        ref: o,
        "is-horizontal": !0,
        "data-orientation": "horizontal",
        style: ie({
          bottom: 0,
          left: ((d = (u = l(t)) == null ? void 0 : u.dir) == null ? void 0 : d.value) === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
          right: ((c = (p = l(t)) == null ? void 0 : p.dir) == null ? void 0 : c.value) === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
          ["--radix-scroll-area-thumb-width"]: s.value ? `${l(En)(s.value)}px` : void 0
        }),
        onOnDragScroll: r[0] || (r[0] = (f) => {
          var v;
          return (v = l(e)) == null ? void 0 : v.onDragScroll(f.x);
        })
      }, {
        default: y(() => [
          _(i.$slots, "default")
        ]),
        _: 3
      }, 8, ["style"]);
    };
  }
}), nu = /* @__PURE__ */ w({
  __name: "ScrollAreaScrollbarY",
  setup(n) {
    const t = T(ve), e = T(
      kt
    ), { primitiveElement: o, currentElement: a } = H();
    Y(() => {
      a.value && (t == null || t.onScrollbarYChange(a.value));
    });
    const s = D(() => e == null ? void 0 : e.sizes.value);
    return (i, r) => {
      var u, d, p, c;
      return g(), C(ws, {
        ref_key: "primitiveElement",
        ref: o,
        "is-horizontal": !1,
        "data-orientation": "vertical",
        style: ie({
          top: 0,
          right: ((d = (u = l(t)) == null ? void 0 : u.dir) == null ? void 0 : d.value) === "ltr" ? 0 : void 0,
          left: ((c = (p = l(t)) == null ? void 0 : p.dir) == null ? void 0 : c.value) === "rtl" ? 0 : void 0,
          bottom: "var(--radix-scroll-area-corner-height)",
          ["--radix-scroll-area-thumb-height"]: s.value ? `${l(En)(s.value)}px` : void 0
        }),
        onOnDragScroll: r[0] || (r[0] = (f) => {
          var v;
          return (v = l(e)) == null ? void 0 : v.onDragScroll(f.y);
        })
      }, {
        default: y(() => [
          _(i.$slots, "default")
        ]),
        _: 3
      }, 8, ["style"]);
    };
  }
}), kt = Symbol(), Vo = /* @__PURE__ */ w({
  __name: "ScrollAreaScrollbarVisible",
  setup(n) {
    const t = T(ve), e = T(Mt), o = S({
      content: 0,
      viewport: 0,
      scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
    }), a = D(() => {
      const b = _s(o.value.viewport, o.value.content);
      return b > 0 && b < 1;
    }), s = S(), i = S(0);
    function r(b, $) {
      if (f.value) {
        const O = t.viewport.value.scrollLeft + b.deltaY;
        t.viewport.value.scrollLeft = O, la(O, $) && b.preventDefault();
      } else {
        const O = t.viewport.value.scrollTop + b.deltaY;
        t.viewport.value.scrollTop = O, la(O, $) && b.preventDefault();
      }
    }
    function u(b, $) {
      f.value ? i.value = $.x : i.value = $.y;
    }
    function d(b) {
      i.value = 0;
    }
    function p(b) {
      o.value = b;
    }
    function c(b, $) {
      return eu(
        b,
        i.value,
        o.value,
        $
      );
    }
    const f = D(
      () => e == null ? void 0 : e.isHorizontal.value
    );
    function v(b) {
      var $;
      f.value ? t.viewport.value.scrollLeft = c(
        b,
        ($ = t.dir) == null ? void 0 : $.value
      ) : t.viewport.value.scrollTop = c(b);
    }
    function h() {
      var b;
      if (f.value) {
        if (t != null && t.viewport.value && s.value) {
          const $ = t == null ? void 0 : t.viewport.value.scrollLeft, O = sa(
            $,
            o.value,
            (b = t == null ? void 0 : t.dir) == null ? void 0 : b.value
          );
          s.value.style.transform = `translate3d(${O}px, 0, 0)`;
        }
      } else if (t != null && t.viewport.value && s.value) {
        const $ = t == null ? void 0 : t.viewport.value.scrollTop, O = sa($, o.value);
        s.value.style.transform = `translate3d(0, ${O}px, 0)`;
      }
    }
    function m(b) {
      s.value = b;
    }
    return W(
      kt,
      {
        sizes: o,
        hasThumb: a,
        handleWheelScroll: r,
        handleThumbDown: u,
        handleThumbUp: d,
        handleSizeChange: p,
        onThumbPositionChange: h,
        onThumbChange: m,
        onDragScroll: v
      }
    ), (b, $) => f.value ? (g(), C(tu, N(k({ key: 0 }, b.$attrs)), {
      default: y(() => [
        _(b.$slots, "default")
      ]),
      _: 3
    }, 16)) : (g(), C(nu, N(k({ key: 1 }, b.$attrs)), {
      default: y(() => [
        _(b.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Cs = /* @__PURE__ */ w({
  __name: "ScrollAreaScrollbarAuto",
  setup(n) {
    const t = T(ve), e = T(Mt), o = S(!1), a = qn(() => {
      if (t != null && t.viewport.value) {
        const s = (t == null ? void 0 : t.viewport.value.offsetWidth) < (t == null ? void 0 : t.viewport.value.scrollWidth), i = (t == null ? void 0 : t.viewport.value.offsetHeight) < (t == null ? void 0 : t.viewport.value.scrollHeight);
        o.value = e != null && e.isHorizontal.value ? s : i;
      }
    }, 10);
    return Y(() => a()), Be(t == null ? void 0 : t.viewport, a), Be(t == null ? void 0 : t.content, a), (s, i) => o.value ? (g(), C(Vo, k({ key: 0 }, s.$attrs, {
      "data-state": o.value ? "visible" : "hidden"
    }), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["data-state"])) : J("", !0);
  }
}), ou = {
  inheritAttrs: !1
}, au = /* @__PURE__ */ w({
  ...ou,
  __name: "ScrollAreaScrollbarHover",
  setup(n) {
    const t = T(ve);
    let e;
    const o = S(!1);
    function a() {
      window.clearTimeout(e), o.value = !0;
    }
    function s() {
      e = window.setTimeout(() => {
        o.value = !1;
      }, t == null ? void 0 : t.scrollHideDelay.value);
    }
    return Y(() => {
      const i = t == null ? void 0 : t.scrollArea.value;
      i && (i.addEventListener("pointerenter", a), i.addEventListener("pointerleave", s));
    }), ue(() => {
      const i = t == null ? void 0 : t.scrollArea.value;
      i && (window.clearTimeout(e), i.removeEventListener("pointerenter", a), i.removeEventListener("pointerleave", s));
    }), (i, r) => o.value ? (g(), C(Cs, k({ key: 0 }, i.$attrs, {
      "data-state": o.value ? "visible" : "hidden"
    }), {
      default: y(() => [
        _(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["data-state"])) : J("", !0);
  }
}), su = /* @__PURE__ */ w({
  __name: "ScrollAreaScrollbarScroll",
  setup(n) {
    const t = T(ve), e = T(Mt), { state: o, dispatch: a } = ga("hidden", {
      hidden: {
        SCROLL: "scrolling"
      },
      scrolling: {
        SCROLL_END: "idle",
        POINTER_ENTER: "interacting"
      },
      interacting: {
        SCROLL: "interacting",
        POINTER_LEAVE: "idle"
      },
      idle: {
        HIDE: "hidden",
        SCROLL: "scrolling",
        POINTER_ENTER: "interacting"
      }
    });
    ee(() => {
      o.value === "idle" && window.setTimeout(
        () => a("HIDE"),
        t == null ? void 0 : t.scrollHideDelay.value
      );
    });
    const s = qn(() => a("SCROLL_END"), 100);
    return ee(() => {
      const i = t == null ? void 0 : t.viewport.value, r = e != null && e.isHorizontal.value ? "scrollLeft" : "scrollTop";
      if (i) {
        let u = i[r];
        const d = () => {
          const p = i[r];
          u !== p && (a("SCROLL"), s()), u = p;
        };
        i.addEventListener("scroll", d);
      }
    }), (i, r) => l(o) !== "hidden" ? (g(), C(Vo, N(k({ key: 0 }, i.$attrs)), {
      default: y(() => [
        _(i.$slots, "default")
      ]),
      _: 3
    }, 16)) : J("", !0);
  }
}), Mt = Symbol(), lu = {
  inheritAttrs: !1
}, vp = /* @__PURE__ */ w({
  ...lu,
  __name: "ScrollAreaScrollbar",
  props: {
    orientation: { default: "vertical" },
    forceMount: { type: Boolean, default: void 0 },
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(n) {
    const t = n, e = T(ve), o = D(() => t.orientation === "horizontal");
    X(
      o,
      () => {
        o.value ? e == null || e.onScrollbarXEnabledChange(!0) : e == null || e.onScrollbarYEnabledChange(!0);
      },
      { immediate: !0 }
    ), ue(() => {
      e == null || e.onScrollbarXEnabledChange(!1), e == null || e.onScrollbarYEnabledChange(!1);
    });
    const { orientation: a, forceMount: s, asChild: i, as: r } = G(t);
    return W(Mt, {
      orientation: a,
      forceMount: s,
      isHorizontal: o,
      as: r,
      asChild: i
    }), (u, d) => {
      var p, c, f, v;
      return ((p = l(e)) == null ? void 0 : p.type.value) === "hover" ? (g(), C(au, k({ key: 0 }, u.$attrs, { "force-mount": l(s) }), {
        default: y(() => [
          _(u.$slots, "default")
        ]),
        _: 3
      }, 16, ["force-mount"])) : ((c = l(e)) == null ? void 0 : c.type.value) === "scroll" ? (g(), C(su, k({ key: 1 }, u.$attrs, { "force-mount": l(s) }), {
        default: y(() => [
          _(u.$slots, "default")
        ]),
        _: 3
      }, 16, ["force-mount"])) : ((f = l(e)) == null ? void 0 : f.type.value) === "auto" ? (g(), C(Cs, k({ key: 2 }, u.$attrs, { "force-mount": l(s) }), {
        default: y(() => [
          _(u.$slots, "default")
        ]),
        _: 3
      }, 16, ["force-mount"])) : ((v = l(e)) == null ? void 0 : v.type.value) === "always" ? (g(), C(Vo, k({ key: 3 }, u.$attrs, {
        "data-state": "visible",
        "force-mount": l(s)
      }), {
        default: y(() => [
          _(u.$slots, "default")
        ]),
        _: 3
      }, 16, ["force-mount"])) : J("", !0);
    };
  }
}), mp = /* @__PURE__ */ w({
  __name: "ScrollAreaThumb",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, e = T(ve), o = T(
      kt
    );
    function a(f) {
      const h = f.target.getBoundingClientRect(), m = f.clientX - h.left, b = f.clientY - h.top;
      o == null || o.handleThumbDown(f, { x: m, y: b });
    }
    function s(f) {
      o == null || o.handleThumbUp(f);
    }
    const { primitiveElement: i, currentElement: r } = H(), u = S(), d = D(() => e == null ? void 0 : e.viewport.value);
    function p() {
      if (!u.value) {
        const f = Qr(
          d.value,
          o == null ? void 0 : o.onThumbPositionChange
        );
        u.value = f, o == null || o.onThumbPositionChange();
      }
    }
    const c = D(() => o == null ? void 0 : o.sizes.value);
    return Ys(c, () => {
      o == null || o.onThumbChange(r.value), d.value && (o == null || o.onThumbPositionChange(), d.value.addEventListener("scroll", p));
    }), ue(() => {
      var f;
      d.value.removeEventListener("scroll", p), (f = e == null ? void 0 : e.viewport.value) == null || f.removeEventListener("scroll", p);
    }), (f, v) => {
      var h;
      return g(), C(l(M), {
        ref_key: "primitiveElement",
        ref: i,
        "data-state": (h = l(o)) != null && h.hasThumb ? "visible" : "hidden",
        style: ie({
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)"
        }),
        "as-child": t.asChild,
        as: f.as,
        onPointerdown: a,
        onPointerup: s
      }, {
        default: y(() => [
          _(f.$slots, "default")
        ]),
        _: 3
      }, 8, ["data-state", "style", "as-child", "as"]);
    };
  }
}), iu = /* @__PURE__ */ w({
  __name: "ScrollAreaCornerImpl",
  setup(n) {
    const t = T(ve), e = S(0), o = S(0), a = D(() => !!e.value && !!o.value);
    function s() {
      var u;
      const r = ((u = t == null ? void 0 : t.scrollbarX.value) == null ? void 0 : u.offsetHeight) || 0;
      t == null || t.onCornerHeightChange(r), o.value = r;
    }
    function i() {
      var u;
      const r = ((u = t == null ? void 0 : t.scrollbarY.value) == null ? void 0 : u.offsetWidth) || 0;
      t == null || t.onCornerWidthChange(r), e.value = r;
    }
    return Be(t == null ? void 0 : t.scrollbarX.value, s), Be(t == null ? void 0 : t.scrollbarY.value, i), X(() => t == null ? void 0 : t.scrollbarX.value, s), X(() => t == null ? void 0 : t.scrollbarY.value, i), (r, u) => {
      var d;
      return a.value ? (g(), C(l(M), k({
        key: 0,
        style: {
          width: `${e.value}px`,
          height: `${o.value}px`,
          position: "absolute",
          right: l(t).dir.value === "ltr" ? 0 : void 0,
          left: l(t).dir.value === "rtl" ? 0 : void 0,
          bottom: 0
        }
      }, (d = r.$parent) == null ? void 0 : d.$props), {
        default: y(() => [
          _(r.$slots, "default")
        ]),
        _: 3
      }, 16, ["style"])) : J("", !0);
    };
  }
}), hp = /* @__PURE__ */ w({
  __name: "ScrollAreaCorner",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(n) {
    const t = n, e = T(ve), o = D(
      () => !!(e != null && e.scrollbarX.value) && !!e.scrollbarY.value
    ), a = D(
      () => (e == null ? void 0 : e.type.value) !== "scroll" && o.value
    );
    return (s, i) => a.value ? (g(), C(iu, N(k({ key: 0 }, t)), {
      default: y(() => [
        _(s.$slots, "default")
      ]),
      _: 3
    }, 16)) : J("", !0);
  }
});
export {
  pu as AccordionContent,
  fu as AccordionHeader,
  cu as AccordionItem,
  du as AccordionRoot,
  vu as AccordionTrigger,
  fd as AlertDialogAction,
  dd as AlertDialogCancel,
  rd as AlertDialogContent,
  pd as AlertDialogDescription,
  ud as AlertDialogOverlay,
  id as AlertDialogPortal,
  sd as AlertDialogRoot,
  cd as AlertDialogTitle,
  ld as AlertDialogTrigger,
  Ru as AspectRatio,
  Pd as AvatarFallback,
  Sd as AvatarImage,
  Od as AvatarRoot,
  hu as CheckboxIndicator,
  mu as CheckboxRoot,
  fl as CollapsibleContent,
  ul as CollapsibleRoot,
  dl as CollapsibleTrigger,
  Au as ComboboxArrow,
  wu as ComboboxCancel,
  $u as ComboboxContent,
  Ou as ComboboxEmpty,
  Cu as ComboboxGroup,
  bu as ComboboxHeader,
  gu as ComboboxInput,
  Pu as ComboboxItem,
  Tu as ComboboxItemIndicator,
  Eu as ComboboxLabel,
  Iu as ComboboxPortal,
  yu as ComboboxRoot,
  Bu as ComboboxSeparator,
  _u as ComboboxTrigger,
  Su as ComboboxViewport,
  pc as ContextMenuArrow,
  hc as ContextMenuCheckboxItem,
  cc as ContextMenuContent,
  vc as ContextMenuGroup,
  fc as ContextMenuItem,
  yc as ContextMenuItemIndicator,
  gc as ContextMenuLabel,
  dc as ContextMenuPortal,
  bc as ContextMenuRadioGroup,
  _c as ContextMenuRadioItem,
  rc as ContextMenuRoot,
  mc as ContextMenuSeparator,
  wc as ContextMenuSub,
  Cc as ContextMenuSubContent,
  Ec as ContextMenuSubTrigger,
  uc as ContextMenuTrigger,
  os as DialogClose,
  Zi as DialogContent,
  tr as DialogDescription,
  Qi as DialogOverlay,
  ad as DialogPortal,
  Mi as DialogRoot,
  er as DialogTitle,
  Ri as DialogTrigger,
  qd as DropdownMenuArrow,
  ec as DropdownMenuCheckboxItem,
  Jd as DropdownMenuContent,
  Zd as DropdownMenuGroup,
  jd as DropdownMenuItem,
  tc as DropdownMenuItemIndicator,
  nc as DropdownMenuLabel,
  Xd as DropdownMenuPortal,
  oc as DropdownMenuRadioGroup,
  ac as DropdownMenuRadioItem,
  Yd as DropdownMenuRoot,
  Qd as DropdownMenuSeparator,
  sc as DropdownMenuSub,
  lc as DropdownMenuSubContent,
  ic as DropdownMenuSubTrigger,
  Gd as DropdownMenuTrigger,
  Nd as HoverCardArrow,
  Fd as HoverCardContent,
  Rd as HoverCardPortal,
  kd as HoverCardRoot,
  Md as HoverCardTrigger,
  Mu as Label,
  zc as MenubarArrow,
  Jc as MenubarCheckboxItem,
  Uc as MenubarContent,
  Gc as MenubarGroup,
  Yc as MenubarItem,
  qc as MenubarItemIndicator,
  jc as MenubarLabel,
  Kc as MenubarMenu,
  Wc as MenubarPortal,
  Zc as MenubarRadioGroup,
  Qc as MenubarRadioItem,
  Vc as MenubarRoot,
  Xc as MenubarSeparator,
  ep as MenubarSub,
  tp as MenubarSubContent,
  np as MenubarSubTrigger,
  Hc as MenubarTrigger,
  sp as NavigationMenuContent,
  lp as NavigationMenuIndicator,
  ap as NavigationMenuItem,
  ip as NavigationMenuLink,
  rp as NavigationMenuList,
  op as NavigationMenuRoot,
  up as NavigationMenuSub,
  dp as NavigationMenuTrigger,
  cp as NavigationMenuViewport,
  Ju as PaginationEllipsis,
  qu as PaginationFirst,
  ju as PaginationLast,
  Zu as PaginationList,
  Qu as PaginationListItem,
  ed as PaginationNext,
  td as PaginationPrev,
  Xu as PaginationRoot,
  zd as PopoverAnchor,
  Wd as PopoverArrow,
  Ud as PopoverClose,
  Hd as PopoverContent,
  Kd as PopoverPortal,
  Ld as PopoverRoot,
  Vd as PopoverTrigger,
  M as Primitive,
  od as ProgressIndicator,
  nd as ProgressRoot,
  Gu as RadioGroupIndicator,
  Yu as RadioGroupItem,
  zu as RadioGroupRoot,
  hp as ScrollAreaCorner,
  pp as ScrollAreaRoot,
  vp as ScrollAreaScrollbar,
  mp as ScrollAreaThumb,
  fp as ScrollAreaViewport,
  Bc as SelectArrow,
  Tc as SelectContent,
  xc as SelectGroup,
  Lc as SelectIcon,
  Ic as SelectItem,
  Dc as SelectItemIndicator,
  Mc as SelectItemText,
  kc as SelectLabel,
  Sc as SelectPortal,
  $c as SelectRoot,
  Fc as SelectScrollDownButton,
  Rc as SelectScrollUpButton,
  Ac as SelectSeparator,
  Oc as SelectTrigger,
  Nc as SelectValue,
  Pc as SelectViewport,
  ku as Separator,
  Uu as SliderRange,
  Ku as SliderRoot,
  Hu as SliderThumb,
  Wu as SliderTrack,
  rl as Slot,
  Du as SwitchRoot,
  xu as SwitchThumb,
  Lu as TabsContent,
  Nu as TabsList,
  Fu as TabsRoot,
  Vu as TabsTrigger,
  hd as ToastAction,
  cr as ToastClose,
  bd as ToastDescription,
  vd as ToastProvider,
  md as ToastRoot,
  gd as ToastTitle,
  yd as ToastViewport,
  ai as Toggle,
  pi as ToggleGroupItem,
  ci as ToggleGroupRoot,
  fr as ToolbarButton,
  wd as ToolbarLink,
  _d as ToolbarRoot,
  $d as ToolbarSeparator,
  Cd as ToolbarToggleGroup,
  Ed as ToolbarToggleItem,
  Dd as TooltipArrow,
  Id as TooltipContent,
  xd as TooltipPortal,
  Td as TooltipProvider,
  Bd as TooltipRoot,
  Ad as TooltipTrigger,
  ae as useEmitAsProps,
  sn as useForwardProps,
  fe as useForwardPropsEmits,
  te as useId,
  ga as useStateMachine
};
